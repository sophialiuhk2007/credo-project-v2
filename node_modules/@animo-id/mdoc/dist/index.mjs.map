{"version":3,"sources":["../src/cbor/cbor-x/decode.js","../src/cbor/cbor-x/encode.js","../src/cbor/data-item.ts","../src/cbor/index.ts","../src/u-base64.ts","../src/u-uint8-array.ts","../src/cose/typed-map.ts","../src/cose/headers.ts","../src/cose/key/curve.ts","../src/cose/key/key-ops.ts","../src/cose/key/kty.ts","../src/cose/key/params.ts","../src/cose/key/cose-key.ts","../src/mdoc/errors.ts","../src/mdoc/check-callback.ts","../src/mdoc/issuer-signed-item.ts","../src/mdoc/items-request.ts","../src/mdoc/model/device-request.ts","../src/cose/cose-base.ts","../src/cose/e-cose.ts","../src/cose/validate-algorithms.ts","../src/cose/mac0.ts","../src/cose/signature-base.ts","../src/cose/sign1.ts","../src/mdoc/parser.ts","../src/mdoc/model/issuer-signed-document.ts","../src/mdoc/model/device-signed-document.ts","../src/mdoc/model/issuer-auth.ts","../src/mdoc/model/mdoc.ts","../src/mdoc/utils.ts","../src/mdoc/model/pex-limit-disclosure.ts","../src/mdoc/model/device-response.ts","../src/mdoc/model/document.ts","../src/mdoc/verifier.ts","../src/u-hex.ts"],"sourcesContent":["let decoder\ntry {\n  decoder = new TextDecoder()\n} catch (error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000 // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nconst currentExtensions = []\nconst currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nconst defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true,\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2\nlet BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n  new Function('')\n} catch (error) {\n  // if eval variants are not supported, do not create inline object readers ever\n  inlineObjectReadThreshold = Number.POSITIVE_INFINITY\n}\n\nexport class Decoder {\n  constructor(options) {\n    if (options) {\n      if ((options.keyMap || options._keyMap) && !options.useRecords) {\n        options.useRecords = false\n        options.mapsAsObjects = true\n      }\n      if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true\n      if (options.getStructures) options.getShared = options.getStructures\n      if (options.getShared && !options.structures) (options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n      if (options.keyMap) {\n        this.mapKey = new Map()\n        for (const [k, v] of Object.entries(options.keyMap)) this.mapKey.set(v, k)\n      }\n    }\n    Object.assign(this, options)\n  }\n  /*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n  decodeKey(key) {\n    return this.keyMap ? this.mapKey.get(key) || key : key\n  }\n\n  encodeKey(key) {\n    return this.keyMap?.hasOwnProperty(key) ? this.keyMap[key] : key\n  }\n\n  encodeKeys(rec) {\n    if (!this._keyMap) return rec\n    const map = new Map()\n    for (const [k, v] of Object.entries(rec)) map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v)\n    return map\n  }\n\n  decodeKeys(map) {\n    if (!this._keyMap || map.constructor.name !== 'Map') return map\n    if (!this._mapKey) {\n      this._mapKey = new Map()\n      for (const [k, v] of Object.entries(this._keyMap)) this._mapKey.set(v, k)\n    }\n    const res = {}\n    //map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n    map.forEach((v, k) => (res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v))\n    return res\n  }\n\n  mapDecode(source, end) {\n    const res = this.decode(source)\n    if (this._keyMap) {\n      //Experiemntal support for Optimised KeyMap  decoding\n      switch (res.constructor.name) {\n        case 'Array':\n          return res.map((r) => this.decodeKeys(r))\n        //case 'Map': return this.decodeKeys(res)\n      }\n    }\n    return res\n  }\n\n  decode(source, end) {\n    if (src) {\n      // re-entrant execution, save the state and restore it after we do this decode\n      return saveState(() => {\n        clearSource()\n        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n      })\n    }\n    srcEnd = end > -1 ? end : source.length\n    position = 0\n    stringPosition = 0\n    srcStringEnd = 0\n    srcString = null\n    strings = EMPTY_ARRAY\n    bundledStrings = null\n    src = source\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView =\n        source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null\n      if (source instanceof Uint8Array) throw error\n      throw new Error(\n        `Source must be a Uint8Array or Buffer but was a ${\n          source && typeof source === 'object' ? source.constructor.name : typeof source\n        }`\n      )\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this\n      packedValues =\n        this.sharedValues &&\n        (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues)\n      if (this.structures) {\n        currentStructures = this.structures\n        return checkedRead()\n      }\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = []\n      }\n    } else {\n      currentDecoder = defaultOptions\n      if (!currentStructures || currentStructures.length > 0) currentStructures = []\n      packedValues = null\n    }\n    return checkedRead()\n  }\n  decodeMultiple(source, forEach) {\n    let values\n    let lastPosition = 0\n    try {\n      const size = source.length\n      sequentialMode = true\n      const value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n      if (forEach) {\n        if (forEach(value) === false) {\n          return\n        }\n        while (position < size) {\n          lastPosition = position\n          if (forEach(checkedRead()) === false) {\n            return\n          }\n        }\n      } else {\n        values = [value]\n        while (position < size) {\n          lastPosition = position\n          values.push(checkedRead())\n        }\n        return values\n      }\n    } catch (error) {\n      error.lastPosition = lastPosition\n      error.values = values\n      throw error\n    } finally {\n      sequentialMode = false\n      clearSource()\n    }\n  }\n}\nexport function getPosition() {\n  return position\n}\nexport function checkedRead() {\n  try {\n    const result = read()\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error('Unexpected bundle position')\n        error.incomplete = true\n        throw error\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition\n      bundledStrings = null\n    }\n\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null\n      src = null\n      if (referenceMap) referenceMap = null\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error('Unexpected end of CBOR data')\n      error.incomplete = true\n      throw error\n    } else if (!sequentialMode) {\n      throw new Error('Data read, but end of buffer not reached')\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result\n  } catch (error) {\n    clearSource()\n    if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n      error.incomplete = true\n    }\n    throw error\n  }\n}\n\nexport function read() {\n  let token = src[position++]\n  const majorType = token >> 5\n  token = token & 0x1f\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++]\n        break\n      case 0x19:\n        if (majorType === 7) {\n          return getFloat16()\n        }\n        token = dataView.getUint16(position)\n        position += 2\n        break\n      case 0x1a:\n        if (majorType === 7) {\n          const value = dataView.getFloat32(position)\n          if (currentDecoder.useFloat32 > 2) {\n            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n            const multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n            position += 4\n            return ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n          }\n          position += 4\n          return value\n        }\n        token = dataView.getUint32(position)\n        position += 4\n        break\n      case 0x1b:\n        if (majorType === 7) {\n          const value = dataView.getFloat64(position)\n          position += 8\n          return value\n        }\n        if (majorType > 1) {\n          if (dataView.getUint32(position) > 0)\n            throw new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n          token = dataView.getUint32(position + 4)\n        } else if (currentDecoder.int64AsNumber) {\n          token = dataView.getUint32(position) * 0x100000000\n          token += dataView.getUint32(position + 4)\n        } else token = dataView.getBigUint64(position)\n        position += 8\n        break\n      case 0x1f:\n        // indefinite length\n        switch (majorType) {\n          case 2: // byte string\n          case 3: // text string\n            throw new Error('Indefinite length not supported for byte or text strings')\n          case 4: {\n            // array\n            const array = []\n            let value\n            let i = 0\n            while ((value = read()) !== STOP_CODE) {\n              if (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n              array[i++] = value\n            }\n            return majorType === 4 ? array : majorType === 3 ? array.join('') : Buffer.concat(array)\n          }\n          case 5: {\n            // map\n            let key\n            if (currentDecoder.mapsAsObjects) {\n              const object = {}\n              let i = 0\n              if (currentDecoder.keyMap) {\n                while ((key = read()) !== STOP_CODE) {\n                  if (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n                  object[safeKey(currentDecoder.decodeKey(key))] = read()\n                }\n              } else {\n                while ((key = read()) !== STOP_CODE) {\n                  if (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n                  object[safeKey(key)] = read()\n                }\n              }\n              return object\n            }\n            if (restoreMapsAsObject) {\n              currentDecoder.mapsAsObjects = true\n              restoreMapsAsObject = false\n            }\n            const map = new Map()\n            if (currentDecoder.keyMap) {\n              let i = 0\n              while ((key = read()) !== STOP_CODE) {\n                if (i++ >= maxMapSize) {\n                  throw new Error(`Map size exceeds ${maxMapSize}`)\n                }\n                map.set(currentDecoder.decodeKey(key), read())\n              }\n            } else {\n              let i = 0\n              while ((key = read()) !== STOP_CODE) {\n                if (i++ >= maxMapSize) {\n                  throw new Error(`Map size exceeds ${maxMapSize}`)\n                }\n                map.set(key, read())\n              }\n            }\n            return map\n          }\n          case 7:\n            return STOP_CODE\n          default:\n            throw new Error(`Invalid major type for indefinite length ${majorType}`)\n        }\n      default:\n        throw new Error(`Unknown token ${token}`)\n    }\n  }\n  switch (majorType) {\n    case 0: // positive int\n      return token\n    case 1: // negative int\n      return ~token\n    case 2: // buffer\n      return readBin(token)\n    case 3: // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n        if (string != null) return string\n      }\n      return readFixedString(token)\n    case 4: {\n      // array\n      if (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n      const array = new Array(token)\n      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\n      //else\n      for (let i = 0; i < token; i++) array[i] = read()\n      return array\n    }\n    case 5: {\n      // map\n      if (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n      if (currentDecoder.mapsAsObjects) {\n        const object = {}\n        if (currentDecoder.keyMap)\n          for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n        else for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n        return object\n      }\n      if (restoreMapsAsObject) {\n        currentDecoder.mapsAsObjects = true\n        restoreMapsAsObject = false\n      }\n      const map = new Map()\n      if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()), read())\n      else for (let i = 0; i < token; i++) map.set(read(), read())\n      return map\n    }\n    case 6: {\n      // extension\n      if (token >= BUNDLED_STRINGS_ID) {\n        let structure = currentStructures[token & 0x1fff] // check record structures first\n        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n        if (structure) {\n          if (!structure.read) structure.read = createStructureReader(structure)\n          return structure.read()\n        }\n        if (token < 0x10000) {\n          if (token === RECORD_INLINE_ID) {\n            // we do a special check for this so that we can keep the\n            // currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n            const length = readJustLength()\n            const id = read()\n            const structure = read()\n            recordDefinition(id, structure)\n            const object = {}\n            if (currentDecoder.keyMap)\n              for (let i = 2; i < length; i++) {\n                const key = currentDecoder.decodeKey(structure[i - 2])\n                object[safeKey(key)] = read()\n              }\n            else\n              for (let i = 2; i < length; i++) {\n                const key = structure[i - 2]\n                object[safeKey(key)] = read()\n              }\n            return object\n          }\n          if (token === RECORD_DEFINITIONS_ID) {\n            const length = readJustLength()\n            let id = read()\n            for (let i = 2; i < length; i++) {\n              recordDefinition(id++, read())\n            }\n            return read()\n          }\n          if (token === BUNDLED_STRINGS_ID) {\n            return readBundleExt()\n          }\n          if (currentDecoder.getShared) {\n            loadShared()\n            structure = currentStructures[token & 0x1fff]\n            if (structure) {\n              if (!structure.read) structure.read = createStructureReader(structure)\n              return structure.read()\n            }\n          }\n        }\n      }\n      const extension = currentExtensions[token]\n      if (extension) {\n        if (extension.handlesRead) return extension(read)\n        return extension(read())\n      }\n      const input = read()\n      for (let i = 0; i < currentExtensionRanges.length; i++) {\n        const value = currentExtensionRanges[i](token, input)\n        if (value !== undefined) return value\n      }\n      return new Tag(input, token)\n    }\n    case 7: // fixed value\n      switch (token) {\n        case 0x14:\n          return false\n        case 0x15:\n          return true\n        case 0x16:\n          return null\n        case 0x17:\n          return // undefined\n        default: {\n          const packedValue = (packedValues || getPackedValues())[token]\n          if (packedValue !== undefined) return packedValue\n          throw new Error(`Unknown token ${token}`)\n        }\n      }\n    default: // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error('Unexpected end of CBOR data')\n        error.incomplete = true\n        throw error\n      }\n      throw new Error(`Unknown CBOR token ${token}`)\n  }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n  if (!structure) throw new Error('Structure is required in record definition')\n  function readObject() {\n    // get the array size from the header\n    let length = src[position++]\n    //let majorType = token >> 5\n    length = length & 0x1f\n    if (length > 0x17) {\n      switch (length) {\n        case 0x18:\n          length = src[position++]\n          break\n        case 0x19:\n          length = dataView.getUint16(position)\n          position += 2\n          break\n        case 0x1a:\n          length = dataView.getUint32(position)\n          position += 4\n          break\n        default:\n          throw new Error(`Expected array header, but got ${src[position - 1]}`)\n      }\n    }\n    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n    let compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n    while (compiledReader) {\n      // we have a fast compiled object literal reader\n      if (compiledReader.propertyCount === length) return compiledReader(read) // with the right length, so we use it\n      compiledReader = compiledReader.next // see if there is another reader with the right length\n    }\n    if (this.slowReads++ >= inlineObjectReadThreshold) {\n      // create a fast compiled reader\n      const array = this.length === length ? this : this.slice(0, length)\n      compiledReader = currentDecoder.keyMap\n        ? new Function(\n            'r',\n            `return {${array\n              .map((k) => currentDecoder.decodeKey(k))\n              .map((k) => (validName.test(k) ? `${safeKey(k)}:r()` : `[${JSON.stringify(k)}]:r()`))\n              .join(',')}}`\n          )\n        : new Function(\n            'r',\n            `return {${array\n              .map((key) => (validName.test(key) ? `${safeKey(key)}:r()` : `[${JSON.stringify(key)}]:r()`))\n              .join(',')}}`\n          )\n      if (this.compiledReader) compiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n      compiledReader.propertyCount = length\n      this.compiledReader = compiledReader\n      return compiledReader(read)\n    }\n    const object = {}\n    if (currentDecoder.keyMap)\n      for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n    else\n      for (let i = 0; i < length; i++) {\n        object[safeKey(this[i])] = read()\n      }\n    return object\n  }\n  structure.slowReads = 0\n  return readObject\n}\n\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n  if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString()\n  if (key == null) return `${key}`\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`)\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n  isNativeAccelerationEnabled = true\n  readFixedString = readString(1)\n  readString8 = readString(2)\n  readString16 = readString(3)\n  readString32 = readString(5)\n  function readString(headerLength) {\n    return function readString(length) {\n      let string = strings[stringPosition++]\n      if (string == null) {\n        if (bundledStrings) return readStringJS(length)\n        const extraction = extractStrings(position, srcEnd, length, src)\n        if (typeof extraction === 'string') {\n          string = extraction\n          strings = EMPTY_ARRAY\n        } else {\n          strings = extraction\n          stringPosition = 1\n          srcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n          string = strings[0]\n          if (string === undefined) throw new Error('Unexpected end of buffer')\n        }\n      }\n      const srcStringLength = string.length\n      if (srcStringLength <= length) {\n        position += length\n        return string\n      }\n      srcString = string\n      srcStringStart = position\n      srcStringEnd = position + srcStringLength\n      position += length\n      return string.slice(0, length) // we know we just want the beginning\n    }\n  }\n}\nfunction readStringJS(length) {\n  let result\n  if (length < 16) {\n    if ((result = shortStringInJS(length))) return result\n  }\n  if (length > 64 && decoder) return decoder.decode(src.subarray(position, (position += length)))\n  const end = position + length\n  const units = []\n  result = ''\n  while (position < end) {\n    const byte1 = src[position++]\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1)\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f\n      units.push(((byte1 & 0x1f) << 6) | byte2)\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f\n      const byte3 = src[position++] & 0x3f\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f\n      const byte3 = src[position++] & 0x3f\n      const byte4 = src[position++] & 0x3f\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n      if (unit > 0xffff) {\n        unit -= 0x10000\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800)\n        unit = 0xdc00 | (unit & 0x3ff)\n      }\n      units.push(unit)\n    } else {\n      units.push(byte1)\n    }\n\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units)\n      units.length = 0\n    }\n  }\n\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units)\n  }\n\n  return result\n}\nconst fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n  const start = position\n  const bytes = new Array(length)\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++]\n    if ((byte & 0x80) > 0) {\n      position = start\n      return\n    }\n    bytes[i] = byte\n  }\n  return fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) return ''\n\n      const a = src[position++]\n      if ((a & 0x80) > 1) {\n        position -= 1\n        return\n      }\n      return fromCharCode(a)\n    }\n    const a = src[position++]\n    const b = src[position++]\n    if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n      position -= 2\n      return\n    }\n    if (length < 3) return fromCharCode(a, b)\n    const c = src[position++]\n    if ((c & 0x80) > 0) {\n      position -= 3\n      return\n    }\n    return fromCharCode(a, b, c)\n  }\n  const a = src[position++]\n  const b = src[position++]\n  const c = src[position++]\n  const d = src[position++]\n  if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n    position -= 4\n    return\n  }\n  if (length < 6) {\n    if (length === 4) return fromCharCode(a, b, c, d)\n\n    const e = src[position++]\n    if ((e & 0x80) > 0) {\n      position -= 5\n      return\n    }\n    return fromCharCode(a, b, c, d, e)\n  }\n  if (length < 8) {\n    const e = src[position++]\n    const f = src[position++]\n    if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n      position -= 6\n      return\n    }\n    if (length < 7) return fromCharCode(a, b, c, d, e, f)\n    const g = src[position++]\n    if ((g & 0x80) > 0) {\n      position -= 7\n      return\n    }\n    return fromCharCode(a, b, c, d, e, f, g)\n  }\n  const e = src[position++]\n  const f = src[position++]\n  const g = src[position++]\n  const h = src[position++]\n  if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n    position -= 8\n    return\n  }\n  if (length < 10) {\n    if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h)\n\n    const i = src[position++]\n    if ((i & 0x80) > 0) {\n      position -= 9\n      return\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i)\n  }\n  if (length < 12) {\n    const i = src[position++]\n    const j = src[position++]\n    if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n      position -= 10\n      return\n    }\n    if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j)\n    const k = src[position++]\n    if ((k & 0x80) > 0) {\n      position -= 11\n      return\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n  }\n  const i = src[position++]\n  const j = src[position++]\n  const k = src[position++]\n  const l = src[position++]\n  if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n    position -= 12\n    return\n  }\n  if (length < 14) {\n    if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\n    const m = src[position++]\n    if ((m & 0x80) > 0) {\n      position -= 13\n      return\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n  }\n  const m = src[position++]\n  const n = src[position++]\n  if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n    position -= 14\n    return\n  }\n  if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n  const o = src[position++]\n  if ((o & 0x80) > 0) {\n    position -= 15\n    return\n  }\n  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n}\n\nfunction readBin(length) {\n  return currentDecoder.copyBuffers\n    ? // specifically use the copying slice (not the node one)\n      Uint8Array.prototype.slice.call(src, position, (position += length))\n    : src.subarray(position, (position += length))\n}\nfunction readExt(length) {\n  const type = src[position++]\n  if (currentExtensions[type]) {\n    return currentExtensions[type](src.subarray(position, (position += length)))\n  }\n  throw new Error(`Unknown extension type ${type}`)\n}\nconst f32Array = new Float32Array(1)\nconst u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n  const byte0 = src[position++]\n  const byte1 = src[position++]\n  const exponent = (byte0 & 0x7f) >> 2\n  if (exponent === 0x1f) {\n    // specials\n    if (byte1 || byte0 & 3) return Number.NaN\n    return byte0 & 0x80 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY\n  }\n  if (exponent === 0) {\n    // sub-normals\n    // significand with 10 fractional bits and divided by 2^14\n    const abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n    return byte0 & 0x80 ? -abs : abs\n  }\n\n  u8Array[3] =\n    (byte0 & 0x80) | // sign bit\n    ((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n  u8Array[2] =\n    ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n    (byte1 >> 3) // next 5 bits of mantissa\n  u8Array[1] = byte1 << 5 // last three bits of mantissa\n  u8Array[0] = 0\n  return f32Array[0]\n}\n\nconst keyCache = new Array(4096)\nfunction readKey() {\n  let length = src[position++]\n  if (length >= 0x60 && length < 0x78) {\n    // fixstr, potentially use key cache\n    length = length - 0x60\n    if (srcStringEnd >= position)\n      // if it has been extracted, must use it (and faster anyway)\n      return srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n    if (!(srcStringEnd === 0 && srcEnd < 180)) return readFixedString(length)\n  } else {\n    // not cacheable, go back and do a standard read\n    position--\n    return read()\n  }\n  const key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n  let entry = keyCache[key]\n  let checkPosition = position\n  let end = position + length - 3\n  let chunk\n  let i = 0\n  if (entry && entry.bytes === length) {\n    while (checkPosition < end) {\n      chunk = dataView.getUint32(checkPosition)\n      if (chunk !== entry[i++]) {\n        checkPosition = 0x70000000\n        break\n      }\n      checkPosition += 4\n    }\n    end += 3\n    while (checkPosition < end) {\n      chunk = src[checkPosition++]\n      if (chunk !== entry[i++]) {\n        checkPosition = 0x70000000\n        break\n      }\n    }\n    if (checkPosition === end) {\n      position = checkPosition\n      return entry.string\n    }\n    end -= 3\n    checkPosition = position\n  }\n  entry = []\n  keyCache[key] = entry\n  entry.bytes = length\n  while (checkPosition < end) {\n    chunk = dataView.getUint32(checkPosition)\n    entry.push(chunk)\n    checkPosition += 4\n  }\n  end += 3\n  while (checkPosition < end) {\n    chunk = src[checkPosition++]\n    entry.push(chunk)\n  }\n  // for small blocks, avoiding the overhead of the extract call is helpful\n  const string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n  if (string != null) return (entry.string = string)\n  return (entry.string = readFixedString(length))\n}\n\nexport class Tag {\n  constructor(value, tag) {\n    this.value = value\n    this.tag = tag\n  }\n}\n\ncurrentExtensions[0] = (dateString) => {\n  // string date extension\n  return new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n  // numeric date extension\n  return new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n  // bigint extension\n  let value = BigInt(0)\n  for (let i = 0, l = buffer.byteLength; i < l; i++) {\n    value = BigInt(buffer[i]) + (value << BigInt(8))\n  }\n  return value\n}\n\ncurrentExtensions[3] = (buffer) => {\n  // negative bigint extension\n  return BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n  // best to reparse to maintain accuracy\n  return +`${fraction[1]}e${fraction[0]}`\n}\n\ncurrentExtensions[5] = (fraction) => {\n  // probably not sufficiently accurate\n  return fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n  id = id - 0xe000\n  const existingStructure = currentStructures[id]\n  if (existingStructure?.isShared) {\n    ;(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n  }\n  currentStructures[id] = structure\n\n  structure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n  const length = data.length\n  const structure = data[1]\n  recordDefinition(data[0], structure)\n  const object = {}\n  for (let i = 2; i < length; i++) {\n    const key = structure[i - 2]\n    object[safeKey(key)] = data[i]\n  }\n  return object\n}\ncurrentExtensions[14] = (value) => {\n  if (bundledStrings) return bundledStrings[0].slice(bundledStrings.position0, (bundledStrings.position0 += value))\n  return new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n  if (bundledStrings) return bundledStrings[1].slice(bundledStrings.position1, (bundledStrings.position1 += value))\n  return new Tag(value, 15)\n}\nconst glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n  if (src[position++] !== 0x84) {\n    const error = new Error('Packed values structure must be followed by a 4 element array')\n    if (src.length < position) error.incomplete = true\n    throw error\n  }\n  const newPackedValues = read() // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error('Packed values structure must be followed by a 4 element array')\n    error.incomplete = true\n    throw error\n  }\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n  packedValues.prefixes = read()\n  packedValues.suffixes = read()\n  return read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {\n  // packed reference\n  if (!packedValues) {\n    if (currentDecoder.getShared) loadShared()\n    else return new Tag(data, PACKED_REFERENCE_TAG_ID)\n  }\n  if (typeof data === 'number') return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)]\n  const error = new Error('No support for non-integer packed references yet')\n  if (data === undefined) error.incomplete = true\n  throw error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map()\n    referenceMap.id = 0\n  }\n  const id = referenceMap.id++\n  const startingPosition = position\n  const token = src[position]\n  let target\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) target = []\n  else target = {}\n\n  const refEntry = { target } // a placeholder object\n  referenceMap.set(id, refEntry)\n  let targetProperties = read() // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    if (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n      // this means that the returned target does not match the targetProperties, so we need rerun the read to\n      // have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n      // target\n      // reset the position so that the read can be repeated\n      position = startingPosition\n      // the returned instance is our new target for references\n      target = targetProperties\n      referenceMap.set(id, { target })\n      targetProperties = read()\n    }\n    return Object.assign(target, targetProperties)\n  }\n  refEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n  const refEntry = referenceMap.get(id)\n  refEntry.used = true\n  return refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array) // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n;(currentExtensions[259] = (read) => {\n  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n  // for decoding as a standard Map\n  if (currentDecoder.mapsAsObjects) {\n    currentDecoder.mapsAsObjects = false\n    restoreMapsAsObject = true\n  }\n  return read()\n}).handlesRead = true\nfunction combine(a, b) {\n  if (typeof a === 'string') return a + b\n  if (Array.isArray(a)) return a.concat(b)\n  return Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n  if (!packedValues) {\n    if (currentDecoder.getShared) loadShared()\n    else throw new Error('No packed values available')\n  }\n  return packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n  if (tag >= 225 && tag <= 255) return combine(getPackedValues().prefixes[tag - 224], input)\n  if (tag >= 28704 && tag <= 32767) return combine(getPackedValues().prefixes[tag - 28672], input)\n  if (tag >= 1879052288 && tag <= 2147483647) return combine(getPackedValues().prefixes[tag - 1879048192], input)\n  if (tag >= 216 && tag <= 223) return combine(input, getPackedValues().suffixes[tag - 216])\n  if (tag >= 27647 && tag <= 28671) return combine(input, getPackedValues().suffixes[tag - 27639])\n  if (tag >= 1811940352 && tag <= 1879048191) return combine(input, getPackedValues().suffixes[tag - 1811939328])\n  if (tag === SHARED_DATA_TAG_ID) {\n    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n    return {\n      packedValues: packedValues,\n      structures: currentStructures.slice(0),\n      version: input,\n    }\n  }\n  if (tag === 55799)\n    // self-descriptive CBOR tag, just return input value\n    return input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1\nexport const typedArrays = [\n  Uint8Array,\n  Uint8ClampedArray,\n  Uint16Array,\n  Uint32Array,\n  typeof BigUint64Array === 'undefined' ? { name: 'BigUint64Array' } : BigUint64Array,\n  Int8Array,\n  Int16Array,\n  Int32Array,\n  typeof BigInt64Array === 'undefined' ? { name: 'BigInt64Array' } : BigInt64Array,\n  Float32Array,\n  Float64Array,\n]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n  registerTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n  const dvMethod = `get${TypedArray.name.slice(0, -5)}`\n  let bytesPerElement\n  if (typeof TypedArray === 'function') bytesPerElement = TypedArray.BYTES_PER_ELEMENT\n  else TypedArray = null\n  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n    if (!littleEndian && bytesPerElement === 1) continue\n    const sizeShift = bytesPerElement === 2 ? 1 : bytesPerElement === 4 ? 2 : bytesPerElement === 8 ? 3 : 0\n    currentExtensions[littleEndian ? tag : tag - 4] =\n      bytesPerElement === 1 || littleEndian === isLittleEndianMachine\n        ? (buffer) => {\n            if (!TypedArray) throw new Error(`Could not find typed array for code ${tag}`)\n            if (!currentDecoder.copyBuffers) {\n              // try provide a direct view, but will only work if we are byte-aligned\n              if (\n                bytesPerElement === 1 ||\n                (bytesPerElement === 2 && !(buffer.byteOffset & 1)) ||\n                (bytesPerElement === 4 && !(buffer.byteOffset & 3)) ||\n                (bytesPerElement === 8 && !(buffer.byteOffset & 7))\n              )\n                return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift)\n            }\n            // we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n            return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n          }\n        : (buffer) => {\n            if (!TypedArray) throw new Error(`Could not find typed array for code ${tag}`)\n            const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n            const elements = buffer.length >> sizeShift\n            const ta = new TypedArray(elements)\n            const method = dv[dvMethod]\n            for (let i = 0; i < elements; i++) {\n              ta[i] = method.call(dv, i << sizeShift, littleEndian)\n            }\n            return ta\n          }\n  }\n}\n\nfunction readBundleExt() {\n  const length = readJustLength()\n  const bundlePosition = position + read()\n  for (let i = 2; i < length; i++) {\n    // skip past bundles that were already read\n    const bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n    position += bundleLength\n  }\n  const dataPosition = position\n  position = bundlePosition\n  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n  bundledStrings.position0 = 0\n  bundledStrings.position1 = 0\n  bundledStrings.postBundlePosition = position\n  position = dataPosition\n  return read()\n}\n\nfunction readJustLength() {\n  let token = src[position++] & 0x1f\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++]\n        break\n      case 0x19:\n        token = dataView.getUint16(position)\n        position += 2\n        break\n      case 0x1a:\n        token = dataView.getUint32(position)\n        position += 4\n        break\n    }\n  }\n  return token\n}\n\nfunction loadShared() {\n  if (currentDecoder.getShared) {\n    const sharedData =\n      saveState(() => {\n        // save the state in case getShared modifies our buffer\n        src = null\n        return currentDecoder.getShared()\n      }) || {}\n    const updatedStructures = sharedData.structures || []\n    currentDecoder.sharedVersion = sharedData.version\n    packedValues = currentDecoder.sharedValues = sharedData.packedValues\n    if (currentStructures === true) currentDecoder.structures = currentStructures = updatedStructures\n    else currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n  }\n}\n\nfunction saveState(callback) {\n  const savedSrcEnd = srcEnd\n  const savedPosition = position\n  const savedStringPosition = stringPosition\n  const savedSrcStringStart = srcStringStart\n  const savedSrcStringEnd = srcStringEnd\n  const savedSrcString = srcString\n  const savedStrings = strings\n  const savedReferenceMap = referenceMap\n  const savedBundledStrings = bundledStrings\n\n  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n  const savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n  const savedStructures = currentStructures\n  const savedDecoder = currentDecoder\n  const savedSequentialMode = sequentialMode\n  const value = callback()\n  srcEnd = savedSrcEnd\n  position = savedPosition\n  stringPosition = savedStringPosition\n  srcStringStart = savedSrcStringStart\n  srcStringEnd = savedSrcStringEnd\n  srcString = savedSrcString\n  strings = savedStrings\n  referenceMap = savedReferenceMap\n  bundledStrings = savedBundledStrings\n  src = savedSrc\n  sequentialMode = savedSequentialMode\n  currentStructures = savedStructures\n  currentDecoder = savedDecoder\n  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n  return value\n}\nexport function clearSource() {\n  src = null\n  referenceMap = null\n  currentStructures = null\n}\n\nexport function addExtension(extension) {\n  currentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n  if (limits.maxMapSize) maxMapSize = limits.maxMapSize\n  if (limits.maxArraySize) maxArraySize = limits.maxArraySize\n  if (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = +`1e${Math.floor(45.15 - i * 0.30103)}`\n}\nconst defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n  NEVER: 0,\n  ALWAYS: 1,\n  DECIMAL_ROUND: 3,\n  DECIMAL_FIT: 4,\n}\nexport function roundFloat32(float32Number) {\n  f32Array[0] = float32Number\n  const multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n  return ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Decoder, FLOAT32_OPTIONS, Tag, addExtension as decodeAddExtension, mult10 } from './decode.js'\nlet textEncoder\ntry {\n  textEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions\nlet extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nconst serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n  constructor(options) {\n    super(options)\n    this.offset = 0\n    let typeBuffer\n    let start\n    let sharedStructures\n    let hasSharedUpdate\n    let structures\n    let referenceMap\n    options = options || {}\n    const encodeUtf8 = ByteArray.prototype.utf8Write\n      ? (string, position, maxBytes) => target.utf8Write(string, position, maxBytes)\n      : textEncoder?.encodeInto\n        ? (string, position) => textEncoder.encodeInto(string, target.subarray(position)).written\n        : false\n\n    const encoder = this\n    const hasSharedStructures = options.structures || options.saveStructures\n    let maxSharedStructures = options.maxSharedStructures\n    if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0\n    if (maxSharedStructures > 8190) throw new Error('Maximum maxSharedStructure is 8190')\n    const isSequential = options.sequential\n    if (isSequential) {\n      maxSharedStructures = 0\n    }\n    if (!this.structures) this.structures = []\n    if (this.saveStructures) this.saveShared = this.saveStructures\n    let samplingPackedValues\n    let packedObjectMap\n    let sharedValues = options.sharedValues\n    let sharedPackedObjectMap\n    if (sharedValues) {\n      sharedPackedObjectMap = Object.create(null)\n      for (let i = 0, l = sharedValues.length; i < l; i++) {\n        sharedPackedObjectMap[sharedValues[i]] = i\n      }\n    }\n    let recordIdsToRemove = []\n    let transitionsCount = 0\n    let serializationsSinceTransitionRebuild = 0\n\n    this.mapEncode = function (value, encodeOptions) {\n      // Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n      if (this._keyMap && !this._mapped) {\n        //console.log('encoding ', value)\n        switch (value.constructor.name) {\n          case 'Array':\n            value = value.map((r) => this.encodeKeys(r))\n            break\n          //case 'Map':\n          //\tvalue = this.encodeKeys(value)\n          //\tbreak\n        }\n        //this._mapped = true\n      }\n      return this.encode(value, encodeOptions)\n    }\n\n    this.encode = (value, encodeOptions) => {\n      if (!target) {\n        target = new ByteArrayAllocate(8192)\n        targetView = new DataView(target.buffer, 0, 8192)\n        position = 0\n      }\n      safeEnd = target.length - 10\n      if (safeEnd - position < 0x800) {\n        // don't start too close to the end,\n        target = new ByteArrayAllocate(target.length)\n        targetView = new DataView(target.buffer, 0, target.length)\n        safeEnd = target.length - 10\n        position = 0\n      } else if (encodeOptions === REUSE_BUFFER_MODE) position = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n      start = position\n      if (encoder.useSelfDescribedHeader) {\n        targetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n        position += 3\n      }\n      referenceMap = encoder.structuredClone ? new Map() : null\n      if (encoder.bundleStrings && typeof value !== 'string') {\n        bundledStrings = []\n        bundledStrings.size = Number.POSITIVE_INFINITY // force a new bundle start on first string\n      } else bundledStrings = null\n\n      sharedStructures = encoder.structures\n      if (sharedStructures) {\n        if (sharedStructures.uninitialized) {\n          const sharedData = encoder.getShared() || {}\n          encoder.structures = sharedStructures = sharedData.structures || []\n          encoder.sharedVersion = sharedData.version\n          const sharedValues = (encoder.sharedValues = sharedData.packedValues)\n          if (sharedValues) {\n            sharedPackedObjectMap = {}\n            for (let i = 0, l = sharedValues.length; i < l; i++) sharedPackedObjectMap[sharedValues[i]] = i\n          }\n        }\n        let sharedStructuresLength = sharedStructures.length\n        if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures\n        if (!sharedStructures.transitions) {\n          // rebuild our structure transitions\n          sharedStructures.transitions = Object.create(null)\n          for (let i = 0; i < sharedStructuresLength; i++) {\n            const keys = sharedStructures[i]\n            //console.log('shared struct keys:', keys)\n            if (!keys) continue\n            let nextTransition\n            let transition = sharedStructures.transitions\n            for (let j = 0, l = keys.length; j < l; j++) {\n              if (transition[RECORD_SYMBOL] === undefined) transition[RECORD_SYMBOL] = i\n              const key = keys[j]\n              nextTransition = transition[key]\n              if (!nextTransition) {\n                nextTransition = transition[key] = Object.create(null)\n              }\n              transition = nextTransition\n            }\n            transition[RECORD_SYMBOL] = i | 0x100000\n          }\n        }\n        if (!isSequential) sharedStructures.nextId = sharedStructuresLength\n      }\n      if (hasSharedUpdate) hasSharedUpdate = false\n      structures = sharedStructures || []\n      packedObjectMap = sharedPackedObjectMap\n      if (options.pack) {\n        const packedValues = new Map()\n        packedValues.values = []\n        packedValues.encoder = encoder\n        packedValues.maxValues =\n          options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Number.POSITIVE_INFINITY)\n        packedValues.objectMap = sharedPackedObjectMap || false\n        packedValues.samplingPackedValues = samplingPackedValues\n        findRepetitiveStrings(value, packedValues)\n        if (packedValues.values.length > 0) {\n          target[position++] = 0xd8 // one-byte tag\n          target[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n          writeArrayHeader(4)\n          const valuesArray = packedValues.values\n          encode(valuesArray)\n          writeArrayHeader(0) // prefixes\n          writeArrayHeader(0) // suffixes\n          packedObjectMap = Object.create(sharedPackedObjectMap || null)\n          for (let i = 0, l = valuesArray.length; i < l; i++) {\n            packedObjectMap[valuesArray[i]] = i\n          }\n        }\n      }\n      throwOnIterable = encodeOptions & THROW_ON_ITERABLE\n      try {\n        if (throwOnIterable) return\n        encode(value)\n        if (bundledStrings) {\n          writeBundles(start, encode)\n        }\n        encoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n        if (referenceMap?.idsToInsert) {\n          position += referenceMap.idsToInsert.length * 2\n          if (position > safeEnd) makeRoom(position)\n          encoder.offset = position\n          const serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n          referenceMap = null\n          return serialized\n        }\n        if (encodeOptions & REUSE_BUFFER_MODE) {\n          target.start = start\n          target.end = position\n          return target\n        }\n        return target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n      } finally {\n        if (sharedStructures) {\n          if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++\n          if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures\n          if (transitionsCount > 10000) {\n            // force a rebuild occasionally after a lot of transitions so it can get cleaned up\n            sharedStructures.transitions = null\n            serializationsSinceTransitionRebuild = 0\n            transitionsCount = 0\n            if (recordIdsToRemove.length > 0) recordIdsToRemove = []\n          } else if (recordIdsToRemove.length > 0 && !isSequential) {\n            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n              recordIdsToRemove[i][RECORD_SYMBOL] = undefined\n            }\n            recordIdsToRemove = []\n            //sharedStructures.nextId = maxSharedStructures\n          }\n        }\n        if (hasSharedUpdate && encoder.saveShared) {\n          if (encoder.structures.length > maxSharedStructures) {\n            encoder.structures = encoder.structures.slice(0, maxSharedStructures)\n          }\n          // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n          const returnBuffer = target.subarray(start, position)\n          if (encoder.updateSharedData() === false) return encoder.encode(value) // re-encode if it fails\n          return returnBuffer\n        }\n        if (encodeOptions & RESET_BUFFER_MODE) position = start\n      }\n    }\n    this.findCommonStringsToPack = () => {\n      samplingPackedValues = new Map()\n      if (!sharedPackedObjectMap) sharedPackedObjectMap = Object.create(null)\n      return (options) => {\n        const threshold = options?.threshold || 4\n        let position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n        if (!sharedValues) sharedValues = this.sharedValues = []\n        for (const [key, status] of samplingPackedValues) {\n          if (status.count > threshold) {\n            sharedPackedObjectMap[key] = position++\n            sharedValues.push(key)\n            hasSharedUpdate = true\n          }\n        }\n        while (this.saveShared && this.updateSharedData() === false) {}\n        samplingPackedValues = null\n      }\n    }\n    const encode = (value) => {\n      if (position > safeEnd) target = makeRoom(position)\n\n      const type = typeof value\n      let length\n      if (type === 'string') {\n        if (packedObjectMap) {\n          const packedPosition = packedObjectMap[value]\n          if (packedPosition >= 0) {\n            if (packedPosition < 16)\n              target[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n            else {\n              target[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n              if (packedPosition & 1) encode((15 - packedPosition) >> 1)\n              else encode((packedPosition - 16) >> 1)\n            }\n            return\n            /*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n          }\n          if (samplingPackedValues && !options.pack) {\n            const status = samplingPackedValues.get(value)\n            if (status) status.count++\n            else\n              samplingPackedValues.set(value, {\n                count: 1,\n              })\n          }\n        }\n        const strLength = value.length\n        if (bundledStrings && strLength >= 4 && strLength < 0x400) {\n          if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n            let extStart\n            const maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n            if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes)\n            target[position++] = 0xd9 // tag 16-bit\n            target[position++] = 0xdf // tag 0xdff9\n            target[position++] = 0xf9\n            // TODO: If we only have one bundle with any string data, only write one string bundle\n            target[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n            target[position++] = 0x1a // 32-bit unsigned int\n            extStart = position - start\n            position += 4 // reserve for writing bundle reference\n            if (bundledStrings.position) {\n              writeBundles(start, encode) // write the last bundles\n            }\n            bundledStrings = ['', ''] // create new ones\n            bundledStrings.size = 0\n            bundledStrings.position = extStart\n          }\n          const twoByte = hasNonLatin.test(value)\n          bundledStrings[twoByte ? 0 : 1] += value\n          target[position++] = twoByte ? 0xce : 0xcf\n          encode(strLength)\n          return\n        }\n        let headerSize\n        // first we estimate the header size, so we can write to the correct location\n        if (strLength < 0x20) {\n          headerSize = 1\n        } else if (strLength < 0x100) {\n          headerSize = 2\n        } else if (strLength < 0x10000) {\n          headerSize = 3\n        } else {\n          headerSize = 5\n        }\n        const maxBytes = strLength * 3\n        if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes)\n\n        if (strLength < 0x40 || !encodeUtf8) {\n          let i\n          let c1\n          let c2\n          let strPosition = position + headerSize\n          for (i = 0; i < strLength; i++) {\n            c1 = value.charCodeAt(i)\n            if (c1 < 0x80) {\n              target[strPosition++] = c1\n            } else if (c1 < 0x800) {\n              target[strPosition++] = (c1 >> 6) | 0xc0\n              target[strPosition++] = (c1 & 0x3f) | 0x80\n            } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n              c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n              i++\n              target[strPosition++] = (c1 >> 18) | 0xf0\n              target[strPosition++] = ((c1 >> 12) & 0x3f) | 0x80\n              target[strPosition++] = ((c1 >> 6) & 0x3f) | 0x80\n              target[strPosition++] = (c1 & 0x3f) | 0x80\n            } else {\n              target[strPosition++] = (c1 >> 12) | 0xe0\n              target[strPosition++] = ((c1 >> 6) & 0x3f) | 0x80\n              target[strPosition++] = (c1 & 0x3f) | 0x80\n            }\n          }\n          length = strPosition - position - headerSize\n        } else {\n          length = encodeUtf8(value, position + headerSize, maxBytes)\n        }\n\n        if (length < 0x18) {\n          target[position++] = 0x60 | length\n        } else if (length < 0x100) {\n          if (headerSize < 2) {\n            target.copyWithin(position + 2, position + 1, position + 1 + length)\n          }\n          target[position++] = 0x78\n          target[position++] = length\n        } else if (length < 0x10000) {\n          if (headerSize < 3) {\n            target.copyWithin(position + 3, position + 2, position + 2 + length)\n          }\n          target[position++] = 0x79\n          target[position++] = length >> 8\n          target[position++] = length & 0xff\n        } else {\n          if (headerSize < 5) {\n            target.copyWithin(position + 5, position + 3, position + 3 + length)\n          }\n          target[position++] = 0x7a\n          targetView.setUint32(position, length)\n          position += 4\n        }\n        position += length\n      } else if (type === 'number') {\n        if (!this.alwaysUseFloat && value >>> 0 === value) {\n          // positive integer, 32-bit or less\n          // positive uint\n          if (value < 0x18) {\n            target[position++] = value\n          } else if (value < 0x100) {\n            target[position++] = 0x18\n            target[position++] = value\n          } else if (value < 0x10000) {\n            target[position++] = 0x19\n            target[position++] = value >> 8\n            target[position++] = value & 0xff\n          } else {\n            target[position++] = 0x1a\n            targetView.setUint32(position, value)\n            position += 4\n          }\n        } else if (!this.alwaysUseFloat && value >> 0 === value) {\n          // negative integer\n          if (value >= -0x18) {\n            target[position++] = 0x1f - value\n          } else if (value >= -0x100) {\n            target[position++] = 0x38\n            target[position++] = ~value\n          } else if (value >= -0x10000) {\n            target[position++] = 0x39\n            targetView.setUint16(position, ~value)\n            position += 2\n          } else {\n            target[position++] = 0x3a\n            targetView.setUint32(position, ~value)\n            position += 4\n          }\n        } else {\n          let useFloat32\n          if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n            target[position++] = 0xfa\n            targetView.setFloat32(position, value)\n            let xShifted\n            if (\n              useFloat32 < 4 ||\n              // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n              (xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0 ===\n                xShifted\n            ) {\n              position += 4\n              return\n            }\n            position-- // move back into position for writing a double\n          }\n          target[position++] = 0xfb\n          targetView.setFloat64(position, value)\n          position += 8\n        }\n      } else if (type === 'object') {\n        if (!value) target[position++] = 0xf6\n        else {\n          if (referenceMap) {\n            const referee = referenceMap.get(value)\n            if (referee) {\n              target[position++] = 0xd8\n              target[position++] = 29 // http://cbor.schmorp.de/value-sharing\n              target[position++] = 0x19 // 16-bit uint\n              if (!referee.references) {\n                const idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n                referee.references = []\n                idsToInsert.push(referee)\n              }\n              referee.references.push(position - start)\n              position += 2 // TODO: also support 32-bit\n              return\n            }\n            referenceMap.set(value, { offset: position - start })\n          }\n          const constructor = value.constructor\n          if (constructor === Object) {\n            writeObject(value)\n          } else if (constructor === Array) {\n            length = value.length\n            if (length < 0x18) {\n              target[position++] = 0x80 | length\n            } else {\n              writeArrayHeader(length)\n            }\n            for (let i = 0; i < length; i++) {\n              encode(value[i])\n            }\n          } else if (constructor === Map) {\n            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n              // use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n              target[position++] = 0xd9\n              target[position++] = 1\n              target[position++] = 3\n            }\n            length = value.size\n            if (length < 0x18) {\n              target[position++] = 0xa0 | length\n            } else if (length < 0x100) {\n              target[position++] = 0xb8\n              target[position++] = length\n            } else if (length < 0x10000) {\n              target[position++] = 0xb9\n              target[position++] = length >> 8\n              target[position++] = length & 0xff\n            } else {\n              target[position++] = 0xba\n              targetView.setUint32(position, length)\n              position += 4\n            }\n            if (encoder.keyMap) {\n              for (const [key, entryValue] of value) {\n                encode(encoder.encodeKey(key))\n                encode(entryValue)\n              }\n            } else {\n              for (const [key, entryValue] of value) {\n                encode(key)\n                encode(entryValue)\n              }\n            }\n          } else {\n            for (let i = 0, l = extensions.length; i < l; i++) {\n              const extensionClass = extensionClasses[i]\n              if (value instanceof extensionClass) {\n                const extension = extensions[i]\n                let tag = extension.tag\n                if (tag === undefined) tag = extension.getTag?.call(this, value)\n                if (tag < 0x18) {\n                  target[position++] = 0xc0 | tag\n                } else if (tag < 0x100) {\n                  target[position++] = 0xd8\n                  target[position++] = tag\n                } else if (tag < 0x10000) {\n                  target[position++] = 0xd9\n                  target[position++] = tag >> 8\n                  target[position++] = tag & 0xff\n                } else if (tag > -1) {\n                  target[position++] = 0xda\n                  targetView.setUint32(position, tag)\n                  position += 4\n                } // else undefined, don't write tag\n                extension.encode.call(this, value, encode, makeRoom)\n                return\n              }\n            }\n            if (value[Symbol.iterator]) {\n              if (throwOnIterable) {\n                const error = new Error('Iterable should be serialized as iterator')\n                error.iteratorNotHandled = true\n                throw error\n              }\n              target[position++] = 0x9f // indefinite length array\n              for (const entry of value) {\n                encode(entry)\n              }\n              target[position++] = 0xff // stop-code\n              return\n            }\n            if (value[Symbol.asyncIterator] || isBlob(value)) {\n              const error = new Error('Iterable/blob should be serialized as iterator')\n              error.iteratorNotHandled = true\n              throw error\n            }\n            if (this.useToJSON && value.toJSON) {\n              const json = value.toJSON()\n              // if for some reason value.toJSON returns itself it'll loop forever\n              if (json !== value) return encode(json)\n            }\n\n            // no extension found, write as a plain object\n            writeObject(value)\n          }\n        }\n      } else if (type === 'boolean') {\n        target[position++] = value ? 0xf5 : 0xf4\n      } else if (type === 'bigint') {\n        if (value < BigInt(1) << BigInt(64) && value >= 0) {\n          // use an unsigned int as long as it fits\n          target[position++] = 0x1b\n          targetView.setBigUint64(position, value)\n        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {\n          // if we can fit an unsigned int, use that\n          target[position++] = 0x3b\n          targetView.setBigUint64(position, -value - BigInt(1))\n        } else {\n          // overflow\n          if (this.largeBigIntToFloat) {\n            target[position++] = 0xfb\n            targetView.setFloat64(position, Number(value))\n          } else {\n            if (value >= BigInt(0))\n              target[position++] = 0xc2 // tag 2\n            else {\n              target[position++] = 0xc3 // tag 2\n              value = BigInt(-1) - value\n            }\n            const bytes = []\n            while (value) {\n              bytes.push(Number(value & BigInt(0xff)))\n              value >>= BigInt(8)\n            }\n            writeBuffer(new Uint8Array(bytes.reverse()), makeRoom)\n            return\n          }\n        }\n        position += 8\n      } else if (type === 'undefined') {\n        target[position++] = 0xf7\n      } else {\n        throw new Error(`Unknown type: ${type}`)\n      }\n    }\n\n    const writeObject =\n      this.useRecords === false\n        ? this.variableMapSize\n          ? (object) => {\n              // this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n              const keys = Object.keys(object)\n              const vals = Object.values(object)\n              const length = keys.length\n              if (length < 0x18) {\n                target[position++] = 0xa0 | length\n              } else if (length < 0x100) {\n                target[position++] = 0xb8\n                target[position++] = length\n              } else if (length < 0x10000) {\n                target[position++] = 0xb9\n                target[position++] = length >> 8\n                target[position++] = length & 0xff\n              } else {\n                target[position++] = 0xba\n                targetView.setUint32(position, length)\n                position += 4\n              }\n              let key\n              if (encoder.keyMap) {\n                for (let i = 0; i < length; i++) {\n                  encode(encoder.encodeKey(keys[i]))\n                  encode(vals[i])\n                }\n              } else {\n                for (let i = 0; i < length; i++) {\n                  encode(keys[i])\n                  encode(vals[i])\n                }\n              }\n            }\n          : (object) => {\n              target[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n              let objectOffset = position - start\n              position += 2\n              let size = 0\n              if (encoder.keyMap) {\n                for (const key in object)\n                  if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n                    encode(encoder.encodeKey(key))\n                    encode(object[key])\n                    size++\n                  }\n              } else {\n                for (const key in object)\n                  if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n                    encode(key)\n                    encode(object[key])\n                    size++\n                  }\n              }\n              target[objectOffset++ + start] = size >> 8\n              target[objectOffset + start] = size & 0xff\n            }\n        : (object, skipValues) => {\n            let nextTransition\n            let transition = structures.transitions || (structures.transitions = Object.create(null))\n            let newTransitions = 0\n            let length = 0\n            let parentRecordId\n            let keys\n            if (this.keyMap) {\n              keys = Object.keys(object).map((k) => this.encodeKey(k))\n              length = keys.length\n              for (let i = 0; i < length; i++) {\n                const key = keys[i]\n                nextTransition = transition[key]\n                if (!nextTransition) {\n                  nextTransition = transition[key] = Object.create(null)\n                  newTransitions++\n                }\n                transition = nextTransition\n              }\n            } else {\n              for (const key in object)\n                if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n                  nextTransition = transition[key]\n                  if (!nextTransition) {\n                    if (transition[RECORD_SYMBOL] & 0x100000) {\n                      // this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n                      parentRecordId = transition[RECORD_SYMBOL] & 0xffff\n                    }\n                    nextTransition = transition[key] = Object.create(null)\n                    newTransitions++\n                  }\n                  transition = nextTransition\n                  length++\n                }\n            }\n            let recordId = transition[RECORD_SYMBOL]\n            if (recordId !== undefined) {\n              recordId &= 0xffff\n              target[position++] = 0xd9\n              target[position++] = (recordId >> 8) | 0xe0\n              target[position++] = recordId & 0xff\n            } else {\n              if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n              if (parentRecordId === undefined) {\n                recordId = structures.nextId++\n                if (!recordId) {\n                  recordId = 0\n                  structures.nextId = 1\n                }\n                if (recordId >= MAX_STRUCTURES) {\n                  // cycle back around\n                  structures.nextId = (recordId = maxSharedStructures) + 1\n                }\n              } else {\n                recordId = parentRecordId\n              }\n              structures[recordId] = keys\n              if (recordId < maxSharedStructures) {\n                target[position++] = 0xd9\n                target[position++] = (recordId >> 8) | 0xe0\n                target[position++] = recordId & 0xff\n                transition = structures.transitions\n                for (let i = 0; i < length; i++) {\n                  if (transition[RECORD_SYMBOL] === undefined || transition[RECORD_SYMBOL] & 0x100000)\n                    transition[RECORD_SYMBOL] = recordId\n                  transition = transition[keys[i]]\n                }\n                transition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n                hasSharedUpdate = true\n              } else {\n                transition[RECORD_SYMBOL] = recordId\n                targetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n                position += 3\n                if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions\n                // record the removal of the id, we can maintain our shared structure\n                if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n                  recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n                recordIdsToRemove.push(transition)\n                writeArrayHeader(length + 2)\n                encode(0xe000 + recordId)\n                encode(keys)\n                if (skipValues) return // special exit for iterator\n                for (const key in object)\n                  if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) encode(object[key])\n                return\n              }\n            }\n            if (length < 0x18) {\n              // write the array header\n              target[position++] = 0x80 | length\n            } else {\n              writeArrayHeader(length)\n            }\n            if (skipValues) return // special exit for iterator\n            for (const key in object)\n              if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) encode(object[key])\n          }\n    const makeRoom = (end) => {\n      let newSize\n      if (end > 0x1000000) {\n        // special handling for really large buffers\n        if (end - start > MAX_BUFFER_SIZE) throw new Error('Encoded buffer would be larger than maximum buffer size')\n        newSize = Math.min(\n          MAX_BUFFER_SIZE,\n          Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000\n        )\n      } // faster handling for smaller buffers\n      else newSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n      const newBuffer = new ByteArrayAllocate(newSize)\n      targetView = new DataView(newBuffer.buffer, 0, newSize)\n      if (target.copy) target.copy(newBuffer, 0, start, end)\n      else newBuffer.set(target.slice(start, end))\n      position -= start\n      start = 0\n      safeEnd = newBuffer.length - 10\n      return (target = newBuffer)\n    }\n    let chunkThreshold = 100\n    let continuedChunkThreshold = 1000\n    this.encodeAsIterable = (value, options) => startEncoding(value, options, encodeObjectAsIterable)\n    this.encodeAsAsyncIterable = (value, options) => startEncoding(value, options, encodeObjectAsAsyncIterable)\n\n    function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n      const constructor = object.constructor\n      if (constructor === Object) {\n        const useRecords = encoder.useRecords !== false\n        if (useRecords)\n          writeObject(object, true) // write the record identifier\n        else writeEntityLength(Object.keys(object).length, 0xa0)\n        for (const key in object) {\n          const value = object[key]\n          if (!useRecords) encode(key)\n          if (value && typeof value === 'object') {\n            if (iterateProperties[key]) yield* encodeObjectAsIterable(value, iterateProperties[key])\n            else yield* tryEncode(value, iterateProperties, key)\n          } else encode(value)\n        }\n      } else if (constructor === Array) {\n        const length = object.length\n        writeArrayHeader(length)\n        for (let i = 0; i < length; i++) {\n          const value = object[i]\n          if (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n            if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element)\n            else yield* tryEncode(value, iterateProperties, 'element')\n          } else encode(value)\n        }\n      } else if (object[Symbol.iterator] && !object.buffer) {\n        // iterator, but exclude typed arrays\n        target[position++] = 0x9f // start indefinite array\n        for (const value of object) {\n          if (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n            if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element)\n            else yield* tryEncode(value, iterateProperties, 'element')\n          } else encode(value)\n        }\n        target[position++] = 0xff // stop byte\n      } else if (isBlob(object)) {\n        writeEntityLength(object.size, 0x40) // encode as binary data\n        yield target.subarray(start, position)\n        yield object // directly return blobs, they have to be encoded asynchronously\n        restartEncoding()\n      } else if (object[Symbol.asyncIterator]) {\n        target[position++] = 0x9f // start indefinite array\n        yield target.subarray(start, position)\n        yield object // directly return async iterators, they have to be encoded asynchronously\n        restartEncoding()\n        target[position++] = 0xff // stop byte\n      } else {\n        encode(object)\n      }\n      if (finalIterable && position > start) yield target.subarray(start, position)\n      else if (position - start > chunkThreshold) {\n        yield target.subarray(start, position)\n        restartEncoding()\n      }\n    }\n    function* tryEncode(value, iterateProperties, key) {\n      const restart = position - start\n      try {\n        encode(value)\n        if (position - start > chunkThreshold) {\n          yield target.subarray(start, position)\n          restartEncoding()\n        }\n      } catch (error) {\n        if (error.iteratorNotHandled) {\n          iterateProperties[key] = {}\n          position = start + restart // restart our position so we don't have partial data from last encode\n          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key])\n        } else throw error\n      }\n    }\n    function restartEncoding() {\n      chunkThreshold = continuedChunkThreshold\n      encoder.encode(null, THROW_ON_ITERABLE) // restart encoding\n    }\n    function startEncoding(value, options, encodeIterable) {\n      if (options?.chunkThreshold)\n        // explicitly specified chunk sizes\n        chunkThreshold = continuedChunkThreshold = options.chunkThreshold\n      // we start with a smaller threshold to get initial bytes sent quickly\n      else chunkThreshold = 100\n      if (value && typeof value === 'object') {\n        encoder.encode(null, THROW_ON_ITERABLE) // start encoding\n        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true)\n      }\n      return [encoder.encode(value)]\n    }\n\n    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n      for (const encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n        const constructor = encodedValue.constructor\n        if (constructor === ByteArray || constructor === Uint8Array) yield encodedValue\n        else if (isBlob(encodedValue)) {\n          const reader = encodedValue.stream().getReader()\n          let next\n          while (!(next = await reader.read()).done) {\n            yield next.value\n          }\n        } else if (encodedValue[Symbol.asyncIterator]) {\n          for await (const asyncValue of encodedValue) {\n            restartEncoding()\n            if (asyncValue)\n              yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}))\n            else yield encoder.encode(asyncValue)\n          }\n        } else {\n          yield encodedValue\n        }\n      }\n    }\n  }\n  useBuffer(buffer) {\n    // this means we are finished using our own buffer and we can write over it safely\n    target = buffer\n    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n    position = 0\n  }\n  clearSharedData() {\n    if (this.structures) this.structures = []\n    if (this.sharedValues) this.sharedValues = undefined\n  }\n  updateSharedData() {\n    const lastVersion = this.sharedVersion || 0\n    this.sharedVersion = lastVersion + 1\n    const structuresCopy = this.structures.slice(0)\n    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n    const saveResults = this.saveShared(sharedData, (existingShared) => (existingShared?.version || 0) === lastVersion)\n    if (saveResults === false) {\n      // get updated structures and try again if the update failed\n      sharedData = this.getShared() || {}\n      this.structures = sharedData.structures || []\n      this.sharedValues = sharedData.packedValues\n      this.sharedVersion = sharedData.version\n      this.structures.nextId = this.structures.length\n    } else {\n      // restore structures\n      structuresCopy.forEach((structure, i) => (this.structures[i] = structure))\n    }\n    // saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n    return saveResults\n  }\n}\nfunction writeEntityLength(length, majorValue) {\n  if (length < 0x18) target[position++] = majorValue | length\n  else if (length < 0x100) {\n    target[position++] = majorValue | 0x18\n    target[position++] = length\n  } else if (length < 0x10000) {\n    target[position++] = majorValue | 0x19\n    target[position++] = length >> 8\n    target[position++] = length & 0xff\n  } else {\n    target[position++] = majorValue | 0x1a\n    targetView.setUint32(position, length)\n    position += 4\n  }\n}\nclass SharedData {\n  constructor(structures, values, version) {\n    this.structures = structures\n    this.packedValues = values\n    this.version = version\n  }\n}\n\nfunction writeArrayHeader(length) {\n  if (length < 0x18) target[position++] = 0x80 | length\n  else if (length < 0x100) {\n    target[position++] = 0x98\n    target[position++] = length\n  } else if (length < 0x10000) {\n    target[position++] = 0x99\n    target[position++] = length >> 8\n    target[position++] = length & 0xff\n  } else {\n    target[position++] = 0x9a\n    targetView.setUint32(position, length)\n    position += 4\n  }\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? () => {} : Blob\nfunction isBlob(object) {\n  if (object instanceof BlobConstructor) return true\n  const tag = object[Symbol.toStringTag]\n  return tag === 'Blob' || tag === 'File'\n}\nfunction findRepetitiveStrings(value, packedValues) {\n  switch (typeof value) {\n    case 'string':\n      if (value.length > 3) {\n        if (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues) return\n        const packedStatus = packedValues.get(value)\n        if (packedStatus) {\n          if (++packedStatus.count === 2) {\n            packedValues.values.push(value)\n          }\n        } else {\n          packedValues.set(value, {\n            count: 1,\n          })\n          if (packedValues.samplingPackedValues) {\n            const status = packedValues.samplingPackedValues.get(value)\n            if (status) status.count++\n            else\n              packedValues.samplingPackedValues.set(value, {\n                count: 1,\n              })\n          }\n        }\n      }\n      break\n    case 'object':\n      if (value) {\n        if (Array.isArray(value)) {\n          for (let i = 0, l = value.length; i < l; i++) {\n            findRepetitiveStrings(value[i], packedValues)\n          }\n        } else {\n          const includeKeys = !packedValues.encoder.useRecords\n          for (const key in value) {\n            if (value.hasOwnProperty(key)) {\n              if (includeKeys) findRepetitiveStrings(key, packedValues)\n              findRepetitiveStrings(value[key], packedValues)\n            }\n          }\n        }\n      }\n      break\n    case 'function':\n      console.log(value)\n  }\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1\nextensionClasses = [\n  Date,\n  Set,\n  Error,\n  RegExp,\n  Tag,\n  ArrayBuffer,\n  Uint8Array,\n  Uint8ClampedArray,\n  Uint16Array,\n  Uint32Array,\n  typeof BigUint64Array === 'undefined' ? () => {} : BigUint64Array,\n  Int8Array,\n  Int16Array,\n  Int32Array,\n  typeof BigInt64Array === 'undefined' ? () => {} : BigInt64Array,\n  Float32Array,\n  Float64Array,\n  SharedData,\n]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [\n  {\n    // Date\n    tag: 1,\n    encode(date, encode) {\n      const seconds = date.getTime() / 1000\n      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n        // Timestamp 32\n        target[position++] = 0x1a\n        targetView.setUint32(position, seconds)\n        position += 4\n      } else {\n        // Timestamp float64\n        target[position++] = 0xfb\n        targetView.setFloat64(position, seconds)\n        position += 8\n      }\n    },\n  },\n  {\n    // Set\n    tag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n    encode(set, encode) {\n      const array = Array.from(set)\n      encode(array)\n    },\n  },\n  {\n    // Error\n    tag: 27, // http://cbor.schmorp.de/generic-object\n    encode(error, encode) {\n      encode([error.name, error.message])\n    },\n  },\n  {\n    // RegExp\n    tag: 27, // http://cbor.schmorp.de/generic-object\n    encode(regex, encode) {\n      encode(['RegExp', regex.source, regex.flags])\n    },\n  },\n  {\n    // Tag\n    getTag(tag) {\n      return tag.tag\n    },\n    encode(tag, encode) {\n      encode(tag.value)\n    },\n  },\n  {\n    // ArrayBuffer\n    encode(arrayBuffer, encode, makeRoom) {\n      writeBuffer(arrayBuffer, makeRoom)\n    },\n  },\n  {\n    // Uint8Array\n    getTag(typedArray) {\n      if (typedArray.constructor === Uint8Array) {\n        if (this.tagUint8Array || (hasNodeBuffer && this.tagUint8Array !== false)) return 64\n      } // else no tag\n    },\n    encode(typedArray, encode, makeRoom) {\n      writeBuffer(typedArray, makeRoom)\n    },\n  },\n  typedArrayEncoder(68, 1),\n  typedArrayEncoder(69, 2),\n  typedArrayEncoder(70, 4),\n  typedArrayEncoder(71, 8),\n  typedArrayEncoder(72, 1),\n  typedArrayEncoder(77, 2),\n  typedArrayEncoder(78, 4),\n  typedArrayEncoder(79, 8),\n  typedArrayEncoder(85, 4),\n  typedArrayEncoder(86, 8),\n  {\n    encode(sharedData, encode) {\n      // write SharedData\n      const packedValues = sharedData.packedValues || []\n      const sharedStructures = sharedData.structures || []\n      if (packedValues.values.length > 0) {\n        target[position++] = 0xd8 // one-byte tag\n        target[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n        writeArrayHeader(4)\n        const valuesArray = packedValues.values\n        encode(valuesArray)\n        writeArrayHeader(0) // prefixes\n        writeArrayHeader(0) // suffixes\n        packedObjectMap = Object.create(sharedPackedObjectMap || null)\n        for (let i = 0, l = valuesArray.length; i < l; i++) {\n          packedObjectMap[valuesArray[i]] = i\n        }\n      }\n      if (sharedStructures) {\n        targetView.setUint32(position, 0xd9dffe00)\n        position += 3\n        const definitions = sharedStructures.slice(0)\n        definitions.unshift(0xe000)\n        definitions.push(new Tag(sharedData.version, 0x53687264))\n        encode(definitions)\n      } else encode(new Tag(sharedData.version, 0x53687264))\n    },\n  },\n]\nfunction typedArrayEncoder(tag, size) {\n  if (!isLittleEndianMachine && size > 1) tag -= 4 // the big endian equivalents are 4 less\n  return {\n    tag: tag,\n    encode: function writeExtBuffer(typedArray, encode) {\n      const length = typedArray.byteLength\n      const offset = typedArray.byteOffset || 0\n      const buffer = typedArray.buffer || typedArray\n      encode(hasNodeBuffer ? Buffer.from(buffer, offset, length) : new Uint8Array(buffer, offset, length))\n    },\n  }\n}\nfunction writeBuffer(buffer, makeRoom) {\n  const length = buffer.byteLength\n  if (length < 0x18) {\n    target[position++] = 0x40 + length\n  } else if (length < 0x100) {\n    target[position++] = 0x58\n    target[position++] = length\n  } else if (length < 0x10000) {\n    target[position++] = 0x59\n    target[position++] = length >> 8\n    target[position++] = length & 0xff\n  } else {\n    target[position++] = 0x5a\n    targetView.setUint32(position, length)\n    position += 4\n  }\n  if (position + length >= target.length) {\n    makeRoom(position + length)\n  }\n  // if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n  // must wrap it to set it.\n  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n  position += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n  // insert the ids that need to be referenced for structured clones\n  let nextId\n  let distanceToMove = idsToInsert.length * 2\n  let lastEnd = serialized.length - distanceToMove\n  idsToInsert.sort((a, b) => (a.offset > b.offset ? 1 : -1))\n  for (let id = 0; id < idsToInsert.length; id++) {\n    const referee = idsToInsert[id]\n    referee.id = id\n    for (let position of referee.references) {\n      serialized[position++] = id >> 8\n      serialized[position] = id & 0xff\n    }\n  }\n  while ((nextId = idsToInsert.pop())) {\n    const offset = nextId.offset\n    serialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n    distanceToMove -= 2\n    let position = offset + distanceToMove\n    serialized[position++] = 0xd8\n    serialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n    lastEnd = offset\n  }\n  return serialized\n}\nfunction writeBundles(start, encode) {\n  targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n  const writeStrings = bundledStrings\n  bundledStrings = null\n  encode(writeStrings[0])\n  encode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n  if (extension.Class) {\n    if (!extension.encode) throw new Error('Extension has no encode function')\n    extensionClasses.unshift(extension.Class)\n    extensions.unshift(extension)\n  }\n  decodeAddExtension(extension)\n}\nconst defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n","import { addExtension } from './cbor-x/index.js'\nimport { cborDecode, cborEncode } from './index.js'\n\nexport type DataItemParams<T = unknown> =\n  | {\n      data: T\n      buffer: Uint8Array\n    }\n  | { data: T }\n  | { buffer: Uint8Array }\n\n/**\n * DataItem is an extension defined https://www.rfc-editor.org/rfc/rfc8949.html#name-encoded-cbor-data-item\n *  > Sometimes it is beneficial to carry an embedded CBOR data item that is\n *  > not meant to be decoded immediately at the time the enclosing data item is being decoded.\n *\n * The idea of this class is to provide lazy encode and decode of cbor data.\n *\n * Due to a bug in the cbor-x library, we are eagerly encoding the data in the constructor.\n * https://github.com/kriszyp/cbor-x/issues/83\n *\n */\nexport class DataItem<T = unknown> {\n  #data?: T\n  #buffer: Uint8Array\n\n  constructor(params: DataItemParams<T>) {\n    if (!('data' in params) && !('buffer' in params)) {\n      throw new Error('DataItem must be initialized with either the data or a buffer')\n    }\n\n    if ('data' in params) this.#data = params.data\n    this.#buffer = 'buffer' in params ? params.buffer : cborEncode(params.data)\n  }\n\n  public get data(): T {\n    if (!this.#data) {\n      this.#data = cborDecode(this.#buffer) as T\n    }\n    return this.#data\n  }\n\n  public get buffer(): Uint8Array {\n    return this.#buffer\n  }\n\n  public static fromData<T>(data: T): DataItem<T> {\n    return new DataItem({ data })\n  }\n}\n\naddExtension({\n  Class: DataItem,\n  tag: 24,\n  encode: (instance: DataItem<unknown>, encode) => {\n    return encode(instance.buffer)\n  },\n  decode: (buffer: Uint8Array): object => {\n    return new DataItem({ buffer })\n  },\n})\n","import type { Options } from './cbor-x/index.js'\nimport { addExtension } from './cbor-x/index.js'\n\nimport { Encoder } from './cbor-x/encode.js'\n\nexport { DataItem } from './data-item.js'\n\nexport { addExtension } from './cbor-x/index.js'\n\nconst customInspectSymbol = Symbol.for('nodejs.util.inspect.custom')\nexport class DateOnly extends Date {\n  get [Symbol.toStringTag]() {\n    return DateOnly.name\n  }\n  override toISOString(): string {\n    return super.toISOString().split('T')[0]\n  }\n  override toString(): string {\n    return this.toISOString()\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override toJSON(key?: unknown): string {\n    return this.toISOString()\n  }\n  [customInspectSymbol](): string {\n    return this.toISOString()\n  }\n}\n\nconst encoderDefaults: Options = {\n  tagUint8Array: false,\n  useRecords: false,\n  mapsAsObjects: false,\n}\n\n// tdate data item shall contain a date-time string as specified in RFC 3339 (with no fraction of seconds)\n// see https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\naddExtension({\n  Class: Date,\n  tag: 0,\n  encode: (date: Date, encode) => encode(`${date.toISOString().split('.')[0]}Z`),\n  decode: (isoStringDateTime: string) => new Date(isoStringDateTime),\n})\n\n// full-date data item shall contain a full-date string as specified in RFC 3339\n// see https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\naddExtension({\n  Class: DateOnly,\n  tag: 1004,\n  encode: (date: DateOnly, encode) => encode(date.toISOString()),\n  decode: (isoStringDate: string): object => new DateOnly(isoStringDate),\n})\n\nexport const cborDecode = (\n  input: Uint8Array,\n  options: Options = encoderDefaults\n  // biome-ignore lint/suspicious/noExplicitAny:\n): any => {\n  const params = { ...encoderDefaults, ...options }\n  const enc = new Encoder(params)\n  return enc.decode(input)\n}\n\nexport const cborDecodeUnknown = (input: Uint8Array, options: Options = encoderDefaults): unknown => {\n  const params = { ...encoderDefaults, ...options }\n  const enc = new Encoder(params)\n  return enc.decode(input)\n}\n\nexport const cborEncode = (obj: unknown, options: Options = encoderDefaults): Uint8Array => {\n  const params = { ...encoderDefaults, ...options }\n  const enc = new Encoder(params)\n  return enc.encode(obj)\n}\n","// https://base64.guru/standards/base64url\nexport const BASE64_URL_REGEX = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/\n\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('')\n\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('')\n\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n  const charMap: number[] = new Array<number>(128)\n\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1\n  }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    charMap[IGNORE_BASE64URL[i]?.charCodeAt(0)] = -2\n  }\n\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    charMap[TO_BASE64URL[i]?.charCodeAt(0)] = i\n  }\n\n  return charMap\n})()\n\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(\n  byte: number | null,\n  state: { queue: number; queuedBits: number },\n  emit: (char: string) => void\n) {\n  if (byte !== null) {\n    state.queue = (state.queue << 8) | byte\n    state.queuedBits += 8\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << (6 - state.queuedBits)\n    state.queuedBits = 6\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  }\n}\n\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(\n  charCode: number,\n  state: { queue: number; queuedBits: number },\n  emit: (byte: number) => void\n) {\n  const bits = FROM_BASE64URL[charCode]\n\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = (state.queue << 6) | bits\n    state.queuedBits += 6\n\n    while (state.queuedBits >= 8) {\n      emit((state.queue >> (state.queuedBits - 8)) & 0xff)\n      state.queuedBits -= 8\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`)\n  }\n}\n\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str: string) {\n  const base64: string[] = []\n\n  const emitter = (char: string) => {\n    base64.push(char)\n  }\n\n  const state = { queue: 0, queuedBits: 0 }\n\n  stringToUTF8(str, (byte: number) => {\n    byteToBase64URL(byte, state, emitter)\n  })\n\n  byteToBase64URL(null, state, emitter)\n\n  return base64.join('')\n}\n\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str: string) {\n  const conv: string[] = []\n\n  const utf8Emit = (codepoint: number) => {\n    conv.push(String.fromCodePoint(codepoint))\n  }\n\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0,\n  }\n\n  const b64State = { queue: 0, queuedBits: 0 }\n\n  const byteEmit = (byte: number) => {\n    stringFromUTF8(byte, utf8State, utf8Emit)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit)\n  }\n\n  return conv.join('')\n}\n\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint: number, emit: (byte: number) => void) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint)\n    return\n  }\n  if (codepoint <= 0x7ff) {\n    emit(0xc0 | (codepoint >> 6))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  }\n  if (codepoint <= 0xffff) {\n    emit(0xe0 | (codepoint >> 12))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  }\n  if (codepoint <= 0x10ffff) {\n    emit(0xf0 | (codepoint >> 18))\n    emit(0x80 | ((codepoint >> 12) & 0x3f))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  }\n\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)\n}\n\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str: string, emit: (byte: number) => void) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i)\n\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff\n      const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000\n      i += 1\n    }\n\n    codepointToUTF8(codepoint, emit)\n  }\n}\n\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(\n  byte: number,\n  state: { utf8seq: number; codepoint: number },\n  emit: (codepoint: number) => void\n) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte)\n      return\n    }\n\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if (((byte >> (7 - leadingBit)) & 1) === 0) {\n        state.utf8seq = leadingBit\n        break\n      }\n    }\n\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7\n    } else {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.utf8seq -= 1\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.codepoint = (state.codepoint << 6) | (byte & 63)\n    state.utf8seq -= 1\n\n    if (state.utf8seq === 0) {\n      emit(state.codepoint)\n    }\n  }\n}\n\nexport function uint8ArrayToBase64Url(bytes: Uint8Array) {\n  const result: string[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onChar = (char: string) => {\n    result.push(char)\n  }\n\n  // @ts-expect-error this works\n  bytes.map((byte) => byteToBase64URL(byte, state, onChar))\n\n  // always call with `null` after processing all bytes\n  byteToBase64URL(null, state, onChar)\n\n  return result.join('')\n}\n\nexport function base64UrlToUint8Array(base64Url: string) {\n  const result: number[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onByte = (byte: number) => {\n    result.push(byte)\n  }\n\n  for (let i = 0; i < base64Url.length; i += 1) {\n    byteFromBase64URL(base64Url.charCodeAt(i), state, onByte)\n  }\n\n  return new Uint8Array(result)\n}\n\nexport function base64UrlToBase64(base64Url: string): string {\n  // Step 1: Replace Base64URL specific characters\n  let base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/')\n\n  // Step 2: Add padding if necessary\n  while (base64.length % 4) {\n    base64 += '='\n  }\n\n  return base64\n}\n\nexport function base64ToBase64Url(base64: string): string {\n  // Step 1: Replace Base64 specific characters\n  let base64Url = base64.replace(/\\+/g, '-').replace(/\\//g, '_')\n\n  // Step 2: Remove padding\n  base64Url = base64Url.replace(/=+$/, '')\n\n  return base64Url\n}\n\nexport function base64ToUint8Array(base64: string): Uint8Array {\n  return base64UrlToUint8Array(base64ToBase64Url(base64))\n}\n\nexport function uint8ArrayToBase64(bytes: Uint8Array): string {\n  return base64UrlToBase64(uint8ArrayToBase64Url(bytes))\n}\n","/**\n * Decodes the `input` and returns a string. If `options.stream` is `true`, any\n * incomplete byte sequences occurring at the end of the `input` are buffered\n * internally and emitted after the next call to `textDecoder.decode()`.\n *\n * If `textDecoder.fatal` is `true`, decoding errors that occur will result in a `TypeError` being thrown.\n * @param input An `ArrayBuffer`, `DataView`, or `TypedArray` instance containing the encoded data.\n */\nexport function uint8ArrayToString(input: Uint8Array): string {\n  return String.fromCharCode.apply(null, Array.from(input))\n}\n\n/**\n * UTF-8 encodes the `input` string and returns a `Uint8Array` containing the\n * encoded bytes.\n * @param [input='an empty string'] The text to encode.\n */\nexport function stringToUint8Array(input: string): Uint8Array {\n  const buffer = new ArrayBuffer(input.length)\n  const uint8Array = new Uint8Array(buffer)\n  for (let i = 0; i < input.length; i++) {\n    uint8Array[i] = input.charCodeAt(i)\n  }\n  return uint8Array\n}\n\nexport function concatUint8Array(...buffers: Uint8Array[]): Uint8Array {\n  const size = buffers.reduce((acc, { length }) => acc + length, 0)\n  const buf = new Uint8Array(size)\n  let i = 0\n  buffers.forEach((buffer) => {\n    buf.set(buffer, i)\n    i += buffer.length\n  })\n  return buf\n}\n\nexport function areEqualUint8Array(buf1: Uint8Array, buf2: Uint8Array): boolean {\n  if (buf1 === buf2) {\n    return true\n  }\n\n  if (buf1.byteLength !== buf2.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < buf1.byteLength; i++) {\n    if (buf1[i] !== buf2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n","/**\n * A map that has a type for its keys and values\n */\nexport class TypedMap<KV extends unknown[]> implements Iterable<KV> {\n  #map = new Map()\n\n  constructor(entries?: Iterable<KV>) {\n    if (entries) {\n      for (const [key, value] of entries) {\n        this.#map.set(key, value)\n      }\n    }\n  }\n\n  [Symbol.iterator](): Iterator<KV, unknown, undefined> {\n    // @ts-expect-error this works\n    return this.#map[Symbol.iterator]()\n  }\n\n  /**\n   *\n   * Sets the value for the key in the map\n   *\n   * @param key - The key to set the value for\n   * @param value - The value to set\n   */\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  set<K extends KV[0]>(key: K, value: Extract<KV, [K, any]>[1]) {\n    this.#map.set(key, value)\n  }\n\n  /**\n   *\n   * Returns the value associated to the key, or undefined if there is none\n   *\n   * @param key - The key to get the value for\n   * @returns - The value associated to the key, or undefined if there is none\n   */\n  get<K extends KV[0]>(key: K): Extract<KV, [K, unknown]>[1] | undefined {\n    // @ts-expect-error this works\n    return this.#map.get(key) as KV[K]\n  }\n\n  /**\n   * Returns an iterable of key, value pairs for every entry in the map.\n   *\n   * @returns - An iterable of key, value pairs for every entry in the map\n   */\n  entries(): IterableIterator<KV> {\n    // @ts-expect-error this works\n    return this.#map.entries()\n  }\n\n  /**\n   * Returns an iterable of keys in the map\n   *\n   * @returns - An iterable of keys in the map\n   */\n  keys(): IterableIterator<KV[0]> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.#map.keys()\n  }\n\n  /**\n   * Returns an iterable of values in the map\n   *\n   * @returns - An iterable of values in the map\n   */\n  values(): IterableIterator<KV[1]> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.#map.values()\n  }\n\n  /**\n   * Clears the map\n   */\n  clear() {\n    this.#map.clear()\n  }\n\n  /**\n   * Deletes the entry for the given key\n   *\n   * @param key - The key to delete\n   * @returns Whether the key was deleted\n   */\n  delete<K extends KV[0]>(key: K): boolean {\n    return this.#map.delete(key)\n  }\n\n  /**\n   *\n   * Checks if the map has an entry for the given key\n   *\n   * @param key - The key to check for\n   * @returns Whether the map has an entry for the given key\n   */\n  has<K extends KV[0]>(key: K): boolean {\n    return this.#map.has(key)\n  }\n\n  /**\n   * Returns the number of entries in the map\n   */\n  get size() {\n    return this.#map.size\n  }\n\n  /**\n   * Returns the internal ES map\n   */\n  get esMap() {\n    return this.#map\n  }\n\n  static wrap<KV extends unknown[]>(map: TypedMap<KV> | Iterable<KV> | undefined) {\n    if (typeof map === 'undefined') {\n      return new TypedMap<KV>()\n    }\n    if (map instanceof TypedMap) {\n      return map\n    }\n    return new TypedMap(map)\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    depth: number | null,\n    options: Record<string, unknown>,\n    inspect: (obj: unknown, options: Record<string, unknown>) => string\n  ) {\n    const className = this.constructor.name\n    if (depth !== null && depth < 0) {\n      // @ts-expect-error this works\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return options.stylize(`[${className}]`, 'special')\n    }\n    const newOptions = Object.assign({}, options, {\n      // @ts-expect-error this works\n      depth: options.depth === null ? null : options.depth - 1,\n    })\n    const padding = ' '.repeat(className.length + 2)\n    const inner = inspect(this.esMap, newOptions).replace(/\\n/g, `\\n${padding}`)\n    // @ts-expect-error this works\n    return `${options.stylize(className, 'special')}< ${inner} >`\n  }\n}\n","import { cborEncode } from '../cbor/index.js'\nimport { TypedMap } from './typed-map.js'\n/**\n * COSE Header labels registered in the IANA \"COSE Header Parameters\" registry.\n * Reference: https://www.iana.org/assignments/cose/cose.xhtml#header-parameters\n */\nexport enum Headers {\n  Algorithm = 1,\n  Critical = 2,\n  ContentType = 3,\n  KeyID = 4,\n  IV = 5,\n  PartialIV = 6,\n  CounterSignature = 7,\n  CounterSignature0 = 9,\n  CounterSignatureV2 = 11,\n  CounterSignature0V2 = 12,\n  X5Bag = 32,\n  X5Chain = 33,\n  X5T = 34,\n  X5U = 35,\n}\n\nexport enum Algorithms {\n  EdDSA = -8,\n  ES256 = -7,\n  ES384 = -35,\n  ES512 = -36,\n  PS256 = -37,\n  PS384 = -38,\n  PS512 = -39,\n  RS256 = -257,\n  RS384 = -258,\n  RS512 = -259,\n}\n\nexport enum MacAlgorithms {\n  HS256 = 5,\n  HS384 = 6,\n  HS512 = 7,\n}\n\nexport enum EncryptionAlgorithms {\n  A128GCM = 1,\n  A192GCM = 2,\n  A256GCM = 3,\n  Direct = -6,\n}\n\nexport type Direct = -6\n\nexport type SupportedEncryptionAlgorithms = 'A128GCM' | 'A192GCM' | 'A256GCM'\n\nexport const EncryptionAlgorithmNames = new Map<EncryptionAlgorithms, SupportedEncryptionAlgorithms>([\n  [EncryptionAlgorithms.A128GCM, 'A128GCM'],\n  [EncryptionAlgorithms.A192GCM, 'A192GCM'],\n  [EncryptionAlgorithms.A256GCM, 'A256GCM'],\n])\n\nexport const MacAlgorithmNames = new Map<MacAlgorithms, SupportedMacAlg>([\n  [MacAlgorithms.HS256, 'HS256'],\n  [MacAlgorithms.HS384, 'HS384'],\n  [MacAlgorithms.HS512, 'HS512'],\n])\n\nexport const AlgorithmNames = new Map<Algorithms, SupportedAlgs>([\n  [Algorithms.EdDSA, 'EdDSA'],\n  [Algorithms.ES256, 'ES256'],\n  [Algorithms.ES384, 'ES384'],\n  [Algorithms.ES512, 'ES512'],\n  [Algorithms.PS256, 'PS256'],\n  [Algorithms.PS384, 'PS384'],\n  [Algorithms.PS512, 'PS512'],\n  [Algorithms.RS256, 'RS256'],\n  [Algorithms.RS384, 'RS384'],\n  [Algorithms.RS512, 'RS512'],\n])\n\nexport type SupportedAlgs =\n  | 'EdDSA'\n  | 'ES256'\n  | 'ES384'\n  | 'ES512'\n  | 'PS256'\n  | 'PS384'\n  | 'PS512'\n  | 'RS256'\n  | 'RS384'\n  | 'RS512'\n\nexport class ProtectedHeaders extends TypedMap<\n  | [Headers.Algorithm, Algorithms]\n  | [Headers.Critical, Headers[]]\n  | [Headers.ContentType, number | Uint8Array]\n  | [Headers.KeyID, Uint8Array]\n  | [\n      Omit<Headers, Headers.Algorithm | Headers.Critical | Headers.ContentType | Headers.KeyID>,\n      Uint8Array | Uint8Array[] | number | number[],\n    ]\n> {\n  /**\n   * Ensure input is a ProtectedHeaders instance.\n   *\n   * @param headers - The headers to wrap.\n   * @returns\n   */\n  static from(headers: ProtectedHeaders | ConstructorParameters<typeof ProtectedHeaders>[0]) {\n    //similar to base class wrap\n    if (headers instanceof ProtectedHeaders) {\n      return headers\n    }\n    return new ProtectedHeaders(headers)\n  }\n\n  /**\n   * CBOR encode the hedaers instance\n   * @returns {Uint8Array} - The encoded protected headers.\n   */\n  encode(): Uint8Array {\n    return cborEncode(this.esMap)\n  }\n}\n\nexport type SupportedMacAlg = 'HS256' | 'HS384' | 'HS512'\n\nexport class EncryptProtectedHeaders extends TypedMap<\n  | [Headers.Algorithm, EncryptionAlgorithms]\n  | [Headers.Critical, Headers[]]\n  | [Headers.ContentType, number | Uint8Array]\n  | [Headers.KeyID, Uint8Array]\n  | [\n      Omit<Headers, Headers.Algorithm | Headers.Critical | Headers.ContentType | Headers.KeyID>,\n      Uint8Array | number | number[],\n    ]\n> {\n  /**\n   * Ensure input is a EncryptProtectedHeaders instance.\n   *\n   * @param headers - The headers to wrap.\n   * @returns\n   */\n  static from(headers: EncryptProtectedHeaders | ConstructorParameters<typeof EncryptProtectedHeaders>[0]) {\n    //similar to base class wrap\n    if (headers instanceof EncryptProtectedHeaders) {\n      return headers\n    }\n    return new MacProtectedHeaders(headers)\n  }\n}\n\nexport class MacProtectedHeaders extends TypedMap<\n  | [Headers.Algorithm, MacAlgorithms]\n  | [Headers.Critical, Headers[]]\n  | [Headers.ContentType, number | Uint8Array]\n  | [Headers.KeyID, Uint8Array]\n  | [\n      Omit<Headers, Headers.Algorithm | Headers.Critical | Headers.ContentType | Headers.KeyID>,\n      Uint8Array | number | number[],\n    ]\n> {\n  /**\n   * Ensure input is a MacProtectedHeaders instance.\n   *\n   * @param headers - The headers to wrap.\n   * @returns\n   */\n  static from(headers: MacProtectedHeaders | ConstructorParameters<typeof MacProtectedHeaders>[0]) {\n    //similar to base class wrap\n    if (headers instanceof MacProtectedHeaders) {\n      return headers\n    }\n    return new MacProtectedHeaders(headers)\n  }\n}\n\nexport class UnprotectedHeaders extends TypedMap<\n  | [Headers.ContentType, number | Uint8Array]\n  | [Headers.KeyID, Uint8Array]\n  | [Headers.IV, Uint8Array]\n  | [Headers.PartialIV, Uint8Array]\n  | [Headers.X5Chain, Uint8Array | Uint8Array[]]\n  | [\n      Exclude<Headers, Headers.ContentType | Headers.KeyID | Headers.PartialIV | Headers.X5Chain>,\n      number | number[] | Uint8Array | Uint8Array[],\n    ]\n> {\n  /**\n   * Ensure input is a MacProtectedHeaders instance.\n   *\n   * @param headers - The headers to wrap.\n   * @returns\n   */\n  static from(headers: UnprotectedHeaders | ConstructorParameters<typeof UnprotectedHeaders>[0]) {\n    //similar to base class wrap\n    if (headers instanceof UnprotectedHeaders) {\n      return headers\n    }\n    return new UnprotectedHeaders(headers)\n  }\n}\n","export enum Curve {\n  'P-256' = 1,\n  'P-384' = 2,\n  'P-521' = 3,\n  X25519 = 4,\n  X448 = 5,\n  Ed25519 = 6,\n  Ed448 = 7,\n}\n","export enum KeyOps {\n  Sign = 1,\n  Verify = 2,\n  Encrypt = 3,\n  Decrypt = 4,\n  WrapKey = 5,\n  UnwrapKey = 6,\n  DeriveKey = 7,\n  DeriveBits = 8,\n  MACCreate = 9,\n  MACVerify = 10,\n}\n\nexport const JWKKeyOps = new Map<KeyOps, string>([\n  [KeyOps.Sign, 'sign'],\n  [KeyOps.Verify, 'verify'],\n  [KeyOps.Encrypt, 'encrypt'],\n  [KeyOps.Decrypt, 'decrypt'],\n  [KeyOps.WrapKey, 'wrapKey'],\n  [KeyOps.UnwrapKey, 'unwrapKey'],\n  [KeyOps.DeriveKey, 'deriveKey'],\n  [KeyOps.DeriveBits, 'deriveBits'],\n  //in JWK MAC Create and MAC Verify are sign and verify.\n  [KeyOps.MACCreate, 'sign'],\n  [KeyOps.MACVerify, 'verify'],\n])\n\nexport const JWKKeyOpsToCOSE = new Map<string, KeyOps[]>([\n  ['sign', [KeyOps.Sign, KeyOps.MACCreate]],\n  ['verify', [KeyOps.Verify, KeyOps.MACVerify]],\n  ['encrypt', [KeyOps.Encrypt]],\n  ['decrypt', [KeyOps.Decrypt]],\n  ['wrapKey', [KeyOps.WrapKey]],\n  ['unwrapKey', [KeyOps.UnwrapKey]],\n  ['deriveKey', [KeyOps.DeriveKey]],\n  ['deriveBits', [KeyOps.DeriveBits]],\n])\n","export enum KeyType {\n  OKP = 1,\n  EC = 2,\n  OCT = 4,\n  Reserved = 0,\n}\n\nexport enum JWKKeyType {\n  OKP = KeyType.OKP,\n  EC = KeyType.EC,\n  oct = KeyType.OCT,\n}\n","/**\n * Creates a new map with the keys and values of the given map swapped.\n *\n * @param map {Map<K, V>} the original map\n * @returns {Map<V, K>} the new map\n */\nexport const reverseMap = <K, V>(map: Map<K, V>): Map<V, K> => new Map(Array.from(map).map(([k, v]) => [v, k]))\n\nexport enum COSEKeyParam {\n  KeyType = 1,\n  KeyID = 2,\n  Algorithm = 3,\n  KeyOps = 4,\n  Curve = -1,\n  BaseIV = 5,\n  x = -2,\n  y = -3,\n  d = -4,\n  k = -1,\n}\n\nexport enum JWKParam {\n  kty = COSEKeyParam.KeyType,\n  kid = COSEKeyParam.KeyID,\n  alg = COSEKeyParam.Algorithm,\n  key_ops = COSEKeyParam.KeyOps,\n  base_iv = COSEKeyParam.BaseIV,\n  crv = COSEKeyParam.Curve,\n  x = COSEKeyParam.x,\n  y = COSEKeyParam.y,\n  d = COSEKeyParam.d,\n  k = COSEKeyParam.k,\n}\n\nexport const KTYSpecificJWKParams: Record<string, Map<number, string> | undefined> = {\n  EC: new Map([\n    [-1, 'crv'],\n    [-2, 'x'],\n    [-3, 'y'],\n    [-4, 'd'],\n  ]),\n  OKP: new Map([\n    [-1, 'crv'],\n    [-2, 'x'],\n    [-3, 'y'],\n    [-4, 'd'],\n  ]),\n  oct: new Map([[-1, 'k']]),\n}\n\nexport const KTYSpecificJWKParamsRev = Object.fromEntries(\n  // biome-ignore lint/style/noNonNullAssertion:\n  Object.entries(KTYSpecificJWKParams).map(([k, v]) => [k, reverseMap(v!)])\n)\n","import type { JWK } from 'jose'\nimport { cborDecode, cborEncode } from '../../cbor/index.js'\nimport { base64UrlToUint8Array, uint8ArrayToBase64Url } from '../../u-base64.js'\nimport { concatUint8Array, uint8ArrayToString } from '../../u-uint8-array.js'\nimport { Algorithms } from '../headers.js'\nimport { TypedMap } from '../typed-map.js'\nimport { Curve } from './curve.js'\nimport type { KeyOps } from './key-ops.js'\nimport { JWKKeyOps, JWKKeyOpsToCOSE } from './key-ops.js'\nimport type { KeyType } from './kty.js'\nimport { JWKKeyType } from './kty.js'\nimport { COSEKeyParam, JWKParam, KTYSpecificJWKParams, KTYSpecificJWKParamsRev } from './params.js'\n\nconst toArray = (v: unknown | unknown[]) => (Array.isArray(v) ? v : [v])\n\nfunction normalize(input: string | Uint8Array): string {\n  const encoded = input\n  if (encoded instanceof Uint8Array) {\n    return uint8ArrayToString(encoded)\n  }\n  return encoded\n}\n// @ts-ignore\nexport const JWKFromCOSEValue = new Map<string, (v: unknown) => string>([\n  ['kty', (value: KeyType) => JWKKeyType[value]],\n  ['crv', (value: Curve) => Curve[value]],\n  ['alg', (value: Algorithms) => Algorithms[value]],\n  ['kid', (v: string | Uint8Array) => (typeof v === 'string' ? v : uint8ArrayToBase64Url(v))],\n  ['key_ops', (v) => toArray(v).map((value) => JWKKeyOps.get(value))],\n  ...['x', 'y', 'd', 'k'].map((param) => [param, (v: Uint8Array) => uint8ArrayToBase64Url(v)]),\n])\n\nexport const JWKToCOSEValue = new Map<string, (v: unknown) => KeyType | Uint8Array | Algorithms | KeyOps[]>([\n  ['kty', (value: JWKKeyType) => JWKKeyType[value]],\n  ['crv', (value: Curve) => Curve[value]],\n  ['alg', (value: Algorithms) => Algorithms[value]],\n  ['kid', (v: unknown) => v],\n  ['key_ops', (v: unknown) => toArray(v).flatMap((value) => JWKKeyOpsToCOSE.get(value))],\n  ...['x', 'y', 'd', 'k'].map((label) => [\n    label,\n    (v: Uint8Array | string) => {\n      const normalized = normalize(v)\n      return base64UrlToUint8Array(normalized)\n    },\n  ]),\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n] as any)\n\nexport class COSEKey extends TypedMap<\n  | [COSEKeyParam.KeyType, KeyType]\n  | [COSEKeyParam.KeyID, Uint8Array]\n  | [COSEKeyParam.Algorithm, Algorithms]\n  | [COSEKeyParam.KeyOps, KeyOps[]]\n  | [COSEKeyParam.BaseIV, Uint8Array]\n  | [COSEKeyParam.Curve, Curve]\n  | [COSEKeyParam.x, Uint8Array]\n  | [COSEKeyParam.y, Uint8Array]\n  | [COSEKeyParam.d, Uint8Array]\n  | [COSEKeyParam.k, Uint8Array]\n> {\n  /**\n   * Import a COSEKey either decoded as Map<number, unknown> or as an encoded CBOR.\n   *\n   * @param data {Uint8Array | Map<number, unknown>}\n   * @returns\n   */\n  static import(data: Uint8Array | Map<number, unknown>): COSEKey {\n    if (data instanceof Uint8Array) {\n      return new COSEKey(cborDecode(data))\n    }\n    return new COSEKey(data as ConstructorParameters<typeof COSEKey>[0])\n  }\n\n  /**\n   *\n   * Create a COSEKey from a JWK.\n   *\n   * @param jwk {JWK} - A JWK.\n   * @returns\n   */\n  static fromJWK(jwk: JWK): COSEKey {\n    const coseKey = new COSEKey()\n    const kty = jwk.kty\n    for (const [key, value] of Object.entries(jwk)) {\n      const jwkKey = KTYSpecificJWKParamsRev[kty]?.get(key) ?? (JWKParam[key as keyof typeof JWKParam] as number)\n      const formatter = JWKToCOSEValue.get(key)\n      if (jwkKey && formatter) {\n        coseKey.set(jwkKey, formatter(value))\n      }\n    }\n    return coseKey\n  }\n\n  /**\n   *\n   * Returns a JWK representation of the COSEKey.\n   *\n   * @returns {JWK} - The JWK representation of the COSEKey.\n   */\n  toJWK(): JWK {\n    const kty = JWKKeyType[this.get(COSEKeyParam.KeyType) as unknown as JWKKeyType]\n    const result: JWK = { kty }\n\n    for (const [key, value] of this) {\n      const jwkKey = KTYSpecificJWKParams[kty]?.get(key) ?? JWKParam[key]\n      const parser = JWKFromCOSEValue.get(jwkKey)\n      if (parser && jwkKey) {\n        const parsed = parser(value)\n        // @ts-expect-error JWK has no index signature\n        result[jwkKey] = parsed\n      }\n    }\n    return result\n  }\n\n  /**\n   *\n   * Encode the COSEKey as a CBOR buffer.\n   *\n   * @returns {Uint8Array} - The encoded COSEKey.\n   */\n  encode(): Uint8Array {\n    return cborEncode(this.esMap)\n  }\n}\n\n/**\n * Exports the COSE Key as a raw key.\n *\n * It's effectively the same than:\n *\n * crypto.subtle.exportKey('raw', importedJWK)\n *\n * Note: This only works for KTY = EC.\n *\n * @param {Map<number, Uint8Array | number>} key - The COSE Key\n * @returns {Uint8Array} - The raw key\n */\nexport const COSEKeyToRAW = (key: Map<number, Uint8Array | number> | Uint8Array): Uint8Array => {\n  let decodedKey: Map<number, Uint8Array | number>\n  if (key instanceof Uint8Array) {\n    decodedKey = cborDecode(key)\n  } else {\n    decodedKey = key\n  }\n  const kty = decodedKey.get(1)\n  if (kty !== 2) {\n    throw new Error(`Expected COSE Key type: EC2 (2), got: ${kty}`)\n  }\n\n  // its a private key\n  if (decodedKey.has(-4)) {\n    return decodedKey.get(-4) as Uint8Array\n  }\n\n  return concatUint8Array(Uint8Array.from([0x04]), decodedKey.get(-2) as Uint8Array, decodedKey.get(-3) as Uint8Array)\n}\n","export class MDLError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = new.target.name\n    Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\nexport class MDLParseError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = new.target.name\n    Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import { MDLError } from './errors.js'\n\nexport interface VerificationAssessment {\n  status: 'PASSED' | 'FAILED' | 'WARNING'\n  category: 'DOCUMENT_FORMAT' | 'DEVICE_AUTH' | 'ISSUER_AUTH' | 'DATA_INTEGRITY'\n  check: string\n  reason?: string\n}\n\nexport type VerificationCallback = (item: VerificationAssessment) => void\n\nexport const defaultCallback: VerificationCallback = (verification) => {\n  if (verification.status !== 'FAILED') return\n  throw new MDLError(verification.reason ?? verification.check)\n}\n\nexport const onCatCheck = (onCheck: VerificationCallback, category: VerificationAssessment['category']) => {\n  return (item: Omit<VerificationAssessment, 'category'>) => {\n    onCheck({ ...item, category })\n  }\n}\n","import type { MdocContext, X509Context } from '../c-mdoc.js'\nimport { DataItem } from '../cbor/data-item.js'\nimport { cborEncode } from '../cbor/index.js'\nimport { areEqualUint8Array } from '../u-uint8-array.js'\nimport type IssuerAuth from './model/issuer-auth.js'\nimport type { DigestAlgorithm } from './model/types.js'\n\nexport const MDL_NAMESPACE = 'org.iso.18013.5.1'\n\nconst supportedDigestAlgorithms = ['SHA-256', 'SHA-384', 'SHA-512']\n\nexport type IssuerSignedDataItem = DataItem<Map<keyof IssuerSignedItem, unknown>>\n\nexport class IssuerSignedItem {\n  readonly #dataItem: IssuerSignedDataItem\n  #isValid: boolean | undefined\n\n  constructor(dataItem: IssuerSignedDataItem) {\n    this.#dataItem = dataItem\n  }\n\n  public encode() {\n    return this.#dataItem.buffer\n  }\n\n  public get dataItem() {\n    return this.#dataItem\n  }\n\n  private get decodedData() {\n    if (!this.#dataItem.data.has('digestID')) {\n      throw new Error('Invalid data item')\n    }\n    return this.#dataItem.data\n  }\n\n  public get digestID(): number {\n    return this.decodedData.get('digestID') as number\n  }\n\n  public get random(): Uint8Array {\n    return this.decodedData.get('random') as Uint8Array\n  }\n\n  public get elementIdentifier(): string {\n    return this.decodedData.get('elementIdentifier') as string\n  }\n\n  public get elementValue(): unknown {\n    return this.decodedData.get('elementValue')\n  }\n\n  public async calculateDigest(alg: DigestAlgorithm, ctx: { crypto: MdocContext['crypto'] }) {\n    const bytes = cborEncode(this.#dataItem)\n    const result = await ctx.crypto.digest({ digestAlgorithm: alg, bytes })\n    return result\n  }\n\n  public async isValid(\n    nameSpace: string,\n    { decodedPayload: { valueDigests, digestAlgorithm } }: IssuerAuth,\n    ctx: { crypto: MdocContext['crypto'] }\n  ): Promise<boolean> {\n    if (typeof this.#isValid !== 'undefined') {\n      return this.#isValid\n    }\n    if (!supportedDigestAlgorithms.includes(digestAlgorithm)) {\n      this.#isValid = false\n      return false\n    }\n    const digest = await this.calculateDigest(digestAlgorithm, ctx)\n    const digests = valueDigests?.get(nameSpace)\n    if (typeof digests === 'undefined') {\n      return false\n    }\n    const expectedDigest = digests.get(this.digestID)\n    this.#isValid = expectedDigest && areEqualUint8Array(digest, expectedDigest)\n    return Boolean(this.#isValid)\n  }\n\n  public matchCertificate(nameSpace: string, issuerAuth: IssuerAuth, ctx: { x509: X509Context }): boolean | undefined {\n    if (nameSpace !== MDL_NAMESPACE) {\n      return undefined\n    }\n\n    const issuingCountry = issuerAuth.getIssuingCountry(ctx)\n    const issuingStateOrProvince = issuerAuth.getIssuingStateOrProvince(ctx)\n\n    if (this.elementIdentifier === 'issuing_country') {\n      return issuingCountry === this.elementValue\n    }\n    if (this.elementIdentifier === 'issuing_jurisdiction') {\n      return issuingStateOrProvince === this.elementValue\n    }\n    return undefined\n  }\n\n  public static create(\n    digestID: number,\n    elementIdentifier: string,\n    elementValue: unknown,\n    ctx: { crypto: MdocContext['crypto'] }\n  ): IssuerSignedItem {\n    const random = ctx.crypto.random(32)\n    const dataItem: IssuerSignedDataItem = DataItem.fromData(\n      new Map([\n        ['digestID', digestID],\n        ['elementIdentifier', elementIdentifier],\n        ['elementValue', elementValue],\n        ['random', random],\n      ])\n    )\n    return new IssuerSignedItem(dataItem)\n  }\n}\n","import { DataItem } from '../cbor/data-item.js'\nimport { cborDecode } from '../cbor/index.js'\nimport type { DeviceRequestNameSpaces } from './model/device-request.js'\n\nexport interface ItemsRequestData {\n  docType: string\n  nameSpaces: DeviceRequestNameSpaces\n  requestInfo?: Record<string, unknown>\n}\n\nexport type ItemsRequestDataItem = DataItem<ItemsRequestData>\n\nexport class ItemsRequest {\n  #dataRecord?: ItemsRequestData\n  readonly #dataItem: ItemsRequestDataItem\n\n  constructor(dataItem: ItemsRequestDataItem) {\n    this.#dataItem = dataItem\n  }\n\n  public get dataItem() {\n    return this.#dataItem\n  }\n\n  public get data(): ItemsRequestData {\n    if (!this.#dataRecord) {\n      this.#dataRecord = cborDecode(this.#dataItem.buffer, {\n        tagUint8Array: false,\n        useRecords: true,\n        mapsAsObjects: true,\n      }) as ItemsRequestData\n    }\n\n    return this.#dataRecord\n  }\n\n  public static create(\n    docType: string,\n    nameSpaces: DeviceRequestNameSpaces,\n    requestInfo?: Record<string, unknown>\n  ): ItemsRequest {\n    const dataItem = DataItem.fromData({\n      docType,\n      nameSpaces,\n      requestInfo,\n    }) as unknown as ItemsRequestDataItem\n    return new ItemsRequest(dataItem)\n  }\n}\n","import { cborDecode, cborEncode } from '../../cbor'\nimport type { ItemsRequestData } from '../items-request'\nimport { ItemsRequest } from '../items-request'\n\nexport interface DocRequest {\n  itemsRequest: ItemsRequest\n  readerAuth?: ReaderAuth\n}\n\nexport type ReaderAuth = [\n  Uint8Array | undefined,\n  Uint8Array | undefined,\n  Uint8Array | undefined,\n  Uint8Array | undefined,\n]\n\nexport type DeviceRequestNameSpaces = Record<string, Record<string, boolean>>\n\nexport class DeviceRequest {\n  constructor(\n    public version: string,\n    public docRequests: DocRequest[]\n  ) {}\n\n  public static from(\n    version: string,\n    docRequests: {\n      itemsRequestData: ItemsRequestData\n      readerAuth?: ReaderAuth\n    }[]\n  ) {\n    return new DeviceRequest(\n      version,\n      docRequests.map((docRequest) => {\n        return {\n          ...docRequest,\n          itemsRequest: ItemsRequest.create(\n            docRequest.itemsRequestData.docType,\n            docRequest.itemsRequestData.nameSpaces,\n            docRequest.itemsRequestData.requestInfo\n          ),\n        }\n      })\n    )\n  }\n\n  public static parse(cbor: Uint8Array) {\n    const res = cborDecode(cbor, {\n      tagUint8Array: false,\n      useRecords: true,\n      mapsAsObjects: true,\n      // biome-ignore lint/suspicious/noExplicitAny:\n    }) as { version: string; docRequests: any[] }\n\n    const { version, docRequests } = res\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const parsedDocRequests: DocRequest[] = docRequests.map((docRequest) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n      const itemsRequest = new ItemsRequest(docRequest.itemsRequest)\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return {\n        ...docRequest,\n        itemsRequest,\n      }\n    })\n\n    return new DeviceRequest(version, parsedDocRequests)\n  }\n\n  public static encodeDocRequest(r: DocRequest) {\n    // biome-ignore lint/suspicious/noExplicitAny:\n    return new Map<string, any>([\n      ['itemsRequest', r.itemsRequest.dataItem],\n      ['readerAuth', r.readerAuth],\n    ])\n  }\n\n  encode() {\n    return cborEncode({\n      version: this.version,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      docRequests: this.docRequests.map(DeviceRequest.encodeDocRequest),\n    })\n  }\n}\n","import { cborDecodeUnknown, cborEncode } from '../cbor/index.js'\n\nexport class COSEBase {\n  #encodedProtectedHeaders?: Uint8Array\n  public readonly protectedHeaders: Map<number, unknown>\n\n  constructor(\n    protectedHeaders: Uint8Array | Map<number, unknown>,\n    public readonly unprotectedHeaders: Map<number, unknown>\n  ) {\n    if (protectedHeaders instanceof Uint8Array) {\n      this.#encodedProtectedHeaders = protectedHeaders\n      this.protectedHeaders =\n        protectedHeaders.length === 0\n          ? new Map<number, unknown>()\n          : (cborDecodeUnknown(protectedHeaders) as Map<number, unknown>)\n    } else {\n      this.protectedHeaders = protectedHeaders\n      this.#encodedProtectedHeaders = cborEncode(protectedHeaders)\n    }\n  }\n\n  protected get encodedProtectedHeaders(): Uint8Array | undefined {\n    return this.#encodedProtectedHeaders\n  }\n  public encode() {\n    return cborEncode(this)\n  }\n}\n","export function isObject(value: unknown): value is Record<string, unknown> {\n  return !!value && !Array.isArray(value) && typeof value === 'object'\n}\n\nclass UnknownCauseError extends Error {\n  [key: string]: unknown\n}\n\nexport function getCauseFromUnknown(cause: unknown): Error | undefined {\n  if (cause instanceof Error) {\n    return cause\n  }\n\n  const type = typeof cause\n  if (type === 'undefined' || type === 'function' || cause === null) {\n    return undefined\n  }\n\n  // Primitive types just get wrapped in an error\n  if (type !== 'object') {\n    return new Error(String(cause))\n  }\n\n  // If it's an object, we'll create a synthetic error\n  if (isObject(cause)) {\n    const err = new UnknownCauseError()\n    for (const key in cause) {\n      err[key] = cause[key]\n    }\n    return err\n  }\n\n  return undefined\n}\n\nexport const isCoseError = (cause: unknown): cause is CoseError => {\n  if (cause instanceof CoseError) {\n    return true\n  }\n  if (cause instanceof Error && cause.name === 'CoseError') {\n    // https://github.com/trpc/trpc/pull/4848\n    return true\n  }\n\n  return false\n}\n\nexport function getCoseErrorFromUnknown(cause: unknown): CoseError {\n  if (isCoseError(cause)) {\n    return cause\n  }\n\n  const coseError = new CoseError({\n    code: 'INTERNAL_SERVER_ERROR',\n    cause,\n  })\n\n  // Inherit stack from error\n  if (cause instanceof Error && cause.stack) {\n    coseError.stack = cause.stack\n  }\n\n  return coseError\n}\n\nexport type COSE_ERROR_CODE =\n  | 'INTERNAL_SERVER_ERROR'\n  | 'COSE_UNSUPPORTED_MAC'\n  | 'COSE_ALG_NOT_ALLOWED'\n  | 'COSE_INVALID_SIGNATURE'\n  | 'COSE_INVALID_ALG'\n  | 'COSE_UNSUPPORTED_ALG'\n\nexport class CoseError extends Error {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n  public override readonly cause?: Error\n  public readonly code\n\n  constructor(opts: {\n    message?: string\n    code: COSE_ERROR_CODE\n    cause?: unknown\n  }) {\n    const cause = getCauseFromUnknown(opts.cause)\n    const message = opts.message ?? cause?.message ?? opts.code\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore https://github.com/tc39/proposal-error-cause\n    super(message, { cause })\n\n    this.code = opts.code\n    this.name = 'CoseError'\n\n    if (!this.cause) {\n      // < ES2022 / < Node 16.9.0 compatability\n      this.cause = cause\n    }\n  }\n}\n","export const validateAlgorithms = (option: string, algorithms?: number[]) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'number'))) {\n    throw new TypeError(`\"${option}\" option must be an array of numbers`)\n  }\n\n  if (!algorithms) {\n    return undefined\n  }\n\n  return new Set(algorithms)\n}\n","import { addExtension, cborEncode } from '../cbor/index.js'\nimport { COSEBase } from './cose-base.js'\nimport { CoseError } from './e-cose.js'\nimport type { MacAlgorithms, SupportedMacAlg } from './headers.js'\nimport { Headers, MacAlgorithmNames, MacProtectedHeaders, ProtectedHeaders, UnprotectedHeaders } from './headers.js'\nimport { validateAlgorithms } from './validate-algorithms.js'\nexport interface VerifyOptions {\n  externalAAD?: Uint8Array\n  detachedPayload?: Uint8Array\n  algorithms?: MacAlgorithms[]\n}\n\nexport class Mac0 extends COSEBase {\n  constructor(\n    protectedHeaders: Map<number, unknown> | Uint8Array,\n    unprotectedHeaders: Map<number, unknown>,\n    public readonly payload: Uint8Array,\n    private _tag?: Uint8Array\n  ) {\n    super(protectedHeaders, unprotectedHeaders)\n  }\n\n  private static createMAC0(protectedHeaders: Uint8Array, applicationHeaders: Uint8Array, payload: Uint8Array) {\n    return cborEncode(['MAC0', protectedHeaders, applicationHeaders, payload])\n  }\n\n  public getContentForEncoding() {\n    return [this.encodedProtectedHeaders, this.unprotectedHeaders, this.payload, this.tag]\n  }\n\n  public get tag() {\n    if (!this._tag) {\n      throw new Error('No signature present')\n    }\n\n    return this._tag\n  }\n\n  public set tag(sig: Uint8Array) {\n    this._tag = sig\n  }\n\n  public get alg(): MacAlgorithms | undefined {\n    return this.protectedHeaders.get(Headers.Algorithm) as MacAlgorithms\n  }\n\n  public get algName(): SupportedMacAlg | undefined {\n    return this.alg ? MacAlgorithmNames.get(this.alg) : undefined\n  }\n\n  public hasSupportedAlg() {\n    return !!this.algName\n  }\n\n  static create(\n    protectedHeaders: MacProtectedHeaders | ConstructorParameters<typeof MacProtectedHeaders>[0],\n    unprotectedHeaders: UnprotectedHeaders | ConstructorParameters<typeof UnprotectedHeaders>[0] | undefined,\n    payload: Uint8Array,\n    signature?: Uint8Array\n  ) {\n    const wProtectedHeaders = MacProtectedHeaders.wrap(protectedHeaders)\n    const mac0AlgName = wProtectedHeaders.get(Headers.Algorithm)\n    const alg = mac0AlgName ? MacAlgorithmNames.get(mac0AlgName) : undefined\n\n    if (!alg) {\n      throw new CoseError({\n        code: 'COSE_INVALID_ALG',\n        message: `The [${Headers.Algorithm}] (Algorithm) header must be set.`,\n      })\n    }\n\n    const encodedProtectedHeaders = cborEncode(wProtectedHeaders.esMap)\n    const wUnprotectedHeaders = UnprotectedHeaders.wrap(unprotectedHeaders)\n\n    return new Mac0(encodedProtectedHeaders, wUnprotectedHeaders.esMap as Map<number, unknown>, payload, signature)\n  }\n\n  public getRawSigningData() {\n    const algName = this.algName\n    if (!algName) {\n      throw new CoseError({\n        code: 'COSE_INVALID_ALG',\n        message: 'Cannot get raw signing data. Mac alg is not defined',\n      })\n    }\n\n    const toBeSigned = Mac0.createMAC0(\n      cborEncode(ProtectedHeaders.wrap(this.protectedHeaders).esMap),\n      new Uint8Array(),\n      this.payload\n    )\n\n    return { data: toBeSigned, alg: algName }\n  }\n\n  public getRawVerificationData(options?: VerifyOptions) {\n    const mac0Structure = Mac0.createMAC0(\n      this.encodedProtectedHeaders ?? new Uint8Array(),\n      options?.externalAAD ?? new Uint8Array(),\n      options?.detachedPayload ?? this.payload\n    )\n\n    if (!this.alg || !this.algName || !MacAlgorithmNames.has(this.alg)) {\n      throw new CoseError({\n        code: 'COSE_UNSUPPORTED_MAC',\n        message: `Unsupported MAC algorithm '${this.alg}'`,\n      })\n    }\n\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms)\n\n    if (algorithms && !algorithms.has(this.alg)) {\n      throw new CoseError({\n        code: 'COSE_UNSUPPORTED_ALG',\n        message: `[${Headers.Algorithm}] (algorithm) Header Parameter not allowed`,\n      })\n    }\n\n    return {\n      alg: this.algName,\n      signature: this.tag,\n      data: mac0Structure,\n    }\n  }\n\n  static tag = 17\n}\n\naddExtension({\n  Class: Mac0,\n  tag: Mac0.tag,\n  encode(instance: Mac0, encodeFn: (obj: unknown) => Uint8Array) {\n    return encodeFn(instance.getContentForEncoding())\n  },\n  decode: (data: ConstructorParameters<typeof Mac0>) => {\n    return new Mac0(data[0], data[1], data[2], data[3])\n  },\n})\n","import { COSEBase } from './cose-base.js'\nimport { CoseError } from './e-cose.js'\nimport type { Algorithms } from './headers.js'\nimport { AlgorithmNames, Headers } from './headers.js'\nimport { validateAlgorithms } from './validate-algorithms.js'\n\nexport interface VerifyOptions {\n  externalAAD?: Uint8Array\n  detachedPayload?: Uint8Array\n  algorithms?: Algorithms[]\n}\n\nexport class SignatureBase extends COSEBase {\n  constructor(\n    protectedHeaders: Uint8Array | Map<number, unknown>,\n    unprotectedHeaders: Map<number, unknown>,\n    private _signature?: Uint8Array\n  ) {\n    super(protectedHeaders, unprotectedHeaders)\n  }\n\n  public get signature() {\n    if (!this._signature) {\n      throw new Error('No signature present')\n    }\n\n    return this._signature\n  }\n\n  public set signature(sig: Uint8Array) {\n    this._signature = sig\n  }\n\n  /**\n      This parameter is used to indicate the algorithm used for the\n      security processing.  This parameter MUST be authenticated where\n      the ability to do so exists.  This support is provided by AEAD\n      algorithms or construction (COSE_Sign, COSE_Sign0, COSE_Mac, and\n      COSE_Mac0).  This authentication can be done either by placing the\n      header in the protected header bucket or as part of the externally\n      supplied data.  The value is taken from the \"COSE Algorithms\"\n      registry (see Section 16.4).\n   */\n  public get alg(): Algorithms | undefined {\n    return (\n      (this.protectedHeaders.get(Headers.Algorithm) as Algorithms | undefined) ??\n      (this.unprotectedHeaders.get(Headers.Algorithm) as Algorithms)\n    )\n  }\n\n  public get algName(): string | undefined {\n    return this.alg ? AlgorithmNames.get(this.alg) : undefined\n  }\n\n  /**\n      This parameter identifies one piece of data that can be used as\n      input to find the needed cryptographic key.  The value of this\n      parameter can be matched against the 'kid' member in a COSE_Key\n      structure.  Other methods of key distribution can define an\n      equivalent field to be matched.  Applications MUST NOT assume that\n      'kid' values are unique.  There may be more than one key with the\n      same 'kid' value, so all of the keys associated with this 'kid'\n      may need to be checked.  The internal structure of 'kid' values is\n      not defined and cannot be relied on by applications.  Key\n      identifier values are hints about which key to use.  This is not a\n      security-critical field.  For this reason, it can be placed in the\n      unprotected headers bucket.\n   */\n  public get kid(): Uint8Array | undefined {\n    return (\n      (this.protectedHeaders.get(Headers.KeyID) as Uint8Array | undefined) ??\n      (this.unprotectedHeaders.get(Headers.KeyID) as Uint8Array)\n    )\n  }\n\n  public get x5chain(): [Uint8Array, ...Uint8Array[]] | undefined {\n    const x5chain =\n      (this.protectedHeaders.get(Headers.X5Chain) as Uint8Array | Uint8Array[] | undefined) ??\n      (this.unprotectedHeaders.get(Headers.X5Chain) as Uint8Array | Uint8Array[] | undefined)\n\n    if (!x5chain?.[0]) {\n      return undefined\n    }\n    return Array.isArray(x5chain) ? (x5chain as [Uint8Array, ...Uint8Array[]]) : [x5chain]\n  }\n\n  protected internalGetRawVerificationData(payload: Uint8Array, options?: VerifyOptions) {\n    if (!this.alg || !this.algName || !AlgorithmNames.has(this.alg)) {\n      throw new CoseError({\n        code: 'COSE_UNSUPPORTED_ALG',\n        message: `Unsupported alg '${this.alg}'`,\n      })\n    }\n\n    const algorithms = options?.algorithms && validateAlgorithms('algorithms', options.algorithms)\n\n    if (algorithms && !algorithms.has(this.alg)) {\n      throw new CoseError({\n        code: 'COSE_INVALID_ALG',\n        message: `[${Headers.Algorithm}] (algorithm) Header Parameter not allowed`,\n      })\n    }\n\n    return {\n      alg: this.algName,\n      signature: this.signature,\n      data: payload,\n    }\n  }\n}\n","import { addExtension, cborEncode } from '../cbor/index.js'\nimport { CoseError } from './e-cose.js'\nimport { AlgorithmNames, Headers, ProtectedHeaders, UnprotectedHeaders } from './headers.js'\nimport type { VerifyOptions } from './signature-base.js'\nimport { SignatureBase } from './signature-base.js'\n\nexport class Sign1 extends SignatureBase {\n  constructor(\n    protectedHeaders: Map<number, unknown> | Uint8Array,\n    unprotectedHeaders: Map<number, unknown>,\n    public readonly payload: Uint8Array,\n    _signature?: Uint8Array\n  ) {\n    super(protectedHeaders, unprotectedHeaders, _signature)\n  }\n\n  public getContentForEncoding() {\n    return [this.encodedProtectedHeaders, this.unprotectedHeaders, this.payload, this.signature]\n  }\n\n  private static Signature1(protectedHeaders: Uint8Array, applicationHeaders: Uint8Array, payload: Uint8Array) {\n    return cborEncode(['Signature1', protectedHeaders, applicationHeaders, payload])\n  }\n\n  public static create(\n    protectedHeaders: ProtectedHeaders | ConstructorParameters<typeof ProtectedHeaders>[0],\n    unprotectedHeaders: UnprotectedHeaders | ConstructorParameters<typeof UnprotectedHeaders>[0] | undefined,\n    payload: Uint8Array,\n    signature?: Uint8Array\n  ) {\n    const wProtectedHeaders = ProtectedHeaders.wrap(protectedHeaders)\n    const sig1AlgName = wProtectedHeaders.get(Headers.Algorithm)\n    const alg = sig1AlgName ? AlgorithmNames.get(sig1AlgName) : undefined\n\n    if (!alg) {\n      throw new CoseError({\n        code: 'COSE_INVALID_ALG',\n        message: `The [${Headers.Algorithm}] (Algorithm) header must be set.`,\n      })\n    }\n\n    const encodedProtectedHeaders = cborEncode(wProtectedHeaders.esMap)\n    const wUnprotectedHeaders = UnprotectedHeaders.wrap(unprotectedHeaders)\n\n    return new Sign1(encodedProtectedHeaders, wUnprotectedHeaders.esMap as Map<number, unknown>, payload, signature)\n  }\n\n  public getRawSigningData() {\n    const alg = this.algName\n    if (!alg) {\n      throw new CoseError({\n        code: 'COSE_INVALID_ALG',\n        message: 'Cannot get raw signing data. Alg is not defined',\n      })\n    }\n\n    const toBeSigned = Sign1.Signature1(\n      cborEncode(ProtectedHeaders.wrap(this.protectedHeaders).esMap),\n      new Uint8Array(),\n      this.payload\n    )\n\n    return {\n      data: toBeSigned,\n      alg,\n    }\n  }\n\n  public getRawVerificationData(options?: VerifyOptions) {\n    const toBeSigned = Sign1.Signature1(\n      this.encodedProtectedHeaders ?? new Uint8Array(),\n      options?.externalAAD ?? new Uint8Array(),\n      options?.detachedPayload ?? this.payload\n    )\n\n    return this.internalGetRawVerificationData(toBeSigned)\n  }\n\n  static tag = 18\n}\n\naddExtension({\n  Class: Sign1,\n  tag: Sign1.tag,\n  encode(instance: Sign1, encodeFn: (obj: unknown) => Uint8Array) {\n    return encodeFn(instance.getContentForEncoding())\n  },\n  decode: (data: ConstructorParameters<typeof Sign1>) => {\n    return new Sign1(data[0], data[1], data[2], data[3])\n  },\n})\n","import { compareVersions } from 'compare-versions'\nimport { cborDecode } from '../cbor/index.js'\nimport { Mac0 } from '../cose/mac0.js'\nimport { Sign1 } from '../cose/sign1.js'\nimport { MDLParseError } from './errors.js'\nimport { IssuerSignedItem } from './issuer-signed-item.js'\nimport { DeviceSignedDocument } from './model/device-signed-document.js'\nimport IssuerAuth from './model/issuer-auth.js'\nimport { IssuerSignedDocument } from './model/issuer-signed-document.js'\nimport { MDoc } from './model/mdoc.js'\nimport type {\n  DeviceAuth,\n  DeviceSigned,\n  IssuerNameSpaces,\n  IssuerSigned,\n  RawDeviceAuth,\n  RawIndexedDataItem,\n  RawIssuerAuth,\n  RawNameSpaces,\n} from './model/types.js'\n\nconst parseIssuerAuthElement = (rawIssuerAuth: RawIssuerAuth, expectedDocType?: string): IssuerAuth => {\n  const issuerAuth = new IssuerAuth(...rawIssuerAuth)\n  const { decodedPayload } = issuerAuth\n  const { docType, version } = decodedPayload\n\n  if (expectedDocType && docType !== expectedDocType) {\n    throw new MDLParseError(`The issuerAuth docType must be ${expectedDocType}`)\n  }\n\n  if (!version || compareVersions(version, '1.0') !== 0) {\n    throw new MDLParseError(\"The issuerAuth version must be '1.0'\")\n  }\n\n  return issuerAuth\n}\n\nconst parseDeviceAuthElement = (rawDeviceAuth: RawDeviceAuth): DeviceAuth => {\n  const { deviceSignature, deviceMac } = Object.fromEntries(rawDeviceAuth)\n  if (deviceSignature) {\n    return { deviceSignature: new Sign1(...deviceSignature) }\n  }\n  if (deviceMac) {\n    return { deviceMac: new Mac0(...deviceMac) }\n  }\n\n  throw new MDLParseError(`Invalid deviceAuth element. Missing 'deviceSignature' and 'deviceMac'`)\n}\n\nconst namespaceToArray = (entries: RawIndexedDataItem): IssuerSignedItem[] => {\n  return entries.map((di) => new IssuerSignedItem(di))\n}\n\nconst mapIssuerNameSpaces = (namespace: RawNameSpaces): IssuerNameSpaces => {\n  return Array.from(namespace.entries()).reduce((prev, [nameSpace, entries]) => {\n    const mappedNamespace = namespaceToArray(entries)\n    return {\n      ...prev,\n      [nameSpace]: mappedNamespace,\n    }\n  }, {})\n}\n\nconst mapDeviceNameSpaces = (namespace: Map<string, Map<string, unknown>>) => {\n  const entries = Array.from(namespace.entries()).map(([ns, attrs]) => {\n    return [ns, Object.fromEntries(attrs.entries())]\n  })\n  return Object.fromEntries(entries)\n}\n\n/**\n * Parse a IssuerSignedDocument\n *\n * @param issuerSigned - The cbor encoded or decoded IssuerSigned Structure\n * @returns {Promise<IssuerSignedDocument>} - The parsed IssuerSigned document\n */\nexport const parseIssuerSigned = (\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  issuerSigned: Uint8Array | Map<string, any>,\n  expectedDocType?: string\n): IssuerSignedDocument => {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  let issuerSignedDecoded: Map<string, any>\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    issuerSignedDecoded = issuerSigned instanceof Map ? issuerSigned : (cborDecode(issuerSigned) as Map<string, any>)\n  } catch (err) {\n    throw new MDLParseError(\n      `Unable to decode issuer signed document: ${err instanceof Error ? err.message : 'Unknown error'}`\n    )\n  }\n\n  const issuerAuth = parseIssuerAuthElement(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    issuerSignedDecoded.get('issuerAuth'),\n    expectedDocType\n  )\n\n  const parsedIssuerSigned: IssuerSigned = {\n    ...issuerSignedDecoded,\n    nameSpaces: mapIssuerNameSpaces(\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      issuerSignedDecoded.get('nameSpaces')\n    ),\n    issuerAuth,\n  }\n\n  return new IssuerSignedDocument(issuerAuth.decodedPayload.docType, parsedIssuerSigned)\n}\n\n/**\n * Parse a DeviceSignedDocument\n *\n * @param deviceSigned - The cbor encoded or decoded DeviceSigned Structure\n * @param issuerSigned - The cbor encoded or decoded IssuerSigned Structure\n * @returns {Promise<DeviceSignedDocument>} - The parsed DeviceSigned document\n */\nexport const parseDeviceSigned = (\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  deviceSigned: Uint8Array | Map<string, any>,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  issuerSigned: Uint8Array | Map<string, any>,\n  expectedDocType?: string\n): DeviceSignedDocument => {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  let deviceSignedDecoded: Map<string, any>\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    deviceSignedDecoded = deviceSigned instanceof Map ? deviceSigned : (cborDecode(deviceSigned) as Map<string, any>)\n  } catch (err) {\n    throw new MDLParseError(\n      `Unable to decode device signed document : ${err instanceof Error ? err.message : 'Unknown error'}`\n    )\n  }\n\n  const deviceSignedParsed: DeviceSigned = {\n    ...deviceSignedDecoded,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n    nameSpaces: mapDeviceNameSpaces(deviceSignedDecoded.get('nameSpaces').data),\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    deviceAuth: parseDeviceAuthElement(deviceSignedDecoded.get('deviceAuth')),\n  }\n\n  const issuerSignedDocument = parseIssuerSigned(issuerSigned, expectedDocType)\n\n  return new DeviceSignedDocument(issuerSignedDocument.docType, issuerSignedDocument.issuerSigned, deviceSignedParsed)\n}\n\n/**\n * Parse an mdoc\n *\n * @param encoded - The cbor encoded mdoc\n * @returns {Promise<MDoc>} - The parsed device response\n */\nexport const parseDeviceResponse = (encoded: Uint8Array): MDoc => {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  let deviceResponse: Map<string, any>\n  try {\n    deviceResponse = cborDecode(encoded) as Map<string, unknown>\n  } catch (err) {\n    throw new MDLParseError(`Unable to decode device response: ${err instanceof Error ? err.message : 'Unknown error'}`)\n  }\n\n  const { version, documents, status } = Object.fromEntries(deviceResponse)\n\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  const parsedDocuments: IssuerSignedDocument[] = documents.map((doc: Map<string, any>): IssuerSignedDocument => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const docType = doc.get('docType')\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const issuerSigned = doc.get('issuerSigned')\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const deviceSigned = doc.get('deviceSigned')\n\n    if (deviceSigned) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      return parseDeviceSigned(deviceSigned, issuerSigned, docType)\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return parseIssuerSigned(issuerSigned, docType)\n  })\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  return new MDoc(parsedDocuments, version, status)\n}\n","import type { DocType, IssuerSigned, MdocNameSpaces } from './types.js'\n\n/**\n * Represents an issuer signed document.\n *\n * Note: You don't need instantiate this class.\n * This is the return type of the parser and the document.sign() method.\n */\nexport class IssuerSignedDocument {\n  constructor(\n    public readonly docType: DocType,\n    public readonly issuerSigned: IssuerSigned\n  ) {}\n\n  /**\n   * Create the structure for encoding a document.\n   *\n   * @returns {Map<string, unknown>} - The document as a map\n   */\n  public prepare(): Map<string, unknown> {\n    const nameSpaces = new Map(\n      Object.entries(this.issuerSigned.nameSpaces).map(([nameSpace, items]) => {\n        return [nameSpace, items.map((item) => item.dataItem)] as const\n      })\n    )\n\n    // TODO: ERRORS MISSING\n    const docMap = new Map(\n      Object.entries({\n        docType: this.docType,\n        issuerSigned: {\n          nameSpaces,\n          issuerAuth: this.issuerSigned.issuerAuth.getContentForEncoding(),\n        },\n      })\n    )\n    return docMap\n  }\n\n  /**\n   * Helper method to get the values in a namespace as a JS object.\n   *\n   * @param {string} namespace - The namespace to add.\n   * @returns {Record<string, unknown>} - The values in the namespace as an object\n   */\n  getIssuerNameSpace(namespace: string): Record<string, unknown> | undefined {\n    const nameSpace = this.issuerSigned.nameSpaces[namespace]\n    if (!nameSpace) return undefined\n    return Object.fromEntries(nameSpace.map((item) => [item.elementIdentifier, item.elementValue]))\n  }\n\n  /**\n   * List of namespaces in the document.\n   */\n  get issuerSignedNameSpaces(): string[] {\n    return Object.keys(this.issuerSigned.nameSpaces)\n  }\n\n  public get allIssuerSignedNamespaces(): MdocNameSpaces {\n    const namespaces = this.issuerSignedNameSpaces\n\n    return Object.fromEntries(\n      namespaces.map((namespace) => {\n        const namespaceValues = this.getIssuerNameSpace(namespace)\n        if (!namespaceValues) {\n          throw new Error(`Cannot extract the namespace '${namespace}' from the mdoc.`)\n        }\n        return [namespace, namespaceValues]\n      })\n    )\n  }\n}\n","import { DataItem } from '../../cbor/data-item.js'\nimport { IssuerSignedDocument } from './issuer-signed-document.js'\nimport type { DeviceSigned, DocType, IssuerSigned, MdocNameSpaces } from './types.js'\n\n/**\n * Represents a device signed document.\n *\n * Note: You don't need to instantiate this class.\n * This is the return type of the parser and it will be generated by the DeviceResponse builder.\n */\nexport class DeviceSignedDocument extends IssuerSignedDocument {\n  constructor(\n    docType: DocType,\n    issuerSigned: IssuerSigned,\n    public readonly deviceSigned: DeviceSigned\n  ) {\n    super(docType, issuerSigned)\n  }\n\n  override prepare(): Map<string, unknown> {\n    const doc = super.prepare()\n\n    const deviceSignature = this.deviceSigned.deviceAuth.deviceSignature?.getContentForEncoding()\n    const deviceMac = this.deviceSigned.deviceAuth.deviceMac?.getContentForEncoding()\n    // detach payload\n    if (deviceMac) {\n      deviceMac[2] = undefined\n    }\n    if (deviceSignature) {\n      deviceSignature[2] = undefined\n    }\n    //\n    doc.set('deviceSigned', {\n      ...this.deviceSigned,\n      nameSpaces: DataItem.fromData(this.deviceSigned.nameSpaces),\n      // TODO: ERRORS MISSING\n      deviceAuth: {\n        ...this.deviceSigned.deviceAuth,\n        deviceSignature,\n        deviceMac,\n      },\n    })\n\n    return doc\n  }\n\n  /**\n   * Helper method to get the values in a namespace as a JS object.\n   *\n   * @param {string} namespace - The namespace to add.\n   * @returns {Record<string, unknown>} - The values in the namespace as an object\n   */\n  getDeviceNameSpace(namespace: string): Record<string, unknown> | undefined {\n    return this.deviceSigned.nameSpaces[namespace]\n  }\n\n  /**\n   * List of namespaces in the document.\n   */\n  get deviceSignedNameSpaces(): string[] {\n    return Object.keys(this.deviceSigned.nameSpaces)\n  }\n\n  public get allDeviceSignedNamespaces(): MdocNameSpaces {\n    const namespaces = this.deviceSignedNameSpaces\n\n    return Object.fromEntries(\n      namespaces.map((namespace) => {\n        const namespaceValues = this.getDeviceNameSpace(namespace)\n        if (!namespaceValues) {\n          throw new Error(`Cannot extract the namespace '${namespace}' from the mdoc.`)\n        }\n        return [namespace, namespaceValues]\n      })\n    )\n  }\n}\n","import type { X509Context } from '../../c-mdoc.js'\nimport { DataItem } from '../../cbor/data-item.js'\nimport { cborDecode } from '../../cbor/index.js'\nimport type { ProtectedHeaders, UnprotectedHeaders } from '../../cose/headers.js'\nimport { Sign1 } from '../../cose/sign1.js'\nimport type { MSO } from './types.js'\n\n/**\n * The IssuerAuth which is a COSE_Sign1 message\n * as defined in https://www.iana.org/assignments/cose/cose.xhtml#messages\n */\nexport default class IssuerAuth extends Sign1 {\n  #decodedPayload?: MSO\n  #x5chain?: [Uint8Array, ...Uint8Array[]]\n\n  public get decodedPayload(): MSO {\n    if (this.#decodedPayload) {\n      return this.#decodedPayload\n    }\n\n    let decoded = cborDecode(this.payload)\n    decoded = decoded instanceof DataItem ? decoded.data : decoded\n    decoded = Object.fromEntries(decoded)\n    const mapValidityInfo = (validityInfo: Map<string, Uint8Array>) => {\n      if (!validityInfo) {\n        return validityInfo\n      }\n      return Object.fromEntries(\n        [...validityInfo.entries()].map(([key, value]) => {\n          return [key, value instanceof Uint8Array ? cborDecode(value) : value]\n        })\n      )\n    }\n\n    const result: MSO = {\n      ...decoded,\n      validityInfo: mapValidityInfo(decoded.validityInfo),\n      validityDigests: decoded.validityDigests ? Object.fromEntries(decoded.validityDigests) : undefined,\n      deviceKeyInfo: decoded.deviceKeyInfo ? Object.fromEntries(decoded.deviceKeyInfo) : undefined,\n    }\n    this.#decodedPayload = result\n    return result\n  }\n\n  public get certificateChain() {\n    if (this.#x5chain) return this.#x5chain\n    this.#x5chain = this.x5chain\n\n    if (!this.#x5chain) {\n      throw new Error('No certificate found')\n    }\n    return this.#x5chain\n  }\n\n  public get certificate() {\n    return this.certificateChain[0]\n  }\n\n  public getIssuingCountry(ctx: { x509: X509Context }) {\n    const countryName = ctx.x509.getIssuerNameField({\n      certificate: this.certificate,\n      field: 'C',\n    })[0]\n\n    return countryName\n  }\n\n  public getIssuingStateOrProvince(ctx: { x509: X509Context }) {\n    const stateOrProvince = ctx.x509.getIssuerNameField({\n      certificate: this.certificate,\n      field: 'ST',\n    })[0]\n\n    return stateOrProvince\n  }\n\n  static override create(\n    protectedHeaders: ProtectedHeaders,\n    unprotectedHeaders: UnprotectedHeaders | undefined,\n    payload: Uint8Array\n  ): IssuerAuth {\n    const sign1 = Sign1.create(protectedHeaders, unprotectedHeaders, payload)\n\n    return new IssuerAuth(sign1.protectedHeaders, sign1.unprotectedHeaders, sign1.payload)\n  }\n}\n","import { cborEncode } from '../../cbor/index.js'\nimport type { IssuerSignedDocument } from './issuer-signed-document.js'\n\nexport type ErrorCode = number\nexport type ErrorItems = Record<string, ErrorCode>\nexport interface DocumentError {\n  DocType: ErrorCode\n}\n\nexport enum MDocStatus {\n  OK = 0,\n  GeneralError = 10,\n  CBORDecodingError = 11,\n  CBORValidationError = 12,\n}\n\nexport class MDoc {\n  constructor(\n    public readonly documents: IssuerSignedDocument[] = [],\n    public readonly version = '1.0',\n    public readonly status: MDocStatus = MDocStatus.OK,\n    public readonly documentErrors: DocumentError[] = []\n  ) {}\n\n  addDocument(document: IssuerSignedDocument) {\n    if (typeof document.issuerSigned === 'undefined') {\n      throw new Error('Cannot add an unsigned document')\n    }\n    this.documents.push(document)\n  }\n\n  encode() {\n    // TODO: ERROR MISSING\n    return cborEncode({\n      version: this.version,\n      documents: this.documents.map((doc) => doc.prepare()),\n      status: this.status,\n    })\n  }\n}\n","import { DataItem } from '../cbor/data-item.js'\nimport { cborDecode, cborEncode } from '../cbor/index.js'\nimport { base64ToUint8Array } from '../u-base64.js'\n\nexport const calculateDeviceAutenticationBytes = (\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  sessionTranscript: Uint8Array | any,\n  docType: string,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  nameSpaces: Record<string, Record<string, any>>\n): Uint8Array => {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  let decodedSessionTranscript: any\n  if (sessionTranscript instanceof Uint8Array) {\n    // assume is encoded in a DataItem\n    decodedSessionTranscript = (cborDecode(sessionTranscript) as DataItem).data\n  } else {\n    decodedSessionTranscript = sessionTranscript\n  }\n\n  const nameSpacesAsMap = new Map(Object.entries(nameSpaces).map(([ns, items]) => [ns, new Map(Object.entries(items))]))\n  const encode = DataItem.fromData([\n    'DeviceAuthentication',\n    decodedSessionTranscript,\n    docType,\n    DataItem.fromData(nameSpacesAsMap),\n  ])\n\n  const result = cborEncode(encode)\n\n  return result\n}\n\nexport function fromPEM(pem: string): Uint8Array {\n  const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/gm, '').replace(/\\s/gm, '')\n  return base64ToUint8Array(base64)\n}\n","import type { IssuerSignedItem } from '../issuer-signed-item.js'\nimport type { DeviceRequestNameSpaces } from './device-request.js'\nimport type { IssuerSignedDocument } from './issuer-signed-document.js'\nimport type { MDoc } from './mdoc.js'\nimport type { InputDescriptor } from './presentation-definition.js'\nimport type { DocType, IssuerNameSpaces } from './types.js'\n\nexport const limitDisclosureToDeviceRequestNameSpaces = (\n  mdoc: IssuerSignedDocument,\n  deviceRequestNameSpaces: DeviceRequestNameSpaces\n): Record<string, IssuerSignedItem[]> => {\n  const nameSpaces: Record<string, IssuerSignedItem[]> = {}\n\n  for (const [nameSpace, nameSpaceFields] of Object.entries(deviceRequestNameSpaces)) {\n    const nsAttrs = mdoc.issuerSigned.nameSpaces[nameSpace] ?? []\n    const digests = Object.entries(nameSpaceFields).map(([elementIdentifier, _]) => {\n      const digest = prepareDigest(elementIdentifier, nsAttrs)\n      if (!digest) {\n        throw new Error(`No matching field found for '${elementIdentifier}'`)\n      }\n      return digest\n    })\n\n    nameSpaces[nameSpace] = digests\n  }\n  return nameSpaces\n}\n\nconst prepareDigest = (elementIdentifier: string, nsAttrs: IssuerSignedItem[]): IssuerSignedItem | null => {\n  if (elementIdentifier.startsWith('age_over_')) {\n    const digest = handleAgeOverNN(elementIdentifier, nsAttrs)\n    return digest\n  }\n\n  const digest = nsAttrs.find((d) => d.elementIdentifier === elementIdentifier)\n  return digest ?? null\n}\n\nconst prepareDigestForInputDescriptor = (\n  paths: string[],\n  issuerNameSpaces: IssuerNameSpaces\n): { nameSpace: string; digest: IssuerSignedItem } | null => {\n  for (const path of paths) {\n    const { nameSpace, elementIdentifier } = parsePath(path)\n    const nsAttrs = issuerNameSpaces[nameSpace] ?? []\n\n    const digest = prepareDigest(elementIdentifier, nsAttrs)\n    if (digest) return { nameSpace, digest }\n  }\n  return null\n}\n\nconst parsePath = (\n  path: string\n): {\n  nameSpace: string\n  elementIdentifier: string\n} => {\n  /**\n   * path looks like this: \"$['org.iso.18013.5.1']['family_name']\"\n   * the regex creates two groups with contents between \"['\" and \"']\"\n   * the second entry in each group contains the result without the \"'[\" or \"']\"\n   *\n   * @example org.iso.18013.5.1 family_name\n   */\n  const matches = [...path.matchAll(/\\['(.*?)'\\]/g)]\n  if (matches.length !== 2) {\n    throw new Error(`Invalid path format: \"${path}\"`)\n  }\n\n  const [nameSpaceMatch, elementIdentifierMatch] = matches\n  const nameSpace = nameSpaceMatch?.[1]\n  const elementIdentifier = elementIdentifierMatch?.[1]\n\n  if (!nameSpace || !elementIdentifier) {\n    throw new Error(`Failed to parse path: \"${path}\"`)\n  }\n\n  return { nameSpace, elementIdentifier }\n}\n\nconst handleAgeOverNN = (request: string, attributes: IssuerSignedItem[]): IssuerSignedItem | null => {\n  const ageOverList = attributes\n    .map((a, i) => {\n      const { elementIdentifier: key, elementValue: value } = a\n      return { key, value, index: i }\n    })\n    .filter((i) => i.key.startsWith('age_over_'))\n    .map((i) => ({\n      nn: Number.parseInt(i.key.replace('age_over_', ''), 10),\n      ...i,\n    }))\n    .sort((a, b) => a.nn - b.nn)\n\n  const reqNN = Number.parseInt(request.replace('age_over_', ''), 10)\n\n  let item: (typeof ageOverList)[number] | undefined\n  // Find nearest TRUE\n  item = ageOverList.find((i) => i.value === true && i.nn >= reqNN)\n\n  if (!item) {\n    // Find the nearest False\n    item = ageOverList.sort((a, b) => b.nn - a.nn).find((i) => i.value === false && i.nn <= reqNN)\n  }\n\n  if (!item) {\n    return null\n  }\n\n  return attributes[item.index]\n}\n\nexport const findMdocMatchingDocType = (mdoc: MDoc, docType: DocType) => {\n  const matchingMdoc = mdoc.documents.filter((document) => document.docType === docType)\n\n  if (!matchingMdoc[0]) {\n    throw new Error(`Cannot limit the disclosure. No credential is matching the requested DocType '${docType}'`)\n  }\n\n  if (matchingMdoc.length > 1) {\n    throw new Error(`Cannot limit the disclosure. Multiple credentials are matching the requested DocType '${docType}'`)\n  }\n\n  return matchingMdoc[0]\n}\n\nexport const limitDisclosureToInputDescriptor = (\n  mdoc: IssuerSignedDocument,\n  inputDescriptor: InputDescriptor\n): Record<string, IssuerSignedItem[]> => {\n  const nameSpaces: Record<string, IssuerSignedItem[]> = {}\n\n  for (const field of inputDescriptor.constraints.fields) {\n    const result = prepareDigestForInputDescriptor(field.path, mdoc.issuerSigned.nameSpaces)\n    if (!result) {\n      throw new Error(\n        `Cannot limit the disclosure to the input descriptor. No matching field found for '${field.path.join('.')}'`\n      )\n    }\n\n    const { nameSpace, digest } = result\n    if (!nameSpaces[nameSpace]) nameSpaces[nameSpace] = []\n    nameSpaces[nameSpace].push(digest)\n  }\n\n  return nameSpaces\n}\n","import type { JWK } from 'jose'\nimport type { MdocContext } from '../../c-mdoc.js'\nimport { DataItem, cborEncode } from '../../cbor/index.js'\nimport {\n  Algorithms,\n  Headers,\n  MacAlgorithms,\n  MacProtectedHeaders,\n  ProtectedHeaders,\n  UnprotectedHeaders,\n} from '../../cose/headers.js'\nimport { COSEKey, COSEKeyToRAW } from '../../cose/key/cose-key.js'\nimport { Mac0 } from '../../cose/mac0.js'\nimport { Sign1 } from '../../cose/sign1.js'\nimport { stringToUint8Array } from '../../u-uint8-array.js'\nimport type { IssuerSignedItem } from '../issuer-signed-item.js'\nimport { parseDeviceResponse } from '../parser.js'\nimport { calculateDeviceAutenticationBytes } from '../utils.js'\nimport type { DeviceRequest, DocRequest } from './device-request.js'\nimport { DeviceSignedDocument } from './device-signed-document.js'\nimport type { IssuerSignedDocument } from './issuer-signed-document.js'\nimport { MDoc } from './mdoc.js'\nimport {\n  findMdocMatchingDocType,\n  limitDisclosureToDeviceRequestNameSpaces,\n  limitDisclosureToInputDescriptor,\n} from './pex-limit-disclosure.js'\nimport type { InputDescriptor, PresentationDefinition } from './presentation-definition.js'\nimport type { DeviceAuth, DeviceSigned, MacSupportedAlgs, SupportedAlgs } from './types.js'\n\n/**\n * A builder class for creating a device response.\n */\nexport class DeviceResponse {\n  private mdoc: MDoc\n  private pd?: PresentationDefinition\n  private deviceRequest?: DeviceRequest\n  private sessionTranscriptBytes?: Uint8Array\n  private useMac = true\n  private devicePrivateKey?: JWK\n  public nameSpaces: Record<string, Record<string, unknown>> = {}\n  private alg?: SupportedAlgs\n  private macAlg?: MacSupportedAlgs\n  private ephemeralPublicKey?: JWK\n\n  /**\n   * Create a DeviceResponse builder.\n   *\n   * @param {MDoc | Uint8Array} mdoc - The mdoc to use as a base for the device response.\n   *                                   It can be either a parsed MDoc or a CBOR encoded MDoc.\n   * @returns {DeviceResponse} - A DeviceResponse builder.\n   */\n  public static from(mdoc: MDoc | Uint8Array): DeviceResponse {\n    if (mdoc instanceof Uint8Array) {\n      return new DeviceResponse(parseDeviceResponse(mdoc))\n    }\n    return new DeviceResponse(mdoc)\n  }\n\n  constructor(mdoc: MDoc) {\n    this.mdoc = mdoc\n  }\n\n  /**\n   *\n   * @param pd - The presentation definition to use for the device response.\n   * @returns {DeviceResponse}\n   */\n  public usingPresentationDefinition(pd: PresentationDefinition): DeviceResponse {\n    if (!pd.input_descriptors.length) {\n      throw new Error('The Presentation Definition must have at least one Input Descriptor object.')\n    }\n\n    const hasDuplicates = pd.input_descriptors.some(\n      (id1, idx) => pd.input_descriptors.findIndex((id2) => id2.id === id1.id) !== idx\n    )\n    if (hasDuplicates) {\n      throw new Error('Each Input Descriptor object must have a unique id property.')\n    }\n\n    this.pd = pd\n    return this\n  }\n\n  /**\n   *\n   * @param deviceRequest - The device request\n   * @returns {DeviceResponse}\n   */\n  public usingDeviceRequest(deviceRequest: DeviceRequest): DeviceResponse {\n    if (!deviceRequest.docRequests.length) {\n      throw new Error('The deviceRequest must have at least one docRequest object.')\n    }\n\n    this.deviceRequest = deviceRequest\n    return this\n  }\n\n  /**\n   * Set the session transcript data to use for the device response.\n   *\n   * This is arbitrary and should match the session transcript as it will be calculated by the verifier.\n   * The transcript must be a CBOR encoded DataItem of an array, there is no further requirement.\n   *\n   * Example: `usingSessionTranscriptBytes(cborEncode(DataItem.fromData([a,b,c])))` where `a`, `b` and `c` can be anything including `null`.\n   *\n   * It is preferable to use {@link usingSessionTranscriptForOID4VP} or {@link usingSessionTranscriptForWebAPI} when possible.\n   *\n   * @param {Uint8Array} sessionTranscriptBytes - The sessionTranscriptBytes data to use in the session transcript.\n   * @returns {DeviceResponse}\n   */\n  public usingSessionTranscriptBytes(sessionTranscriptBytes: Uint8Array): DeviceResponse {\n    if (this.sessionTranscriptBytes) {\n      throw new Error(\n        'A session transcript has already been set, either with .usingSessionTranscriptForOID4VP, .usingSessionTranscriptForWebAPI or .usingSessionTranscriptBytes'\n      )\n    }\n    this.sessionTranscriptBytes = sessionTranscriptBytes\n    return this\n  }\n\n  /**\n   * Set the session transcript data to use for the device response as defined in ISO/IEC 18013-7 in Annex B (OID4VP), 2023 draft.\n   *\n   * This should match the session transcript as it will be calculated by the verifier.\n   *\n   * @param {string} mdocGeneratedNonce - A cryptographically random number with sufficient entropy.\n   * @param {string} clientId - The client_id Authorization Request parameter from the Authorization Request Object.\n   * @param {string} responseUri - The response_uri Authorization Request parameter from the Authorization Request Object.\n   * @param {string} verifierGeneratedNonce - The nonce Authorization Request parameter from the Authorization Request Object.\n   * @returns {DeviceResponse}\n   */\n  public usingSessionTranscriptForOID4VP(input: {\n    mdocGeneratedNonce: string\n    clientId: string\n    responseUri: string\n    verifierGeneratedNonce: string\n  }): DeviceResponse {\n    const bytes = DeviceResponse.calculateSessionTranscriptForOID4VP(input)\n    this.usingSessionTranscriptBytes(bytes)\n    return this\n  }\n\n  public static calculateSessionTranscriptForOID4VP(input: {\n    mdocGeneratedNonce: string\n    clientId: string\n    responseUri: string\n    verifierGeneratedNonce: string\n  }) {\n    const { mdocGeneratedNonce, clientId, responseUri, verifierGeneratedNonce } = input\n\n    return cborEncode(\n      DataItem.fromData([\n        null, // deviceEngagementBytes\n        null, // eReaderKeyBytes\n        [mdocGeneratedNonce, clientId, responseUri, verifierGeneratedNonce],\n      ])\n    )\n  }\n\n  /**\n   * Set the session transcript data to use for the device response as defined in ISO/IEC 18013-7 in Annex A (Web API), 2023 draft.\n   *\n   * This should match the session transcript as it will be calculated by the verifier.\n   *\n   * @param {Uint8Array} deviceEngagementBytes - The device engagement, encoded as a Tagged 24 cbor\n   * @param {Uint8Array} readerEngagementBytes - The reader engagement, encoded as a Tagged 24 cbor\n   * @param {Uint8Array} eReaderKeyBytes - The reader ephemeral public key as a COSE Key, encoded as a Tagged 24 cbor\n   * @returns {DeviceResponse}\n   */\n  public usingSessionTranscriptForWebAPI(input: {\n    deviceEngagementBytes: Uint8Array\n    readerEngagementBytes: Uint8Array\n    eReaderKeyBytes: Uint8Array\n  }): DeviceResponse {\n    const bytes = DeviceResponse.calculateSessionTranscriptForWebApi(input)\n    this.usingSessionTranscriptBytes(bytes)\n    return this\n  }\n\n  public static calculateSessionTranscriptForWebApi(input: {\n    deviceEngagementBytes: Uint8Array\n    readerEngagementBytes: Uint8Array\n    eReaderKeyBytes: Uint8Array\n  }) {\n    const { deviceEngagementBytes, eReaderKeyBytes, readerEngagementBytes } = input\n\n    return cborEncode(\n      DataItem.fromData([\n        new DataItem({ buffer: deviceEngagementBytes }),\n        new DataItem({ buffer: eReaderKeyBytes }),\n        readerEngagementBytes,\n      ])\n    )\n  }\n\n  /**\n   * Add a namespace to the device response.\n   *\n   * @param {string} nameSpace - The name space to add to the device response.\n   * @param {Record<string, any>} data - The data to add to the name space.\n   * @returns {DeviceResponse}\n   */\n  public addDeviceNameSpace(nameSpace: string, data: Record<string, unknown>): DeviceResponse {\n    this.nameSpaces[nameSpace] = data\n    return this\n  }\n\n  /**\n   * Set the device's private key to be used for signing the device response.\n   *\n   * @param  {JWK} devicePrivateKey - The device's private key either as a JWK or a COSEKey.\n   * @param  {SupportedAlgs} alg - The algorithm to use for signing the device response.\n   * @returns {DeviceResponse}\n   */\n  public authenticateWithSignature(devicePrivateKey: JWK, alg: SupportedAlgs): DeviceResponse {\n    this.devicePrivateKey = devicePrivateKey\n    this.alg = alg\n    this.useMac = false\n    return this\n  }\n\n  /**\n   * Set the reader shared key to be used for signing the device response with MAC.\n   *\n   * @param  {JWK} devicePrivateKey - The device's private key either as a JWK or a COSEKey.\n   * @param  {JWK} ephemeralPublicKey - The public part of the ephemeral key generated by the MDOC.\n   * @param  {SupportedAlgs} alg - The algorithm to use for signing the device response.\n   * @returns {DeviceResponse}\n   */\n  public authenticateWithMAC(devicePrivateKey: JWK, ephemeralPublicKey: JWK, alg: MacSupportedAlgs): DeviceResponse {\n    this.devicePrivateKey = devicePrivateKey\n    this.ephemeralPublicKey = ephemeralPublicKey\n    this.macAlg = alg\n    this.useMac = true\n    return this\n  }\n\n  /**\n   * Sign the device response and return the MDoc.\n   *\n   * @returns {Promise<MDoc>} - The device response as an MDoc.\n   */\n  public async sign(ctx: {\n    crypto: MdocContext['crypto']\n    cose: MdocContext['cose']\n  }): Promise<MDoc> {\n    const requests = this.pd?.input_descriptors ?? this.deviceRequest?.docRequests\n    if (!requests) {\n      throw new Error(\n        'Must provide a presentation definition or device request with .usingPresentationDefinition() or .usingDeviceRequest()'\n      )\n    }\n\n    if (!this.sessionTranscriptBytes) {\n      throw new Error(\n        'Must provide the session transcript with either .usingSessionTranscriptForOID4VP, .usingSessionTranscriptForWebAPI or .usingSessionTranscriptBytes'\n      )\n    }\n\n    const limitedDeviceSignedDocuments = await Promise.all(\n      requests.map(async (request) => {\n        const isDeviceRequest = (r: InputDescriptor | DocRequest): r is DocRequest => 'itemsRequest' in request\n\n        let mdoc: IssuerSignedDocument\n        let disclosedNameSpaces: Record<string, IssuerSignedItem[]>\n        if (isDeviceRequest(request)) {\n          const docType = request.itemsRequest.data.docType\n          mdoc = findMdocMatchingDocType(this.mdoc, docType)\n          disclosedNameSpaces = limitDisclosureToDeviceRequestNameSpaces(mdoc, request.itemsRequest.data.nameSpaces)\n        } else {\n          mdoc = findMdocMatchingDocType(this.mdoc, request.id)\n          disclosedNameSpaces = limitDisclosureToInputDescriptor(mdoc, request)\n        }\n\n        return new DeviceSignedDocument(\n          mdoc.docType,\n          {\n            nameSpaces: disclosedNameSpaces,\n            issuerAuth: mdoc.issuerSigned.issuerAuth,\n          },\n          await this.getDeviceSigned(mdoc.docType, ctx)\n        )\n      })\n    )\n\n    return new MDoc(limitedDeviceSignedDocuments)\n  }\n\n  private async getDeviceSigned(\n    docType: string,\n    ctx: {\n      cose: MdocContext['cose']\n      crypto: MdocContext['crypto']\n    }\n  ): Promise<DeviceSigned> {\n    const deviceAuthenticationBytes = calculateDeviceAutenticationBytes(\n      this.sessionTranscriptBytes,\n      docType,\n      this.nameSpaces\n    )\n\n    let deviceAuth: DeviceAuth\n    if (this.useMac) {\n      if (!this.sessionTranscriptBytes) {\n        throw new Error('Missing sessionTranscriptBytes for getDeviceSigned')\n      }\n\n      deviceAuth = await this.getDeviceAuthMac(deviceAuthenticationBytes, this.sessionTranscriptBytes, ctx)\n    } else {\n      deviceAuth = await this.getDeviceAuthSign(deviceAuthenticationBytes, ctx)\n    }\n\n    const deviceSigned: DeviceSigned = {\n      nameSpaces: this.nameSpaces,\n      deviceAuth,\n    }\n\n    return deviceSigned\n  }\n\n  private async getDeviceAuthMac(\n    deviceAuthenticationBytes: Uint8Array,\n    sessionTranscriptBytes: Uint8Array,\n    ctx: {\n      cose: Pick<MdocContext['cose'], 'mac0'>\n      crypto: MdocContext['crypto']\n    }\n  ): Promise<DeviceAuth> {\n    if (!this.devicePrivateKey) {\n      throw new Error('Missing devicePrivateKey for getDeviceAuthMac')\n    }\n\n    if (!this.ephemeralPublicKey) {\n      throw new Error('Missing ephemeralPublicKey for getDeviceAuthMac')\n    }\n\n    const { kid } = this.devicePrivateKey\n    const ephemeralMacKeyJwk = await ctx.crypto.calculateEphemeralMacKeyJwk({\n      privateKey: COSEKeyToRAW(COSEKey.fromJWK(this.devicePrivateKey).encode()),\n      publicKey: COSEKeyToRAW(COSEKey.fromJWK(this.ephemeralPublicKey).encode()),\n\n      sessionTranscriptBytes: sessionTranscriptBytes,\n    })\n\n    if (!this.macAlg) throw new Error('Missing macAlg')\n\n    const protectedHeaders = MacProtectedHeaders.from([[Headers.Algorithm, MacAlgorithms[this.macAlg]]])\n\n    const unprotectedHeaders = kid ? UnprotectedHeaders.from([[Headers.KeyID, stringToUint8Array(kid)]]) : undefined\n\n    const mac0 = Mac0.create(protectedHeaders, unprotectedHeaders, deviceAuthenticationBytes, undefined)\n\n    const tag = await ctx.cose.mac0.sign({ mac0, jwk: ephemeralMacKeyJwk })\n    mac0.tag = tag\n    return { deviceMac: mac0 }\n  }\n\n  private async getDeviceAuthSign(\n    cborData: Uint8Array,\n    ctx: {\n      crypto: MdocContext['crypto']\n      cose: MdocContext['cose']\n    }\n  ): Promise<DeviceAuth> {\n    if (!this.devicePrivateKey) throw new Error('Missing devicePrivateKey')\n\n    if (!this.alg) {\n      throw new Error('The alg header must be set.')\n    }\n\n    const { kid } = this.devicePrivateKey\n    const unprotectedHeaders = kid ? UnprotectedHeaders.from([[Headers.KeyID, stringToUint8Array(kid)]]) : undefined\n\n    const sign1 = Sign1.create(\n      ProtectedHeaders.from([[Headers.Algorithm, Algorithms[this.alg]]]),\n      unprotectedHeaders,\n      cborData\n    )\n\n    const signature = await ctx.cose.sign1.sign({\n      sign1,\n      jwk: this.devicePrivateKey,\n    })\n    sign1.signature = signature\n\n    return { deviceSignature: sign1 }\n  }\n}\n","import type { JWK } from 'jose'\nimport type { MdocContext } from '../../c-mdoc.js'\nimport { DataItem, DateOnly, cborDecode, cborEncode } from '../../cbor/index.js'\nimport { Algorithms, Headers, ProtectedHeaders, UnprotectedHeaders } from '../../cose/headers.js'\nimport { COSEKey } from '../../cose/key/cose-key.js'\nimport { stringToUint8Array } from '../../u-uint8-array.js'\nimport { IssuerSignedItem } from '../issuer-signed-item.js'\nimport { fromPEM } from '../utils.js'\nimport IssuerAuth from './issuer-auth.js'\nimport { IssuerSignedDocument } from './issuer-signed-document.js'\nimport type {\n  DeviceKeyInfo,\n  DigestAlgorithm,\n  DocType,\n  IssuerNameSpaces,\n  MSO,\n  SupportedAlgs,\n  ValidityInfo,\n} from './types.js'\nfunction isObjectLike(value: unknown) {\n  return typeof value === 'object' && value !== null\n}\n\nexport default function isObject(input: unknown): input is Record<string, unknown> {\n  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n    return false\n  }\n  if (Object.getPrototypeOf(input) === null) {\n    return true\n  }\n  let proto = input\n  while (Object.getPrototypeOf(proto) !== null) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    proto = Object.getPrototypeOf(proto)\n  }\n  return Object.getPrototypeOf(input) === proto\n}\n\nconst DEFAULT_NS = 'org.iso.18013.5.1'\n\nconst getAgeInYears = (birth: string): number => {\n  const birthDate = new Date(birth)\n  birthDate.setHours(0, 0, 0, 0)\n  // @ts-expect-error this works\n  const ageDifMs = Date.now() - birthDate\n  const ageDate = new Date(ageDifMs)\n  return Math.abs(ageDate.getUTCFullYear() - 1970)\n}\n\nconst addYears = (date: Date, years: number): Date => {\n  const r = new Date(date.getTime())\n  r.setFullYear(date.getFullYear() + years)\n  return r\n}\n\n/**\n * Use this class when building new documents.\n *\n * This class allow you to build a document and sign it with the issuer's private key.\n */\nexport class Document {\n  readonly docType: DocType\n  #issuerNameSpaces: IssuerNameSpaces = {}\n  #deviceKeyInfo?: DeviceKeyInfo\n  #validityInfo: ValidityInfo = {\n    signed: new Date(),\n    validFrom: new Date(),\n    validUntil: addYears(new Date(), 1),\n    expectedUpdate: undefined,\n  }\n  #digestAlgorithm: DigestAlgorithm = 'SHA-256'\n  ctx: { crypto: MdocContext['crypto'] }\n\n  constructor(doc: DocType, ctx: { crypto: MdocContext['crypto'] }) {\n    this.docType = doc\n    this.ctx = ctx\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private validateValues(values: Record<string, unknown>) {\n    // TODO\n    // validate required fields, no extra fields, data types, etc...\n  }\n\n  /**\n   * Add a namespace to an unsigned document.\n   *\n   * @param {string} namespace - The namespace to add.\n   * @param {Record<string, any>} values - The values to add to the namespace.\n   * @returns {Document} - The document\n   */\n  addIssuerNameSpace(namespace: 'org.iso.18013.5.1' | (string & {}), values: Record<string, unknown>): Document {\n    if (namespace === DEFAULT_NS) {\n      this.validateValues(values)\n    }\n\n    const namespaceRecord = this.#issuerNameSpaces[namespace] ?? []\n\n    const addAttribute = (key: string, value: unknown) => {\n      let elementValue = value\n      if (namespace === DEFAULT_NS) {\n        // the following namespace attributes must be a full-date as specified in RFC 3339\n        if (['birth_date', 'issue_date', 'expiry_date'].includes(key) && typeof elementValue === 'string') {\n          elementValue = new DateOnly(elementValue)\n        }\n\n        if (key === 'driving_privileges' && Array.isArray(elementValue)) {\n          elementValue.forEach((v, i) => {\n            if (isObject(v) && typeof v.issue_date === 'string') {\n              // @ts-expect-error this works\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              elementValue[i].issue_date = new DateOnly(v.issue_date)\n            }\n            if (isObject(v) && typeof v.expiry_date === 'string') {\n              // @ts-expect-error this works\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              elementValue[i].expiry_date = new DateOnly(v.expiry_date)\n            }\n          })\n        }\n      }\n\n      const digestID = namespaceRecord.length\n      const issuerSignedItem = IssuerSignedItem.create(digestID, key, value, this.ctx)\n      namespaceRecord.push(issuerSignedItem)\n    }\n\n    for (const [key, value] of Object.entries(values)) {\n      addAttribute(key, value)\n      if (this.docType === 'org.iso.18013.5.1.mDL' && key === 'birth_date') {\n        if (typeof value !== 'string') {\n          throw new Error(`Invalid type for 'birth_date'. Expected 'string', received '${typeof value}'`)\n        }\n        const ageInYears = getAgeInYears(value)\n        addAttribute('age_over_21', ageInYears >= 21)\n        addAttribute(`age_over_${Math.floor(ageInYears)}`, true)\n      }\n    }\n\n    this.#issuerNameSpaces[namespace] = namespaceRecord\n\n    return this\n  }\n\n  /**\n   * Get the values in a namespace.\n   *\n   * @param {string} namespace - The namespace to add.\n   * @returns {Record<string, any>} - The values in the namespace as an object\n   */\n  getIssuerNameSpace(namespace: string): Record<string, unknown> | undefined {\n    const nameSpace = this.#issuerNameSpaces[namespace]\n    if (!nameSpace) return undefined\n    return Object.fromEntries(nameSpace.map((item) => [item.elementIdentifier, item.elementValue]))\n  }\n\n  /**\n   * Add the device public key which will be include in the issuer signature.\n   * The device public key could be in JWK format or as COSE_Key format.\n   *\n   * @param params\n   * @param {JWK | Uint8Array} params.devicePublicKey - The device public key.\n   */\n  addDeviceKeyInfo({ deviceKey }: { deviceKey: JWK | Uint8Array }): Document {\n    const deviceKeyCOSEKey = deviceKey instanceof Uint8Array ? deviceKey : COSEKey.fromJWK(deviceKey).encode()\n    const decodedCoseKey = cborDecode(deviceKeyCOSEKey)\n\n    this.#deviceKeyInfo = {\n      deviceKey: decodedCoseKey,\n    }\n\n    return this\n  }\n\n  /**\n   * Add validity info to the document that will be used in the issuer signature.\n   *\n   * @param info - the validity info\n   * @param {Date} [info.signed] - The date the document is signed. default: now\n   * @param {Date} [info.validFrom] - The date the document is valid from. default: signed\n   * @param {Date} [info.validUntil] - The date the document is valid until. default: signed + 1 year\n   * @param {Date} [info.expectedUpdate] - The date the document is expected to be updated. default: null\n   * @returns\n   */\n  addValidityInfo(info: Partial<ValidityInfo> = {}): Document {\n    const signed = info.signed ?? new Date()\n    const validFrom = info.validFrom ?? signed\n    const validUntil = info.validUntil ?? addYears(signed, 1)\n    this.#validityInfo = {\n      signed,\n      validFrom,\n      validUntil,\n      expectedUpdate: info.expectedUpdate,\n    }\n    return this\n  }\n\n  /**\n   * Set the digest algorithm used for the value digests in the issuer signature.\n   *\n   * The default is SHA-256.\n   *\n   * @param {DigestAlgorithm} digestAlgorithm - The digest algorithm to use.\n   * @returns\n   */\n  useDigestAlgorithm(digestAlgorithm: DigestAlgorithm): Document {\n    this.#digestAlgorithm = digestAlgorithm\n    return this\n  }\n\n  /**\n   * Generate the issuer signature for the document.\n   *\n   * @param {Object} params - The parameters object\n   * @param {JWK | Uint8Array} params.issuerPrivateKey - The issuer's private key either in JWK format or COSE_KEY format as buffer.\n   * @param {string | Uint8Array} params.issuerCertificate - The issuer's certificate in pem format or as a buffer.\n   * @param {SupportedAlgs} params.alg - The algorhitm used for the MSO signature.\n   * @param {string | Uint8Array} [params.kid] - The key id of the issuer's private key. default: issuerPrivateKey.kid\n   * @returns {Promise<IssuerSignedDoc>} - The signed document\n   */\n  async sign(\n    params: {\n      issuerPrivateKey: JWK\n      issuerCertificate: string | Uint8Array\n      alg: SupportedAlgs\n      kid?: string | Uint8Array\n    },\n    ctx: {\n      crypto: MdocContext['crypto']\n      cose: MdocContext['cose']\n    }\n  ): Promise<IssuerSignedDocument> {\n    if (!this.#issuerNameSpaces) {\n      throw new Error('No namespaces added')\n    }\n\n    const issuerPublicKeyBuffer =\n      typeof params.issuerCertificate === 'string' ? fromPEM(params.issuerCertificate) : params.issuerCertificate\n\n    const issuerPrivateKeyJWK =\n      params.issuerPrivateKey instanceof Uint8Array\n        ? COSEKey.import(params.issuerPrivateKey).toJWK()\n        : params.issuerPrivateKey\n\n    const valueDigests = new Map(\n      await Promise.all(\n        Object.entries(this.#issuerNameSpaces).map(async ([namespace, items]) => {\n          const digestMap = new Map<number, Uint8Array>()\n          await Promise.all(\n            items.map(async (item, index) => {\n              const hash = await item.calculateDigest(this.#digestAlgorithm, ctx)\n              digestMap.set(index, new Uint8Array(hash))\n            })\n          )\n          return [namespace, digestMap] as [string, Map<number, Uint8Array>]\n        })\n      )\n    )\n\n    const mso: MSO = {\n      version: '1.0',\n      digestAlgorithm: this.#digestAlgorithm,\n      valueDigests,\n      deviceKeyInfo: this.#deviceKeyInfo,\n      docType: this.docType,\n      validityInfo: this.#validityInfo,\n    }\n\n    const payload = cborEncode(DataItem.fromData(mso))\n    const protectedHeader: ProtectedHeaders = ProtectedHeaders.from([[Headers.Algorithm, Algorithms[params.alg]]])\n\n    const _kid = params.kid ?? issuerPrivateKeyJWK.kid\n    const kid = typeof _kid === 'string' ? stringToUint8Array(_kid) : _kid\n    const headers: ConstructorParameters<typeof UnprotectedHeaders>[0] = kid\n      ? [\n          [Headers.KeyID, kid],\n          [Headers.X5Chain, [issuerPublicKeyBuffer]],\n        ]\n      : [[Headers.X5Chain, [issuerPublicKeyBuffer]]]\n\n    const unprotectedHeader = UnprotectedHeaders.from(headers)\n\n    const issuerAuth = IssuerAuth.create(protectedHeader, unprotectedHeader, payload)\n\n    const signature = await ctx.cose.sign1.sign({\n      sign1: issuerAuth,\n      jwk: issuerPrivateKeyJWK,\n    })\n    issuerAuth.signature = signature\n\n    const issuerSigned = {\n      issuerAuth,\n      nameSpaces: this.#issuerNameSpaces,\n    }\n\n    return new IssuerSignedDocument(this.docType, issuerSigned)\n  }\n}\n","import { compareVersions } from 'compare-versions'\nimport type { MDoc } from './model/mdoc.js'\n\nimport { calculateDeviceAutenticationBytes } from './utils.js'\n\nimport type { VerificationAssessment, VerificationCallback } from './check-callback.js'\nimport { defaultCallback, onCatCheck } from './check-callback.js'\n\nimport type { JWK } from 'jose'\nimport type { MdocContext, X509Context } from '../c-mdoc.js'\nimport { COSEKey, COSEKeyToRAW } from '../cose/key/cose-key.js'\nimport { Sign1 } from '../cose/sign1.js'\nimport { MDL_NAMESPACE } from './issuer-signed-item.js'\nimport { DeviceSignedDocument } from './model/device-signed-document.js'\nimport type IssuerAuth from './model/issuer-auth.js'\nimport type { IssuerSignedDocument } from './model/issuer-signed-document.js'\nimport type { DiagnosticInformation } from './model/types.js'\nimport { parseDeviceResponse } from './parser.js'\n\nconst DIGEST_ALGS = {\n  'SHA-256': 'sha256',\n  'SHA-384': 'sha384',\n  'SHA-512': 'sha512',\n} as Record<string, string>\n\nexport class Verifier {\n  /**\n   *\n   * @param input.trustedCertificates The IACA root certificates list of the supported issuers.\n   */\n  public async verifyIssuerSignature(\n    input: {\n      trustedCertificates: Uint8Array[]\n      issuerAuth: IssuerAuth\n      now?: Date\n      disableCertificateChainValidation: boolean\n      onCheckG?: VerificationCallback\n    },\n    ctx: { x509: X509Context; cose: MdocContext['cose'] }\n  ) {\n    const { issuerAuth, disableCertificateChainValidation, onCheckG } = input\n    const onCheck = onCatCheck(onCheckG ?? defaultCallback, 'ISSUER_AUTH')\n    const { certificateChain } = issuerAuth\n    const countryName = issuerAuth.getIssuingCountry(ctx)\n\n    if (!certificateChain) {\n      onCheck({\n        status: 'FAILED',\n        check: 'Missing x509 certificate in issuerAuth',\n      })\n\n      return\n    }\n\n    if (!issuerAuth.algName) {\n      onCheck({\n        status: 'FAILED',\n        check: 'IssuerAuth must have an alg property',\n      })\n\n      return\n    }\n\n    if (!disableCertificateChainValidation) {\n      const trustedCertificates = input.trustedCertificates\n      try {\n        if (!trustedCertificates[0]) {\n          throw new Error('No trusted certificates found. Cannot verify issuer signature.')\n        }\n        await ctx.x509.validateCertificateChain({\n          trustedCertificates: trustedCertificates as [Uint8Array, ...Uint8Array[]],\n          x5chain: certificateChain,\n        })\n        onCheck({\n          status: 'PASSED',\n          check: 'Issuer certificate must be valid',\n        })\n      } catch (err) {\n        onCheck({\n          status: 'FAILED',\n          check: 'Issuer certificate must be valid',\n          reason: err instanceof Error ? err.message : 'Unknown error',\n        })\n      }\n    }\n\n    const verificationJwk = await ctx.x509.getPublicKey({\n      certificate: issuerAuth.certificate,\n      alg: issuerAuth.algName,\n    })\n\n    const verificationResult = await ctx.cose.sign1.verify({\n      sign1: issuerAuth,\n      jwk: verificationJwk,\n    })\n\n    onCheck({\n      status: verificationResult ? 'PASSED' : 'FAILED',\n      check: 'Issuer signature must be valid',\n    })\n\n    // Validity\n    const { validityInfo } = issuerAuth.decodedPayload\n    const now = input.now ?? new Date()\n\n    const certificateData = await ctx.x509.getCertificateData({\n      certificate: issuerAuth.certificate,\n    })\n\n    onCheck({\n      status:\n        validityInfo.signed < certificateData.notBefore || validityInfo.signed > certificateData.notAfter\n          ? 'FAILED'\n          : 'PASSED',\n      check: 'The MSO signed date must be within the validity period of the certificate',\n      reason: `The MSO signed date (${validityInfo.signed.toUTCString()}) must be within the validity period of the certificate (${certificateData.notBefore.toUTCString()} to ${certificateData.notAfter.toUTCString()})`,\n    })\n\n    onCheck({\n      status: now < validityInfo.validFrom || now > validityInfo.validUntil ? 'FAILED' : 'PASSED',\n      check: 'The MSO must be valid at the time of verification',\n      reason: `The MSO must be valid at the time of verification (${now.toUTCString()})`,\n    })\n\n    onCheck({\n      status: countryName ? 'PASSED' : 'FAILED',\n      check: \"Country name (C) must be present in the issuer certificate's subject distinguished name\",\n    })\n  }\n\n  public async verifyDeviceSignature(\n    input: {\n      deviceSigned: DeviceSignedDocument\n      ephemeralPrivateKey?: JWK | Uint8Array\n      sessionTranscriptBytes?: Uint8Array\n      onCheckG?: VerificationCallback\n    },\n    ctx: {\n      crypto: MdocContext['crypto']\n      cose: MdocContext['cose']\n    }\n  ) {\n    const { deviceSigned, sessionTranscriptBytes, ephemeralPrivateKey } = input\n    const onCheck = onCatCheck(input.onCheckG ?? defaultCallback, 'DEVICE_AUTH')\n\n    const { deviceAuth, nameSpaces } = deviceSigned.deviceSigned\n    const { docType } = deviceSigned\n    const { deviceKeyInfo } = deviceSigned.issuerSigned.issuerAuth.decodedPayload\n    const { deviceKey: deviceKeyCoseKey } = deviceKeyInfo ?? {}\n\n    // Prevent cloning of the mdoc and mitigate man in the middle attacks\n    if (!deviceAuth.deviceMac && !deviceAuth.deviceSignature) {\n      onCheck({\n        status: 'FAILED',\n        check: 'Device Auth must contain a deviceSignature or deviceMac element',\n      })\n      return\n    }\n\n    if (!sessionTranscriptBytes) {\n      onCheck({\n        status: 'FAILED',\n        check: 'Session Transcript Bytes missing from options, aborting device signature check',\n      })\n      return\n    }\n\n    const deviceAuthenticationBytes = calculateDeviceAutenticationBytes(sessionTranscriptBytes, docType, nameSpaces)\n\n    if (!deviceKeyCoseKey) {\n      onCheck({\n        status: 'FAILED',\n        check: 'Issuer signature must contain the device key.',\n        reason: 'Unable to verify deviceAuth signature: missing device key in issuerAuth',\n      })\n      return\n    }\n\n    if (deviceAuth.deviceSignature) {\n      const deviceKey = COSEKey.import(deviceKeyCoseKey)\n\n      // ECDSA/EdDSA authentication\n      try {\n        const ds = deviceAuth.deviceSignature\n\n        const sign1 = new Sign1(ds.protectedHeaders, ds.unprotectedHeaders, deviceAuthenticationBytes, ds.signature)\n\n        const jwk = deviceKey.toJWK()\n        const verificationResult = await ctx.cose.sign1.verify({ sign1, jwk })\n\n        onCheck({\n          status: verificationResult ? 'PASSED' : 'FAILED',\n          check: 'Device signature must be valid',\n        })\n      } catch (err) {\n        onCheck({\n          status: 'FAILED',\n          check: 'Device signature must be valid',\n          reason: `Unable to verify deviceAuth signature (ECDSA/EdDSA): ${err instanceof Error ? err.message : 'Unknown error'}`,\n        })\n      }\n      return\n    }\n\n    // MAC authentication\n    onCheck({\n      status: deviceAuth.deviceMac ? 'PASSED' : 'FAILED',\n      check: 'Device MAC must be present when using MAC authentication',\n    })\n    if (!deviceAuth.deviceMac) {\n      return\n    }\n\n    onCheck({\n      status: deviceAuth.deviceMac.hasSupportedAlg() ? 'PASSED' : 'FAILED',\n      check: 'Device MAC must use alg 5 (HMAC 256/256)',\n    })\n    if (!deviceAuth.deviceMac.hasSupportedAlg()) {\n      return\n    }\n\n    onCheck({\n      status: ephemeralPrivateKey ? 'PASSED' : 'FAILED',\n      check: 'Ephemeral private key must be present when using MAC authentication',\n    })\n    if (!ephemeralPrivateKey) {\n      return\n    }\n\n    try {\n      const deviceKeyRaw = COSEKeyToRAW(deviceKeyCoseKey)\n      const ephemeralMacKeyJwk = await ctx.crypto.calculateEphemeralMacKeyJwk({\n        privateKey:\n          ephemeralPrivateKey instanceof Uint8Array\n            ? ephemeralPrivateKey\n            : COSEKeyToRAW(COSEKey.fromJWK(ephemeralPrivateKey).encode()),\n        publicKey: deviceKeyRaw,\n        sessionTranscriptBytes: sessionTranscriptBytes,\n      })\n\n      const isValid = await ctx.cose.mac0.verify({\n        mac0: deviceAuth.deviceMac,\n        jwk: ephemeralMacKeyJwk,\n        options: { detachedPayload: deviceAuthenticationBytes },\n      })\n\n      onCheck({\n        status: isValid ? 'PASSED' : 'FAILED',\n        check: 'Device MAC must be valid',\n      })\n    } catch (err) {\n      onCheck({\n        status: 'FAILED',\n        check: 'Device MAC must be valid',\n        reason: `Unable to verify deviceAuth MAC: ${err instanceof Error ? err.message : 'Unknown error'}`,\n      })\n    }\n  }\n\n  public async verifyData(\n    input: {\n      mdoc: IssuerSignedDocument\n      onCheckG?: VerificationCallback\n    },\n    ctx: { x509: X509Context; crypto: MdocContext['crypto'] }\n  ) {\n    const { mdoc, onCheckG } = input\n    // Confirm that the mdoc data has not changed since issuance\n    const { issuerAuth } = mdoc.issuerSigned\n    const { valueDigests, digestAlgorithm } = issuerAuth.decodedPayload\n\n    const onCheck = onCatCheck(onCheckG ?? defaultCallback, 'DATA_INTEGRITY')\n\n    onCheck({\n      status: digestAlgorithm && DIGEST_ALGS[digestAlgorithm] ? 'PASSED' : 'FAILED',\n      check: 'Issuer Auth must include a supported digestAlgorithm element',\n    })\n\n    const nameSpaces = mdoc.issuerSigned.nameSpaces ?? {}\n\n    await Promise.all(\n      Object.entries(nameSpaces).map(async ([ns, nsItems]) => {\n        onCheck({\n          status: valueDigests?.has(ns) ? 'PASSED' : 'FAILED',\n          check: `Issuer Auth must include digests for namespace: ${ns}`,\n        })\n\n        const verifications = await Promise.all(\n          nsItems.map(async (ev) => {\n            const isValid = await ev.isValid(ns, issuerAuth, ctx)\n            return { ev, ns, isValid }\n          })\n        )\n\n        verifications\n          .filter((v) => v.isValid)\n          .forEach((v) => {\n            onCheck({\n              status: 'PASSED',\n              check: `The calculated digest for ${ns}/${v.ev.elementIdentifier} attribute must match the digest in the issuerAuth element`,\n            })\n          })\n\n        verifications\n          .filter((v) => !v.isValid)\n          .forEach((v) => {\n            onCheck({\n              status: 'FAILED',\n              check: `The calculated digest for ${ns}/${v.ev.elementIdentifier} attribute must match the digest in the issuerAuth element`,\n            })\n          })\n\n        if (ns === MDL_NAMESPACE) {\n          const certificateData = await ctx.x509.getCertificateData({\n            certificate: issuerAuth.certificate,\n          })\n          if (!certificateData.issuerName) {\n            onCheck({\n              status: 'FAILED',\n              check:\n                \"The 'issuing_country' if present must match the 'countryName' in the subject field within the DS certificate\",\n              reason:\n                \"The 'issuing_country' and 'issuing_jurisdiction' cannot be verified because the DS certificate was not provided\",\n            })\n          } else {\n            const invalidCountry = verifications\n              .filter((v) => v.ns === ns && v.ev.elementIdentifier === 'issuing_country')\n              .find((v) => !v.isValid || !v.ev.matchCertificate(ns, issuerAuth, ctx))\n\n            onCheck({\n              status: invalidCountry ? 'FAILED' : 'PASSED',\n              check:\n                \"The 'issuing_country' if present must match the 'countryName' in the subject field within the DS certificate\",\n              reason: invalidCountry\n                ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                  `The 'issuing_country' (${invalidCountry.ev.elementValue}) must match the 'countryName' (${issuerAuth.getIssuingCountry(ctx)}) in the subject field within the issuer certificate`\n                : undefined,\n            })\n\n            const invalidJurisdiction = verifications\n              .filter((v) => v.ns === ns && v.ev.elementIdentifier === 'issuing_jurisdiction')\n              .find((v) => !v.isValid || !v.ev.matchCertificate(ns, issuerAuth, ctx))\n\n            onCheck({\n              status: invalidJurisdiction ? 'FAILED' : 'PASSED',\n              check:\n                \"The 'issuing_jurisdiction' if present must match the 'stateOrProvinceName' in the subject field within the DS certificate\",\n              reason: invalidJurisdiction\n                ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                  `The 'issuing_jurisdiction' (${invalidJurisdiction.ev.elementValue}) must match the 'stateOrProvinceName' (${issuerAuth.getIssuingStateOrProvince(ctx)}) in the subject field within the issuer certificate`\n                : undefined,\n            })\n          }\n        }\n      })\n    )\n  }\n\n  /**\n   * Parse and validate a DeviceResponse as specified in ISO/IEC 18013-5 (Device Retrieval section).\n   *\n   * @param input.encodedDeviceResponse\n   * @param input.encodedSessionTranscript The CBOR encoded SessionTranscript.\n   * @param input.ephemeralReaderKey The private part of the ephemeral key used in the session where the DeviceResponse was obtained. This is only required if the DeviceResponse is using the MAC method for device authentication.\n   */\n  async verifyDeviceResponse(\n    input: {\n      encodedDeviceResponse: Uint8Array\n      encodedSessionTranscript?: Uint8Array\n      ephemeralReaderKey?: JWK | Uint8Array\n      disableCertificateChainValidation?: boolean\n      trustedCertificates: Uint8Array[]\n      now?: Date\n      onCheck?: VerificationCallback\n    },\n    ctx: {\n      x509: X509Context\n      crypto: MdocContext['crypto']\n      cose: MdocContext['cose']\n    }\n  ): Promise<MDoc> {\n    const { encodedDeviceResponse, now, trustedCertificates } = input\n    const onCheck = input.onCheck ?? defaultCallback\n\n    const dr = parseDeviceResponse(encodedDeviceResponse)\n\n    onCheck({\n      status: dr.version ? 'PASSED' : 'FAILED',\n      check: 'Device Response must include \"version\" element.',\n      category: 'DOCUMENT_FORMAT',\n    })\n\n    onCheck({\n      status: compareVersions(dr.version, '1.0') >= 0 ? 'PASSED' : 'FAILED',\n      check: 'Device Response version must be 1.0 or greater',\n      category: 'DOCUMENT_FORMAT',\n    })\n\n    onCheck({\n      status: dr.documents.length > 0 ? 'PASSED' : 'FAILED',\n      check: 'Device Response must include at least one document.',\n      category: 'DOCUMENT_FORMAT',\n    })\n\n    for (const document of dr.documents) {\n      const { issuerAuth } = document.issuerSigned\n      if (!(document instanceof DeviceSignedDocument)) {\n        onCheck({\n          status: 'FAILED',\n          category: 'DEVICE_AUTH',\n          check: `The document is not signed by the device. ${document.docType}`,\n        })\n        continue\n      }\n\n      await this.verifyIssuerSignature(\n        {\n          issuerAuth,\n          disableCertificateChainValidation: input.disableCertificateChainValidation ?? false,\n          now,\n          onCheckG: onCheck,\n          trustedCertificates,\n        },\n        ctx\n      )\n\n      await this.verifyDeviceSignature(\n        {\n          deviceSigned: document,\n          ephemeralPrivateKey: input.ephemeralReaderKey,\n          sessionTranscriptBytes: input.encodedSessionTranscript,\n          onCheckG: onCheck,\n        },\n        ctx\n      )\n\n      await this.verifyData({ mdoc: document, onCheckG: onCheck }, ctx)\n    }\n\n    return dr\n  }\n\n  async getDiagnosticInformation(\n    encodedDeviceResponse: Uint8Array,\n    options: {\n      trustedCertificates: Uint8Array[]\n      encodedSessionTranscript?: Uint8Array\n      ephemeralReaderKey?: JWK | Uint8Array\n      disableCertificateChainValidation?: boolean\n    },\n    ctx: {\n      x509: X509Context\n      crypto: MdocContext['crypto']\n      cose: MdocContext['cose']\n    }\n  ): Promise<DiagnosticInformation> {\n    const { trustedCertificates } = options\n    const dr: VerificationAssessment[] = []\n    const decoded = await this.verifyDeviceResponse(\n      {\n        encodedDeviceResponse,\n        ...options,\n        onCheck: (check) => dr.push(check),\n        trustedCertificates,\n      },\n      ctx\n    )\n\n    const document = decoded.documents[0]\n    if (!document) {\n      throw new Error('No documents found for getting diagnostic information.')\n    }\n\n    const { issuerAuth } = document.issuerSigned\n    const issuerCert = issuerAuth.certificate\n\n    const attributes = (\n      await Promise.all(\n        Object.keys(document.issuerSigned.nameSpaces).map(async (ns) => {\n          const items = document.issuerSigned.nameSpaces[ns] ?? []\n          return Promise.all(\n            items.map(async (item) => {\n              const isValid = await item.isValid(ns, issuerAuth, ctx)\n              return {\n                ns,\n                id: item.elementIdentifier,\n                value: item.elementValue,\n                isValid,\n                matchCertificate: item.matchCertificate(ns, issuerAuth, ctx),\n              }\n            })\n          )\n        })\n      )\n    ).flat()\n\n    const deviceAttributes =\n      document instanceof DeviceSignedDocument\n        ? Object.entries(document.deviceSigned.nameSpaces).flatMap(([ns, items]) => {\n            return Object.entries(items).map(([id, value]) => {\n              return {\n                ns,\n                id,\n                value,\n              }\n            })\n          })\n        : undefined\n\n    let deviceKey: JWK | undefined = undefined\n\n    if (document.issuerSigned.issuerAuth) {\n      const { deviceKeyInfo } = document.issuerSigned.issuerAuth.decodedPayload\n      if (deviceKeyInfo?.deviceKey) {\n        deviceKey = COSEKey.import(deviceKeyInfo.deviceKey).toJWK()\n      }\n    }\n    const disclosedAttributes = attributes.filter((attr) => attr.isValid).length\n    const totalAttributes = Array.from(\n      document.issuerSigned.issuerAuth.decodedPayload.valueDigests?.entries() ?? []\n    ).reduce((prev, [, digests]) => prev + digests.size, 0)\n\n    return {\n      general: {\n        version: decoded.version,\n        type: 'DeviceResponse',\n        status: decoded.status,\n        documents: decoded.documents.length,\n      },\n      validityInfo: document.issuerSigned.issuerAuth.decodedPayload.validityInfo,\n      issuerCertificate: await ctx.x509.getCertificateData({\n        certificate: issuerCert,\n      }),\n      issuerSignature: {\n        // TODO\n        // biome-ignore lint/style/noNonNullAssertion: <explanation>\n        alg: document.issuerSigned.issuerAuth.algName!,\n        isValid: dr.filter((check) => check.category === 'ISSUER_AUTH').every((check) => check.status === 'PASSED'),\n        reasons: dr\n          .filter((check) => check.category === 'ISSUER_AUTH' && check.status === 'FAILED')\n          .map((check) => check.reason ?? check.check),\n        digests: Object.fromEntries(\n          Array.from(document.issuerSigned.issuerAuth.decodedPayload.valueDigests?.entries() ?? []).map(\n            ([ns, digests]) => [ns, digests.size]\n          )\n        ),\n      },\n      deviceKey: {\n        jwk: deviceKey,\n      },\n      deviceSignature:\n        document instanceof DeviceSignedDocument\n          ? {\n              alg:\n                document.deviceSigned.deviceAuth.deviceSignature?.algName ??\n                document.deviceSigned.deviceAuth.deviceMac?.algName,\n              isValid: dr\n                .filter((check) => check.category === 'DEVICE_AUTH')\n                .every((check) => check.status === 'PASSED'),\n              reasons: dr\n                .filter((check) => check.category === 'DEVICE_AUTH' && check.status === 'FAILED')\n                .map((check) => check.reason ?? check.check),\n            }\n          : undefined,\n      dataIntegrity: {\n        disclosedAttributes: `${disclosedAttributes} of ${totalAttributes}`,\n        isValid: dr.filter((check) => check.category === 'DATA_INTEGRITY').every((check) => check.status === 'PASSED'),\n        reasons: dr\n          .filter((check) => check.category === 'DATA_INTEGRITY' && check.status === 'FAILED')\n          .map((check) => check.reason ?? check.check),\n      },\n      attributes,\n      deviceAttributes,\n      // TODO!!!!\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    } as any\n  }\n}\n","export function uint8ArrayToHex(bytes: Uint8Array): string {\n  return Array.from(bytes)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n}\n\nexport function hexToUint8Array(hexString: string): Uint8Array {\n  const bytes = new Uint8Array(hexString.length / 2)\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = Number.parseInt(hexString.substr(i, 2), 16)\n  }\n\n  return bytes\n}\n"],"mappings":"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","names":["structure","a","b","c","e","f","g","i","j","k","m","read","target","Buffer","position","bundledStrings","referenceMap","packedObjectMap","sharedPackedObjectMap","sharedValues","packedValues","encode","options","maxBytes","isLittleEndianMachine","Buffer","addExtension","addExtension","encode","addExtension","encode","Algorithms","MacAlgorithms","Curve","JWKKeyType","JWKParam","_dataItem","addExtension","addExtension","MDocStatus","encode","digest","isObject","compareVersions","compareVersions"]}