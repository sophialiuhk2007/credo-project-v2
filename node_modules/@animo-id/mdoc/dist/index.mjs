var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/cbor/cbor-x/decode.js
var decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var LEGACY_RECORD_INLINE_ID = 105;
var RECORD_DEFINITIONS_ID = 57342;
var RECORD_INLINE_ID = 57343;
var BUNDLED_STRINGS_ID = 57337;
var PACKED_REFERENCE_TAG_ID = 6;
var STOP_CODE = {};
var maxArraySize = 11281e4;
var maxMapSize = 1681e4;
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var currentExtensionRanges = [];
var packedValues;
var dataView;
var restoreMapsAsObject;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var sequentialMode = false;
var inlineObjectReadThreshold = 2;
try {
  new Function("");
} catch (error) {
  inlineObjectReadThreshold = Number.POSITIVE_INFINITY;
}
var Decoder = class _Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0) options.mapsAsObjects = true;
      if (options.getStructures) options.getShared = options.getStructures;
      if (options.getShared && !options.structures) (options.structures = []).uninitialized = true;
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (const [k, v] of Object.entries(options.keyMap)) this.mapKey.set(v, k);
      }
    }
    Object.assign(this, options);
  }
  /*
  decodeKey(key) {
  	return this.keyMap
  		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
  		: key
  }
  */
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  encodeKey(key) {
    return this.keyMap?.hasOwnProperty(key) ? this.keyMap[key] : key;
  }
  encodeKeys(rec) {
    if (!this._keyMap) return rec;
    const map = /* @__PURE__ */ new Map();
    for (const [k, v] of Object.entries(rec)) map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
    return map;
  }
  decodeKeys(map) {
    if (!this._keyMap || map.constructor.name !== "Map") return map;
    if (!this._mapKey) {
      this._mapKey = /* @__PURE__ */ new Map();
      for (const [k, v] of Object.entries(this._keyMap)) this._mapKey.set(v, k);
    }
    const res = {};
    map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
    return res;
  }
  mapDecode(source, end) {
    const res = this.decode(source);
    if (this._keyMap) {
      switch (res.constructor.name) {
        case "Array":
          return res.map((r) => this.decodeKeys(r));
      }
    }
    return res;
  }
  decode(source, end) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) throw error;
      throw new Error(
        `Source must be a Uint8Array or Buffer but was a ${source && typeof source === "object" ? source.constructor.name : typeof source}`
      );
    }
    if (this instanceof _Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      }
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) currentStructures = [];
      packedValues = null;
    }
    return checkedRead();
  }
  decodeMultiple(source, forEach) {
    let values;
    let lastPosition = 0;
    try {
      const size = source.length;
      sequentialMode = true;
      const value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
      if (forEach) {
        if (forEach(value) === false) {
          return;
        }
        while (position < size) {
          lastPosition = position;
          if (forEach(checkedRead()) === false) {
            return;
          }
        }
      } else {
        values = [value];
        while (position < size) {
          lastPosition = position;
          values.push(checkedRead());
        }
        return values;
      }
    } catch (error) {
      error.lastPosition = lastPosition;
      error.values = values;
      throw error;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
};
function checkedRead() {
  try {
    const result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        const error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position === srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) referenceMap = null;
    } else if (position > srcEnd) {
      const error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  const majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        if (majorType === 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType === 7) {
          const value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            const multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType === 7) {
          const value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0)
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 4294967296;
          token += dataView.getUint32(position + 4);
        } else token = dataView.getBigUint64(position);
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          // byte string
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4: {
            const array = [];
            let value;
            let i = 0;
            while ((value = read()) !== STOP_CODE) {
              if (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`);
              array[i++] = value;
            }
            return majorType === 4 ? array : majorType === 3 ? array.join("") : Buffer.concat(array);
          }
          case 5: {
            let key;
            if (currentDecoder.mapsAsObjects) {
              const object = {};
              let i = 0;
              if (currentDecoder.keyMap) {
                while ((key = read()) !== STOP_CODE) {
                  if (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`);
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) !== STOP_CODE) {
                  if (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`);
                  object[safeKey(key)] = read();
                }
              }
              return object;
            }
            if (restoreMapsAsObject) {
              currentDecoder.mapsAsObjects = true;
              restoreMapsAsObject = false;
            }
            const map = /* @__PURE__ */ new Map();
            if (currentDecoder.keyMap) {
              let i = 0;
              while ((key = read()) !== STOP_CODE) {
                if (i++ >= maxMapSize) {
                  throw new Error(`Map size exceeds ${maxMapSize}`);
                }
                map.set(currentDecoder.decodeKey(key), read());
              }
            } else {
              let i = 0;
              while ((key = read()) !== STOP_CODE) {
                if (i++ >= maxMapSize) {
                  throw new Error(`Map size exceeds ${maxMapSize}`);
                }
                map.set(key, read());
              }
            }
            return map;
          }
          case 7:
            return STOP_CODE;
          default:
            throw new Error(`Invalid major type for indefinite length ${majorType}`);
        }
      default:
        throw new Error(`Unknown token ${token}`);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {
        const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null) return string;
      }
      return readFixedString(token);
    case 4: {
      if (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`);
      const array = new Array(token);
      for (let i = 0; i < token; i++) array[i] = read();
      return array;
    }
    case 5: {
      if (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`);
      if (currentDecoder.mapsAsObjects) {
        const object = {};
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read();
        else for (let i = 0; i < token; i++) object[safeKey(read())] = read();
        return object;
      }
      if (restoreMapsAsObject) {
        currentDecoder.mapsAsObjects = true;
        restoreMapsAsObject = false;
      }
      const map = /* @__PURE__ */ new Map();
      if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()), read());
      else for (let i = 0; i < token; i++) map.set(read(), read());
      return map;
    }
    case 6: {
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read) structure.read = createStructureReader(structure);
          return structure.read();
        }
        if (token < 65536) {
          if (token === RECORD_INLINE_ID) {
            const length = readJustLength();
            const id = read();
            const structure2 = read();
            recordDefinition(id, structure2);
            const object = {};
            if (currentDecoder.keyMap)
              for (let i = 2; i < length; i++) {
                const key = currentDecoder.decodeKey(structure2[i - 2]);
                object[safeKey(key)] = read();
              }
            else
              for (let i = 2; i < length; i++) {
                const key = structure2[i - 2];
                object[safeKey(key)] = read();
              }
            return object;
          }
          if (token === RECORD_DEFINITIONS_ID) {
            const length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition(id++, read());
            }
            return read();
          }
          if (token === BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read) structure.read = createStructureReader(structure);
              return structure.read();
            }
          }
        }
      }
      const extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead) return extension(read);
        return extension(read());
      }
      const input = read();
      for (let i = 0; i < currentExtensionRanges.length; i++) {
        const value = currentExtensionRanges[i](token, input);
        if (value !== void 0) return value;
      }
      return new Tag(input, token);
    }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        // undefined
        default: {
          const packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0) return packedValue;
          throw new Error(`Unknown token ${token}`);
        }
      }
    default:
      if (Number.isNaN(token)) {
        const error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error(`Unknown CBOR token ${token}`);
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  if (!structure) throw new Error("Structure is required in record definition");
  function readObject() {
    let length = src[position++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position++];
          break;
        case 25:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error(`Expected array header, but got ${src[position - 1]}`);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length) return compiledReader(read);
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= inlineObjectReadThreshold) {
      const array = this.length === length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function(
        "r",
        `return {${array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? `${safeKey(k)}:r()` : `[${JSON.stringify(k)}]:r()`).join(",")}}`
      ) : new Function(
        "r",
        `return {${array.map((key) => validName.test(key) ? `${safeKey(key)}:r()` : `[${JSON.stringify(key)}]:r()`).join(",")}}`
      );
      if (this.compiledReader) compiledReader.next = this.compiledReader;
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    const object = {};
    if (currentDecoder.keyMap)
      for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
    else
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  if (typeof key === "string") return key === "__proto__" ? "__proto_" : key;
  if (typeof key === "number" || typeof key === "boolean" || typeof key === "bigint") return key.toString();
  if (key == null) return `${key}`;
  throw new Error(`Invalid property name type ${typeof key}`);
}
var readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length)) return result;
  }
  if (length > 64 && decoder) return decoder.decode(src.subarray(position, position += length));
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  const start = position;
  const bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) return "";
      const a3 = src[position++];
      if ((a3 & 128) > 1) {
        position -= 1;
        return;
      }
      return fromCharCode(a3);
    }
    const a2 = src[position++];
    const b2 = src[position++];
    if ((a2 & 128) > 0 || (b2 & 128) > 0) {
      position -= 2;
      return;
    }
    if (length < 3) return fromCharCode(a2, b2);
    const c2 = src[position++];
    if ((c2 & 128) > 0) {
      position -= 3;
      return;
    }
    return fromCharCode(a2, b2, c2);
  }
  const a = src[position++];
  const b = src[position++];
  const c = src[position++];
  const d = src[position++];
  if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
    position -= 4;
    return;
  }
  if (length < 6) {
    if (length === 4) return fromCharCode(a, b, c, d);
    const e2 = src[position++];
    if ((e2 & 128) > 0) {
      position -= 5;
      return;
    }
    return fromCharCode(a, b, c, d, e2);
  }
  if (length < 8) {
    const e2 = src[position++];
    const f2 = src[position++];
    if ((e2 & 128) > 0 || (f2 & 128) > 0) {
      position -= 6;
      return;
    }
    if (length < 7) return fromCharCode(a, b, c, d, e2, f2);
    const g2 = src[position++];
    if ((g2 & 128) > 0) {
      position -= 7;
      return;
    }
    return fromCharCode(a, b, c, d, e2, f2, g2);
  }
  const e = src[position++];
  const f = src[position++];
  const g = src[position++];
  const h = src[position++];
  if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
    position -= 8;
    return;
  }
  if (length < 10) {
    if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);
    const i2 = src[position++];
    if ((i2 & 128) > 0) {
      position -= 9;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i2);
  }
  if (length < 12) {
    const i2 = src[position++];
    const j2 = src[position++];
    if ((i2 & 128) > 0 || (j2 & 128) > 0) {
      position -= 10;
      return;
    }
    if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i2, j2);
    const k2 = src[position++];
    if ((k2 & 128) > 0) {
      position -= 11;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i2, j2, k2);
  }
  const i = src[position++];
  const j = src[position++];
  const k = src[position++];
  const l = src[position++];
  if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
    position -= 12;
    return;
  }
  if (length < 14) {
    if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
    const m2 = src[position++];
    if ((m2 & 128) > 0) {
      position -= 13;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m2);
  }
  const m = src[position++];
  const n = src[position++];
  if ((m & 128) > 0 || (n & 128) > 0) {
    position -= 14;
    return;
  }
  if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
  const o = src[position++];
  if ((o & 128) > 0) {
    position -= 15;
    return;
  }
  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  const byte0 = src[position++];
  const byte1 = src[position++];
  const exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3) return Number.NaN;
    return byte0 & 128 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  }
  if (exponent === 0) {
    const abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
var keyCache = new Array(4096);
var Tag = class {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
};
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + (value << BigInt(8));
  }
  return value;
};
currentExtensions[3] = (buffer) => {
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction) => {
  return +`${fraction[1]}e${fraction[0]}`;
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
var recordDefinition = (id, structure) => {
  id = id - 57344;
  const existingStructure = currentStructures[id];
  if (existingStructure?.isShared) {
    ;
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
  const length = data.length;
  const structure = data[1];
  recordDefinition(data[0], structure);
  const object = {};
  for (let i = 2; i < length; i++) {
    const key = structure[i - 2];
    object[safeKey(key)] = data[i];
  }
  return object;
};
currentExtensions[14] = (value) => {
  if (bundledStrings) return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings) return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  return new Tag(value, 15);
};
var glbl = { Error, RegExp };
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (read2) => {
  if (src[position++] !== 132) {
    const error = new Error("Packed values structure must be followed by a 4 element array");
    if (src.length < position) error.incomplete = true;
    throw error;
  }
  const newPackedValues = read2();
  if (!newPackedValues || !newPackedValues.length) {
    const error = new Error("Packed values structure must be followed by a 4 element array");
    error.incomplete = true;
    throw error;
  }
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = read2();
  packedValues.suffixes = read2();
  return read2();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared) loadShared();
    else return new Tag(data, PACKED_REFERENCE_TAG_ID);
  }
  if (typeof data === "number") return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  const error = new Error("No support for non-integer packed references yet");
  if (data === void 0) error.incomplete = true;
  throw error;
};
currentExtensions[28] = (read2) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  const id = referenceMap.id++;
  const startingPosition = position;
  const token = src[position];
  let target2;
  if (token >> 5 === 4) target2 = [];
  else target2 = {};
  const refEntry = { target: target2 };
  referenceMap.set(id, refEntry);
  let targetProperties = read2();
  if (refEntry.used) {
    if (Object.getPrototypeOf(target2) !== Object.getPrototypeOf(targetProperties)) {
      position = startingPosition;
      target2 = targetProperties;
      referenceMap.set(id, { target: target2 });
      targetProperties = read2();
    }
    return Object.assign(target2, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  const refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (read2) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return read2();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string") return a + b;
  if (Array.isArray(a)) return a.concat(b);
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) loadShared();
    else throw new Error("No packed values available");
  }
  return packedValues;
}
var SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) return combine(getPackedValues().prefixes[tag - 224], input);
  if (tag >= 28704 && tag <= 32767) return combine(getPackedValues().prefixes[tag - 28672], input);
  if (tag >= 1879052288 && tag <= 2147483647) return combine(getPackedValues().prefixes[tag - 1879048192], input);
  if (tag >= 216 && tag <= 223) return combine(input, getPackedValues().suffixes[tag - 216]);
  if (tag >= 27647 && tag <= 28671) return combine(input, getPackedValues().suffixes[tag - 27639]);
  if (tag >= 1811940352 && tag <= 1879048191) return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  if (tag === SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag === 55799)
    return input;
});
var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
var typedArrays = [
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array === "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array === "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
  Float32Array,
  Float64Array
];
var typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  const dvMethod = `get${TypedArray.name.slice(0, -5)}`;
  let bytesPerElement;
  if (typeof TypedArray === "function") bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  else TypedArray = null;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement === 1) continue;
    const sizeShift = bytesPerElement === 2 ? 1 : bytesPerElement === 4 ? 2 : bytesPerElement === 8 ? 3 : 0;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement === 1 || littleEndian === isLittleEndianMachine ? (buffer) => {
      if (!TypedArray) throw new Error(`Could not find typed array for code ${tag}`);
      if (!currentDecoder.copyBuffers) {
        if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer.byteOffset & 1) || bytesPerElement === 4 && !(buffer.byteOffset & 3) || bytesPerElement === 8 && !(buffer.byteOffset & 7))
          return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);
      }
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray) throw new Error(`Could not find typed array for code ${tag}`);
      const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      const elements = buffer.length >> sizeShift;
      const ta = new TypedArray(elements);
      const method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  const length = readJustLength();
  const bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    const bundleLength = readJustLength();
    position += bundleLength;
  }
  const dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    const sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    const updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) currentDecoder.structures = currentStructures = updatedStructures;
    else currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
  }
}
function saveState(callback) {
  const savedSrcEnd = srcEnd;
  const savedPosition = position;
  const savedStringPosition = stringPosition;
  const savedSrcStringStart = srcStringStart;
  const savedSrcStringEnd = srcStringEnd;
  const savedSrcString = srcString;
  const savedStrings = strings;
  const savedReferenceMap = referenceMap;
  const savedBundledStrings = bundledStrings;
  const savedSrc = new Uint8Array(src.slice(0, srcEnd));
  const savedStructures = currentStructures;
  const savedDecoder = currentDecoder;
  const savedSequentialMode = sequentialMode;
  const value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
function addExtension(extension) {
  currentExtensions[extension.tag] = extension.decode;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = +`1e${Math.floor(45.15 - i * 0.30103)}`;
}
var defaultDecoder = new Decoder({ useRecords: false });
var decode = defaultDecoder.decode;
var decodeMultiple = defaultDecoder.decodeMultiple;
var FLOAT32_OPTIONS = {
  NEVER: 0,
  ALWAYS: 1,
  DECIMAL_ROUND: 3,
  DECIMAL_FIT: 4
};

// src/cbor/cbor-x/encode.js
var textEncoder;
try {
  textEncoder = new TextEncoder();
} catch (error) {
}
var extensions;
var extensionClasses;
var Buffer2 = typeof globalThis === "object" && globalThis.Buffer;
var hasNodeBuffer = typeof Buffer2 !== "undefined";
var ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
var ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
var MAX_STRUCTURES = 256;
var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
var throwOnIterable;
var target;
var targetView;
var position2 = 0;
var safeEnd;
var bundledStrings2 = null;
var MAX_BUNDLE_SIZE = 61440;
var hasNonLatin = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL = Symbol("record-id");
var Encoder = class extends Decoder {
  constructor(options) {
    super(options);
    this.offset = 0;
    let typeBuffer;
    let start;
    let sharedStructures;
    let hasSharedUpdate;
    let structures;
    let referenceMap2;
    options = options || {};
    const encodeUtf8 = ByteArray.prototype.utf8Write ? (string, position3, maxBytes) => target.utf8Write(string, position3, maxBytes) : textEncoder?.encodeInto ? (string, position3) => textEncoder.encodeInto(string, target.subarray(position3)).written : false;
    const encoder = this;
    const hasSharedStructures = options.structures || options.saveStructures;
    let maxSharedStructures = options.maxSharedStructures;
    if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0;
    if (maxSharedStructures > 8190) throw new Error("Maximum maxSharedStructure is 8190");
    const isSequential = options.sequential;
    if (isSequential) {
      maxSharedStructures = 0;
    }
    if (!this.structures) this.structures = [];
    if (this.saveStructures) this.saveShared = this.saveStructures;
    let samplingPackedValues;
    let packedObjectMap2;
    let sharedValues = options.sharedValues;
    let sharedPackedObjectMap2;
    if (sharedValues) {
      sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      for (let i = 0, l = sharedValues.length; i < l; i++) {
        sharedPackedObjectMap2[sharedValues[i]] = i;
      }
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.mapEncode = function(value, encodeOptions) {
      if (this._keyMap && !this._mapped) {
        switch (value.constructor.name) {
          case "Array":
            value = value.map((r) => this.encodeKeys(r));
            break;
        }
      }
      return this.encode(value, encodeOptions);
    };
    this.encode = (value, encodeOptions) => {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = new DataView(target.buffer, 0, 8192);
        position2 = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position2 < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = new DataView(target.buffer, 0, target.length);
        safeEnd = target.length - 10;
        position2 = 0;
      } else if (encodeOptions === REUSE_BUFFER_MODE) position2 = position2 + 7 & 2147483640;
      start = position2;
      if (encoder.useSelfDescribedHeader) {
        targetView.setUint32(position2, 3654940416);
        position2 += 3;
      }
      referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (encoder.bundleStrings && typeof value !== "string") {
        bundledStrings2 = [];
        bundledStrings2.size = Number.POSITIVE_INFINITY;
      } else bundledStrings2 = null;
      sharedStructures = encoder.structures;
      if (sharedStructures) {
        if (sharedStructures.uninitialized) {
          const sharedData = encoder.getShared() || {};
          encoder.structures = sharedStructures = sharedData.structures || [];
          encoder.sharedVersion = sharedData.version;
          const sharedValues2 = encoder.sharedValues = sharedData.packedValues;
          if (sharedValues2) {
            sharedPackedObjectMap2 = {};
            for (let i = 0, l = sharedValues2.length; i < l; i++) sharedPackedObjectMap2[sharedValues2[i]] = i;
          }
        }
        let sharedStructuresLength = sharedStructures.length;
        if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures;
        if (!sharedStructures.transitions) {
          sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedStructuresLength; i++) {
            const keys = sharedStructures[i];
            if (!keys) continue;
            let nextTransition;
            let transition = sharedStructures.transitions;
            for (let j = 0, l = keys.length; j < l; j++) {
              if (transition[RECORD_SYMBOL] === void 0) transition[RECORD_SYMBOL] = i;
              const key = keys[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i | 1048576;
          }
        }
        if (!isSequential) sharedStructures.nextId = sharedStructuresLength;
      }
      if (hasSharedUpdate) hasSharedUpdate = false;
      structures = sharedStructures || [];
      packedObjectMap2 = sharedPackedObjectMap2;
      if (options.pack) {
        const packedValues2 = /* @__PURE__ */ new Map();
        packedValues2.values = [];
        packedValues2.encoder = encoder;
        packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Number.POSITIVE_INFINITY);
        packedValues2.objectMap = sharedPackedObjectMap2 || false;
        packedValues2.samplingPackedValues = samplingPackedValues;
        findRepetitiveStrings(value, packedValues2);
        if (packedValues2.values.length > 0) {
          target[position2++] = 216;
          target[position2++] = 51;
          writeArrayHeader(4);
          const valuesArray = packedValues2.values;
          encode2(valuesArray);
          writeArrayHeader(0);
          writeArrayHeader(0);
          packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
          for (let i = 0, l = valuesArray.length; i < l; i++) {
            packedObjectMap2[valuesArray[i]] = i;
          }
        }
      }
      throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
      try {
        if (throwOnIterable) return;
        encode2(value);
        if (bundledStrings2) {
          writeBundles(start, encode2);
        }
        encoder.offset = position2;
        if (referenceMap2?.idsToInsert) {
          position2 += referenceMap2.idsToInsert.length * 2;
          if (position2 > safeEnd) makeRoom(position2);
          encoder.offset = position2;
          const serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
          referenceMap2 = null;
          return serialized;
        }
        if (encodeOptions & REUSE_BUFFER_MODE) {
          target.start = start;
          target.end = position2;
          return target;
        }
        return target.subarray(start, position2);
      } finally {
        if (sharedStructures) {
          if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;
          if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures;
          if (transitionsCount > 1e4) {
            sharedStructures.transitions = null;
            serializationsSinceTransitionRebuild = 0;
            transitionsCount = 0;
            if (recordIdsToRemove.length > 0) recordIdsToRemove = [];
          } else if (recordIdsToRemove.length > 0 && !isSequential) {
            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
              recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
            }
            recordIdsToRemove = [];
          }
        }
        if (hasSharedUpdate && encoder.saveShared) {
          if (encoder.structures.length > maxSharedStructures) {
            encoder.structures = encoder.structures.slice(0, maxSharedStructures);
          }
          const returnBuffer = target.subarray(start, position2);
          if (encoder.updateSharedData() === false) return encoder.encode(value);
          return returnBuffer;
        }
        if (encodeOptions & RESET_BUFFER_MODE) position2 = start;
      }
    };
    this.findCommonStringsToPack = () => {
      samplingPackedValues = /* @__PURE__ */ new Map();
      if (!sharedPackedObjectMap2) sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      return (options2) => {
        const threshold = options2?.threshold || 4;
        let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
        if (!sharedValues) sharedValues = this.sharedValues = [];
        for (const [key, status] of samplingPackedValues) {
          if (status.count > threshold) {
            sharedPackedObjectMap2[key] = position3++;
            sharedValues.push(key);
            hasSharedUpdate = true;
          }
        }
        while (this.saveShared && this.updateSharedData() === false) {
        }
        samplingPackedValues = null;
      };
    };
    const encode2 = (value) => {
      if (position2 > safeEnd) target = makeRoom(position2);
      const type = typeof value;
      let length;
      if (type === "string") {
        if (packedObjectMap2) {
          const packedPosition = packedObjectMap2[value];
          if (packedPosition >= 0) {
            if (packedPosition < 16)
              target[position2++] = packedPosition + 224;
            else {
              target[position2++] = 198;
              if (packedPosition & 1) encode2(15 - packedPosition >> 1);
              else encode2(packedPosition - 16 >> 1);
            }
            return;
          }
          if (samplingPackedValues && !options.pack) {
            const status = samplingPackedValues.get(value);
            if (status) status.count++;
            else
              samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
        const strLength = value.length;
        if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            const maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
            if (position2 + maxBytes2 > safeEnd) target = makeRoom(position2 + maxBytes2);
            target[position2++] = 217;
            target[position2++] = 223;
            target[position2++] = 249;
            target[position2++] = bundledStrings2.position ? 132 : 130;
            target[position2++] = 26;
            extStart = position2 - start;
            position2 += 4;
            if (bundledStrings2.position) {
              writeBundles(start, encode2);
            }
            bundledStrings2 = ["", ""];
            bundledStrings2.size = 0;
            bundledStrings2.position = extStart;
          }
          const twoByte = hasNonLatin.test(value);
          bundledStrings2[twoByte ? 0 : 1] += value;
          target[position2++] = twoByte ? 206 : 207;
          encode2(strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        const maxBytes = strLength * 3;
        if (position2 + maxBytes > safeEnd) target = makeRoom(position2 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i;
          let c1;
          let c2;
          let strPosition = position2 + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length = strPosition - position2 - headerSize;
        } else {
          length = encodeUtf8(value, position2 + headerSize, maxBytes);
        }
        if (length < 24) {
          target[position2++] = 96 | length;
        } else if (length < 256) {
          if (headerSize < 2) {
            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length);
          }
          target[position2++] = 120;
          target[position2++] = length;
        } else if (length < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length);
          }
          target[position2++] = 121;
          target[position2++] = length >> 8;
          target[position2++] = length & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length);
          }
          target[position2++] = 122;
          targetView.setUint32(position2, length);
          position2 += 4;
        }
        position2 += length;
      } else if (type === "number") {
        if (!this.alwaysUseFloat && value >>> 0 === value) {
          if (value < 24) {
            target[position2++] = value;
          } else if (value < 256) {
            target[position2++] = 24;
            target[position2++] = value;
          } else if (value < 65536) {
            target[position2++] = 25;
            target[position2++] = value >> 8;
            target[position2++] = value & 255;
          } else {
            target[position2++] = 26;
            targetView.setUint32(position2, value);
            position2 += 4;
          }
        } else if (!this.alwaysUseFloat && value >> 0 === value) {
          if (value >= -24) {
            target[position2++] = 31 - value;
          } else if (value >= -256) {
            target[position2++] = 56;
            target[position2++] = ~value;
          } else if (value >= -65536) {
            target[position2++] = 57;
            targetView.setUint16(position2, ~value);
            position2 += 2;
          } else {
            target[position2++] = 58;
            targetView.setUint32(position2, ~value);
            position2 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
            target[position2++] = 250;
            targetView.setFloat32(position2, value);
            let xShifted;
            if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
              position2 += 4;
              return;
            }
            position2--;
          }
          target[position2++] = 251;
          targetView.setFloat64(position2, value);
          position2 += 8;
        }
      } else if (type === "object") {
        if (!value) target[position2++] = 246;
        else {
          if (referenceMap2) {
            const referee = referenceMap2.get(value);
            if (referee) {
              target[position2++] = 216;
              target[position2++] = 29;
              target[position2++] = 25;
              if (!referee.references) {
                const idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                referee.references = [];
                idsToInsert.push(referee);
              }
              referee.references.push(position2 - start);
              position2 += 2;
              return;
            }
            referenceMap2.set(value, { offset: position2 - start });
          }
          const constructor = value.constructor;
          if (constructor === Object) {
            writeObject(value);
          } else if (constructor === Array) {
            length = value.length;
            if (length < 24) {
              target[position2++] = 128 | length;
            } else {
              writeArrayHeader(length);
            }
            for (let i = 0; i < length; i++) {
              encode2(value[i]);
            }
          } else if (constructor === Map) {
            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
              target[position2++] = 217;
              target[position2++] = 1;
              target[position2++] = 3;
            }
            length = value.size;
            if (length < 24) {
              target[position2++] = 160 | length;
            } else if (length < 256) {
              target[position2++] = 184;
              target[position2++] = length;
            } else if (length < 65536) {
              target[position2++] = 185;
              target[position2++] = length >> 8;
              target[position2++] = length & 255;
            } else {
              target[position2++] = 186;
              targetView.setUint32(position2, length);
              position2 += 4;
            }
            if (encoder.keyMap) {
              for (const [key, entryValue] of value) {
                encode2(encoder.encodeKey(key));
                encode2(entryValue);
              }
            } else {
              for (const [key, entryValue] of value) {
                encode2(key);
                encode2(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length; i < l; i++) {
              const extensionClass = extensionClasses[i];
              if (value instanceof extensionClass) {
                const extension = extensions[i];
                let tag = extension.tag;
                if (tag === void 0) tag = extension.getTag?.call(this, value);
                if (tag < 24) {
                  target[position2++] = 192 | tag;
                } else if (tag < 256) {
                  target[position2++] = 216;
                  target[position2++] = tag;
                } else if (tag < 65536) {
                  target[position2++] = 217;
                  target[position2++] = tag >> 8;
                  target[position2++] = tag & 255;
                } else if (tag > -1) {
                  target[position2++] = 218;
                  targetView.setUint32(position2, tag);
                  position2 += 4;
                }
                extension.encode.call(this, value, encode2, makeRoom);
                return;
              }
            }
            if (value[Symbol.iterator]) {
              if (throwOnIterable) {
                const error = new Error("Iterable should be serialized as iterator");
                error.iteratorNotHandled = true;
                throw error;
              }
              target[position2++] = 159;
              for (const entry of value) {
                encode2(entry);
              }
              target[position2++] = 255;
              return;
            }
            if (value[Symbol.asyncIterator] || isBlob(value)) {
              const error = new Error("Iterable/blob should be serialized as iterator");
              error.iteratorNotHandled = true;
              throw error;
            }
            if (this.useToJSON && value.toJSON) {
              const json = value.toJSON();
              if (json !== value) return encode2(json);
            }
            writeObject(value);
          }
        }
      } else if (type === "boolean") {
        target[position2++] = value ? 245 : 244;
      } else if (type === "bigint") {
        if (value < BigInt(1) << BigInt(64) && value >= 0) {
          target[position2++] = 27;
          targetView.setBigUint64(position2, value);
        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
          target[position2++] = 59;
          targetView.setBigUint64(position2, -value - BigInt(1));
        } else {
          if (this.largeBigIntToFloat) {
            target[position2++] = 251;
            targetView.setFloat64(position2, Number(value));
          } else {
            if (value >= BigInt(0))
              target[position2++] = 194;
            else {
              target[position2++] = 195;
              value = BigInt(-1) - value;
            }
            const bytes = [];
            while (value) {
              bytes.push(Number(value & BigInt(255)));
              value >>= BigInt(8);
            }
            writeBuffer(new Uint8Array(bytes.reverse()), makeRoom);
            return;
          }
        }
        position2 += 8;
      } else if (type === "undefined") {
        target[position2++] = 247;
      } else {
        throw new Error(`Unknown type: ${type}`);
      }
    };
    const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
      const keys = Object.keys(object);
      const vals = Object.values(object);
      const length = keys.length;
      if (length < 24) {
        target[position2++] = 160 | length;
      } else if (length < 256) {
        target[position2++] = 184;
        target[position2++] = length;
      } else if (length < 65536) {
        target[position2++] = 185;
        target[position2++] = length >> 8;
        target[position2++] = length & 255;
      } else {
        target[position2++] = 186;
        targetView.setUint32(position2, length);
        position2 += 4;
      }
      let key;
      if (encoder.keyMap) {
        for (let i = 0; i < length; i++) {
          encode2(encoder.encodeKey(keys[i]));
          encode2(vals[i]);
        }
      } else {
        for (let i = 0; i < length; i++) {
          encode2(keys[i]);
          encode2(vals[i]);
        }
      }
    } : (object) => {
      target[position2++] = 185;
      let objectOffset = position2 - start;
      position2 += 2;
      let size = 0;
      if (encoder.keyMap) {
        for (const key in object)
          if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
            encode2(encoder.encodeKey(key));
            encode2(object[key]);
            size++;
          }
      } else {
        for (const key in object)
          if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
            encode2(key);
            encode2(object[key]);
            size++;
          }
      }
      target[objectOffset++ + start] = size >> 8;
      target[objectOffset + start] = size & 255;
    } : (object, skipValues) => {
      let nextTransition;
      let transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      let length = 0;
      let parentRecordId;
      let keys;
      if (this.keyMap) {
        keys = Object.keys(object).map((k) => this.encodeKey(k));
        length = keys.length;
        for (let i = 0; i < length; i++) {
          const key = keys[i];
          nextTransition = transition[key];
          if (!nextTransition) {
            nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
        }
      } else {
        for (const key in object)
          if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              if (transition[RECORD_SYMBOL] & 1048576) {
                parentRecordId = transition[RECORD_SYMBOL] & 65535;
              }
              nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
            length++;
          }
      }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId !== void 0) {
        recordId &= 65535;
        target[position2++] = 217;
        target[position2++] = recordId >> 8 | 224;
        target[position2++] = recordId & 255;
      } else {
        if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
        if (parentRecordId === void 0) {
          recordId = structures.nextId++;
          if (!recordId) {
            recordId = 0;
            structures.nextId = 1;
          }
          if (recordId >= MAX_STRUCTURES) {
            structures.nextId = (recordId = maxSharedStructures) + 1;
          }
        } else {
          recordId = parentRecordId;
        }
        structures[recordId] = keys;
        if (recordId < maxSharedStructures) {
          target[position2++] = 217;
          target[position2++] = recordId >> 8 | 224;
          target[position2++] = recordId & 255;
          transition = structures.transitions;
          for (let i = 0; i < length; i++) {
            if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
              transition[RECORD_SYMBOL] = recordId;
            transition = transition[keys[i]];
          }
          transition[RECORD_SYMBOL] = recordId | 1048576;
          hasSharedUpdate = true;
        } else {
          transition[RECORD_SYMBOL] = recordId;
          targetView.setUint32(position2, 3655335680);
          position2 += 3;
          if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
          if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
            recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
          recordIdsToRemove.push(transition);
          writeArrayHeader(length + 2);
          encode2(57344 + recordId);
          encode2(keys);
          if (skipValues) return;
          for (const key in object)
            if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) encode2(object[key]);
          return;
        }
      }
      if (length < 24) {
        target[position2++] = 128 | length;
      } else {
        writeArrayHeader(length);
      }
      if (skipValues) return;
      for (const key in object)
        if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) encode2(object[key]);
    };
    const makeRoom = (end) => {
      let newSize;
      if (end > 16777216) {
        if (end - start > MAX_BUFFER_SIZE) throw new Error("Encoded buffer would be larger than maximum buffer size");
        newSize = Math.min(
          MAX_BUFFER_SIZE,
          Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
        );
      } else newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
      const newBuffer = new ByteArrayAllocate(newSize);
      targetView = new DataView(newBuffer.buffer, 0, newSize);
      if (target.copy) target.copy(newBuffer, 0, start, end);
      else newBuffer.set(target.slice(start, end));
      position2 -= start;
      start = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    };
    let chunkThreshold = 100;
    let continuedChunkThreshold = 1e3;
    this.encodeAsIterable = (value, options2) => startEncoding(value, options2, encodeObjectAsIterable);
    this.encodeAsAsyncIterable = (value, options2) => startEncoding(value, options2, encodeObjectAsAsyncIterable);
    function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
      const constructor = object.constructor;
      if (constructor === Object) {
        const useRecords = encoder.useRecords !== false;
        if (useRecords)
          writeObject(object, true);
        else writeEntityLength(Object.keys(object).length, 160);
        for (const key in object) {
          const value = object[key];
          if (!useRecords) encode2(key);
          if (value && typeof value === "object") {
            if (iterateProperties[key]) yield* encodeObjectAsIterable(value, iterateProperties[key]);
            else yield* tryEncode(value, iterateProperties, key);
          } else encode2(value);
        }
      } else if (constructor === Array) {
        const length = object.length;
        writeArrayHeader(length);
        for (let i = 0; i < length; i++) {
          const value = object[i];
          if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
            if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);
            else yield* tryEncode(value, iterateProperties, "element");
          } else encode2(value);
        }
      } else if (object[Symbol.iterator] && !object.buffer) {
        target[position2++] = 159;
        for (const value of object) {
          if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
            if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);
            else yield* tryEncode(value, iterateProperties, "element");
          } else encode2(value);
        }
        target[position2++] = 255;
      } else if (isBlob(object)) {
        writeEntityLength(object.size, 64);
        yield target.subarray(start, position2);
        yield object;
        restartEncoding();
      } else if (object[Symbol.asyncIterator]) {
        target[position2++] = 159;
        yield target.subarray(start, position2);
        yield object;
        restartEncoding();
        target[position2++] = 255;
      } else {
        encode2(object);
      }
      if (finalIterable && position2 > start) yield target.subarray(start, position2);
      else if (position2 - start > chunkThreshold) {
        yield target.subarray(start, position2);
        restartEncoding();
      }
    }
    function* tryEncode(value, iterateProperties, key) {
      const restart = position2 - start;
      try {
        encode2(value);
        if (position2 - start > chunkThreshold) {
          yield target.subarray(start, position2);
          restartEncoding();
        }
      } catch (error) {
        if (error.iteratorNotHandled) {
          iterateProperties[key] = {};
          position2 = start + restart;
          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
        } else throw error;
      }
    }
    function restartEncoding() {
      chunkThreshold = continuedChunkThreshold;
      encoder.encode(null, THROW_ON_ITERABLE);
    }
    function startEncoding(value, options2, encodeIterable) {
      if (options2?.chunkThreshold)
        chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
      else chunkThreshold = 100;
      if (value && typeof value === "object") {
        encoder.encode(null, THROW_ON_ITERABLE);
        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
      }
      return [encoder.encode(value)];
    }
    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
      for (const encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
        const constructor = encodedValue.constructor;
        if (constructor === ByteArray || constructor === Uint8Array) yield encodedValue;
        else if (isBlob(encodedValue)) {
          const reader = encodedValue.stream().getReader();
          let next;
          while (!(next = await reader.read()).done) {
            yield next.value;
          }
        } else if (encodedValue[Symbol.asyncIterator]) {
          for await (const asyncValue of encodedValue) {
            restartEncoding();
            if (asyncValue)
              yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
            else yield encoder.encode(asyncValue);
          }
        } else {
          yield encodedValue;
        }
      }
    }
  }
  useBuffer(buffer) {
    target = buffer;
    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
    position2 = 0;
  }
  clearSharedData() {
    if (this.structures) this.structures = [];
    if (this.sharedValues) this.sharedValues = void 0;
  }
  updateSharedData() {
    const lastVersion = this.sharedVersion || 0;
    this.sharedVersion = lastVersion + 1;
    const structuresCopy = this.structures.slice(0);
    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
    const saveResults = this.saveShared(sharedData, (existingShared) => (existingShared?.version || 0) === lastVersion);
    if (saveResults === false) {
      sharedData = this.getShared() || {};
      this.structures = sharedData.structures || [];
      this.sharedValues = sharedData.packedValues;
      this.sharedVersion = sharedData.version;
      this.structures.nextId = this.structures.length;
    } else {
      structuresCopy.forEach((structure, i) => this.structures[i] = structure);
    }
    return saveResults;
  }
};
function writeEntityLength(length, majorValue) {
  if (length < 24) target[position2++] = majorValue | length;
  else if (length < 256) {
    target[position2++] = majorValue | 24;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = majorValue | 25;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = majorValue | 26;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
}
var SharedData = class {
  constructor(structures, values, version) {
    this.structures = structures;
    this.packedValues = values;
    this.version = version;
  }
};
function writeArrayHeader(length) {
  if (length < 24) target[position2++] = 128 | length;
  else if (length < 256) {
    target[position2++] = 152;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = 153;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = 154;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
}
var BlobConstructor = typeof Blob === "undefined" ? () => {
} : Blob;
function isBlob(object) {
  if (object instanceof BlobConstructor) return true;
  const tag = object[Symbol.toStringTag];
  return tag === "Blob" || tag === "File";
}
function findRepetitiveStrings(value, packedValues2) {
  switch (typeof value) {
    case "string":
      if (value.length > 3) {
        if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues) return;
        const packedStatus = packedValues2.get(value);
        if (packedStatus) {
          if (++packedStatus.count === 2) {
            packedValues2.values.push(value);
          }
        } else {
          packedValues2.set(value, {
            count: 1
          });
          if (packedValues2.samplingPackedValues) {
            const status = packedValues2.samplingPackedValues.get(value);
            if (status) status.count++;
            else
              packedValues2.samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
      }
      break;
    case "object":
      if (value) {
        if (Array.isArray(value)) {
          for (let i = 0, l = value.length; i < l; i++) {
            findRepetitiveStrings(value[i], packedValues2);
          }
        } else {
          const includeKeys = !packedValues2.encoder.useRecords;
          for (const key in value) {
            if (value.hasOwnProperty(key)) {
              if (includeKeys) findRepetitiveStrings(key, packedValues2);
              findRepetitiveStrings(value[key], packedValues2);
            }
          }
        }
      }
      break;
    case "function":
      console.log(value);
  }
}
var isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
extensionClasses = [
  Date,
  Set,
  Error,
  RegExp,
  Tag,
  ArrayBuffer,
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array === "undefined" ? () => {
  } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array === "undefined" ? () => {
  } : BigInt64Array,
  Float32Array,
  Float64Array,
  SharedData
];
extensions = [
  {
    // Date
    tag: 1,
    encode(date, encode2) {
      const seconds = date.getTime() / 1e3;
      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
        target[position2++] = 26;
        targetView.setUint32(position2, seconds);
        position2 += 4;
      } else {
        target[position2++] = 251;
        targetView.setFloat64(position2, seconds);
        position2 += 8;
      }
    }
  },
  {
    // Set
    tag: 258,
    // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
    encode(set, encode2) {
      const array = Array.from(set);
      encode2(array);
    }
  },
  {
    // Error
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(error, encode2) {
      encode2([error.name, error.message]);
    }
  },
  {
    // RegExp
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(regex, encode2) {
      encode2(["RegExp", regex.source, regex.flags]);
    }
  },
  {
    // Tag
    getTag(tag) {
      return tag.tag;
    },
    encode(tag, encode2) {
      encode2(tag.value);
    }
  },
  {
    // ArrayBuffer
    encode(arrayBuffer, encode2, makeRoom) {
      writeBuffer(arrayBuffer, makeRoom);
    }
  },
  {
    // Uint8Array
    getTag(typedArray) {
      if (typedArray.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false) return 64;
      }
    },
    encode(typedArray, encode2, makeRoom) {
      writeBuffer(typedArray, makeRoom);
    }
  },
  typedArrayEncoder(68, 1),
  typedArrayEncoder(69, 2),
  typedArrayEncoder(70, 4),
  typedArrayEncoder(71, 8),
  typedArrayEncoder(72, 1),
  typedArrayEncoder(77, 2),
  typedArrayEncoder(78, 4),
  typedArrayEncoder(79, 8),
  typedArrayEncoder(85, 4),
  typedArrayEncoder(86, 8),
  {
    encode(sharedData, encode2) {
      const packedValues2 = sharedData.packedValues || [];
      const sharedStructures = sharedData.structures || [];
      if (packedValues2.values.length > 0) {
        target[position2++] = 216;
        target[position2++] = 51;
        writeArrayHeader(4);
        const valuesArray = packedValues2.values;
        encode2(valuesArray);
        writeArrayHeader(0);
        writeArrayHeader(0);
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let i = 0, l = valuesArray.length; i < l; i++) {
          packedObjectMap[valuesArray[i]] = i;
        }
      }
      if (sharedStructures) {
        targetView.setUint32(position2, 3655335424);
        position2 += 3;
        const definitions = sharedStructures.slice(0);
        definitions.unshift(57344);
        definitions.push(new Tag(sharedData.version, 1399353956));
        encode2(definitions);
      } else encode2(new Tag(sharedData.version, 1399353956));
    }
  }
];
function typedArrayEncoder(tag, size) {
  if (!isLittleEndianMachine2 && size > 1) tag -= 4;
  return {
    tag,
    encode: function writeExtBuffer(typedArray, encode2) {
      const length = typedArray.byteLength;
      const offset = typedArray.byteOffset || 0;
      const buffer = typedArray.buffer || typedArray;
      encode2(hasNodeBuffer ? Buffer2.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
    }
  };
}
function writeBuffer(buffer, makeRoom) {
  const length = buffer.byteLength;
  if (length < 24) {
    target[position2++] = 64 + length;
  } else if (length < 256) {
    target[position2++] = 88;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = 89;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = 90;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
  if (position2 + length >= target.length) {
    makeRoom(position2 + length);
  }
  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position2);
  position2 += length;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 2;
  let lastEnd = serialized.length - distanceToMove;
  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
  for (let id = 0; id < idsToInsert.length; id++) {
    const referee = idsToInsert[id];
    referee.id = id;
    for (let position3 of referee.references) {
      serialized[position3++] = id >> 8;
      serialized[position3] = id & 255;
    }
  }
  while (nextId = idsToInsert.pop()) {
    const offset = nextId.offset;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 2;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 216;
    serialized[position3++] = 28;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start, encode2) {
  targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
  const writeStrings = bundledStrings2;
  bundledStrings2 = null;
  encode2(writeStrings[0]);
  encode2(writeStrings[1]);
}
function addExtension2(extension) {
  if (extension.Class) {
    if (!extension.encode) throw new Error("Extension has no encode function");
    extensionClasses.unshift(extension.Class);
    extensions.unshift(extension);
  }
  addExtension(extension);
}
var defaultEncoder = new Encoder({ useRecords: false });
var encode = defaultEncoder.encode;
var encodeAsIterable = defaultEncoder.encodeAsIterable;
var encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
var { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
var REUSE_BUFFER_MODE = 512;
var RESET_BUFFER_MODE = 1024;
var THROW_ON_ITERABLE = 2048;

// src/cbor/data-item.ts
var _data, _buffer;
var _DataItem = class _DataItem {
  constructor(params) {
    __privateAdd(this, _data);
    __privateAdd(this, _buffer);
    if (!("data" in params) && !("buffer" in params)) {
      throw new Error("DataItem must be initialized with either the data or a buffer");
    }
    if ("data" in params) __privateSet(this, _data, params.data);
    __privateSet(this, _buffer, "buffer" in params ? params.buffer : cborEncode(params.data));
  }
  get data() {
    if (!__privateGet(this, _data)) {
      __privateSet(this, _data, cborDecode(__privateGet(this, _buffer)));
    }
    return __privateGet(this, _data);
  }
  get buffer() {
    return __privateGet(this, _buffer);
  }
  static fromData(data) {
    return new _DataItem({ data });
  }
};
_data = new WeakMap();
_buffer = new WeakMap();
var DataItem = _DataItem;
addExtension2({
  Class: DataItem,
  tag: 24,
  encode: (instance, encode2) => {
    return encode2(instance.buffer);
  },
  decode: (buffer) => {
    return new DataItem({ buffer });
  }
});

// src/cbor/index.ts
var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
var DateOnly = class _DateOnly extends Date {
  get [Symbol.toStringTag]() {
    return _DateOnly.name;
  }
  toISOString() {
    return super.toISOString().split("T")[0];
  }
  toString() {
    return this.toISOString();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  toJSON(key) {
    return this.toISOString();
  }
  [customInspectSymbol]() {
    return this.toISOString();
  }
};
var encoderDefaults = {
  tagUint8Array: false,
  useRecords: false,
  mapsAsObjects: false
};
addExtension2({
  Class: Date,
  tag: 0,
  encode: (date, encode2) => encode2(`${date.toISOString().split(".")[0]}Z`),
  decode: (isoStringDateTime) => new Date(isoStringDateTime)
});
addExtension2({
  Class: DateOnly,
  tag: 1004,
  encode: (date, encode2) => encode2(date.toISOString()),
  decode: (isoStringDate) => new DateOnly(isoStringDate)
});
var cborDecode = (input, options = encoderDefaults) => {
  const params = { ...encoderDefaults, ...options };
  const enc = new Encoder(params);
  return enc.decode(input);
};
var cborDecodeUnknown = (input, options = encoderDefaults) => {
  const params = { ...encoderDefaults, ...options };
  const enc = new Encoder(params);
  return enc.decode(input);
};
var cborEncode = (obj, options = encoderDefaults) => {
  const params = { ...encoderDefaults, ...options };
  const enc = new Encoder(params);
  return enc.encode(obj);
};

// src/u-base64.ts
var TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
var IGNORE_BASE64URL = " 	\n\r=".split("");
var FROM_BASE64URL = (() => {
  const charMap = new Array(128);
  for (let i = 0; i < charMap.length; i += 1) {
    charMap[i] = -1;
  }
  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {
    charMap[IGNORE_BASE64URL[i]?.charCodeAt(0)] = -2;
  }
  for (let i = 0; i < TO_BASE64URL.length; i += 1) {
    charMap[TO_BASE64URL[i]?.charCodeAt(0)] = i;
  }
  return charMap;
})();
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 255);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
function uint8ArrayToBase64Url(bytes) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onChar = (char) => {
    result.push(char);
  };
  bytes.map((byte) => byteToBase64URL(byte, state, onChar));
  byteToBase64URL(null, state, onChar);
  return result.join("");
}
function base64UrlToUint8Array(base64Url) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onByte = (byte) => {
    result.push(byte);
  };
  for (let i = 0; i < base64Url.length; i += 1) {
    byteFromBase64URL(base64Url.charCodeAt(i), state, onByte);
  }
  return new Uint8Array(result);
}
function base64ToBase64Url(base64) {
  let base64Url = base64.replace(/\+/g, "-").replace(/\//g, "_");
  base64Url = base64Url.replace(/=+$/, "");
  return base64Url;
}
function base64ToUint8Array(base64) {
  return base64UrlToUint8Array(base64ToBase64Url(base64));
}

// src/u-uint8-array.ts
function uint8ArrayToString(input) {
  return String.fromCharCode.apply(null, Array.from(input));
}
function stringToUint8Array(input) {
  const buffer = new ArrayBuffer(input.length);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < input.length; i++) {
    uint8Array[i] = input.charCodeAt(i);
  }
  return uint8Array;
}
function concatUint8Array(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
function areEqualUint8Array(buf1, buf2) {
  if (buf1 === buf2) {
    return true;
  }
  if (buf1.byteLength !== buf2.byteLength) {
    return false;
  }
  for (let i = 0; i < buf1.byteLength; i++) {
    if (buf1[i] !== buf2[i]) {
      return false;
    }
  }
  return true;
}

// src/cose/typed-map.ts
var _map;
var _TypedMap = class _TypedMap {
  constructor(entries) {
    __privateAdd(this, _map, /* @__PURE__ */ new Map());
    if (entries) {
      for (const [key, value] of entries) {
        __privateGet(this, _map).set(key, value);
      }
    }
  }
  [Symbol.iterator]() {
    return __privateGet(this, _map)[Symbol.iterator]();
  }
  /**
   *
   * Sets the value for the key in the map
   *
   * @param key - The key to set the value for
   * @param value - The value to set
   */
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  set(key, value) {
    __privateGet(this, _map).set(key, value);
  }
  /**
   *
   * Returns the value associated to the key, or undefined if there is none
   *
   * @param key - The key to get the value for
   * @returns - The value associated to the key, or undefined if there is none
   */
  get(key) {
    return __privateGet(this, _map).get(key);
  }
  /**
   * Returns an iterable of key, value pairs for every entry in the map.
   *
   * @returns - An iterable of key, value pairs for every entry in the map
   */
  entries() {
    return __privateGet(this, _map).entries();
  }
  /**
   * Returns an iterable of keys in the map
   *
   * @returns - An iterable of keys in the map
   */
  keys() {
    return __privateGet(this, _map).keys();
  }
  /**
   * Returns an iterable of values in the map
   *
   * @returns - An iterable of values in the map
   */
  values() {
    return __privateGet(this, _map).values();
  }
  /**
   * Clears the map
   */
  clear() {
    __privateGet(this, _map).clear();
  }
  /**
   * Deletes the entry for the given key
   *
   * @param key - The key to delete
   * @returns Whether the key was deleted
   */
  delete(key) {
    return __privateGet(this, _map).delete(key);
  }
  /**
   *
   * Checks if the map has an entry for the given key
   *
   * @param key - The key to check for
   * @returns Whether the map has an entry for the given key
   */
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  /**
   * Returns the number of entries in the map
   */
  get size() {
    return __privateGet(this, _map).size;
  }
  /**
   * Returns the internal ES map
   */
  get esMap() {
    return __privateGet(this, _map);
  }
  static wrap(map) {
    if (typeof map === "undefined") {
      return new _TypedMap();
    }
    if (map instanceof _TypedMap) {
      return map;
    }
    return new _TypedMap(map);
  }
  [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
    const className = this.constructor.name;
    if (depth !== null && depth < 0) {
      return options.stylize(`[${className}]`, "special");
    }
    const newOptions = Object.assign({}, options, {
      // @ts-expect-error this works
      depth: options.depth === null ? null : options.depth - 1
    });
    const padding = " ".repeat(className.length + 2);
    const inner = inspect(this.esMap, newOptions).replace(/\n/g, `
${padding}`);
    return `${options.stylize(className, "special")}< ${inner} >`;
  }
};
_map = new WeakMap();
var TypedMap = _TypedMap;

// src/cose/headers.ts
var Algorithms = /* @__PURE__ */ ((Algorithms2) => {
  Algorithms2[Algorithms2["EdDSA"] = -8] = "EdDSA";
  Algorithms2[Algorithms2["ES256"] = -7] = "ES256";
  Algorithms2[Algorithms2["ES384"] = -35] = "ES384";
  Algorithms2[Algorithms2["ES512"] = -36] = "ES512";
  Algorithms2[Algorithms2["PS256"] = -37] = "PS256";
  Algorithms2[Algorithms2["PS384"] = -38] = "PS384";
  Algorithms2[Algorithms2["PS512"] = -39] = "PS512";
  Algorithms2[Algorithms2["RS256"] = -257] = "RS256";
  Algorithms2[Algorithms2["RS384"] = -258] = "RS384";
  Algorithms2[Algorithms2["RS512"] = -259] = "RS512";
  return Algorithms2;
})(Algorithms || {});
var MacAlgorithms = /* @__PURE__ */ ((MacAlgorithms2) => {
  MacAlgorithms2[MacAlgorithms2["HS256"] = 5] = "HS256";
  MacAlgorithms2[MacAlgorithms2["HS384"] = 6] = "HS384";
  MacAlgorithms2[MacAlgorithms2["HS512"] = 7] = "HS512";
  return MacAlgorithms2;
})(MacAlgorithms || {});
var MacAlgorithmNames = /* @__PURE__ */ new Map([
  [5 /* HS256 */, "HS256"],
  [6 /* HS384 */, "HS384"],
  [7 /* HS512 */, "HS512"]
]);
var AlgorithmNames = /* @__PURE__ */ new Map([
  [-8 /* EdDSA */, "EdDSA"],
  [-7 /* ES256 */, "ES256"],
  [-35 /* ES384 */, "ES384"],
  [-36 /* ES512 */, "ES512"],
  [-37 /* PS256 */, "PS256"],
  [-38 /* PS384 */, "PS384"],
  [-39 /* PS512 */, "PS512"],
  [-257 /* RS256 */, "RS256"],
  [-258 /* RS384 */, "RS384"],
  [-259 /* RS512 */, "RS512"]
]);
var ProtectedHeaders = class _ProtectedHeaders extends TypedMap {
  /**
   * Ensure input is a ProtectedHeaders instance.
   *
   * @param headers - The headers to wrap.
   * @returns
   */
  static from(headers) {
    if (headers instanceof _ProtectedHeaders) {
      return headers;
    }
    return new _ProtectedHeaders(headers);
  }
  /**
   * CBOR encode the hedaers instance
   * @returns {Uint8Array} - The encoded protected headers.
   */
  encode() {
    return cborEncode(this.esMap);
  }
};
var MacProtectedHeaders = class _MacProtectedHeaders extends TypedMap {
  /**
   * Ensure input is a MacProtectedHeaders instance.
   *
   * @param headers - The headers to wrap.
   * @returns
   */
  static from(headers) {
    if (headers instanceof _MacProtectedHeaders) {
      return headers;
    }
    return new _MacProtectedHeaders(headers);
  }
};
var UnprotectedHeaders = class _UnprotectedHeaders extends TypedMap {
  /**
   * Ensure input is a MacProtectedHeaders instance.
   *
   * @param headers - The headers to wrap.
   * @returns
   */
  static from(headers) {
    if (headers instanceof _UnprotectedHeaders) {
      return headers;
    }
    return new _UnprotectedHeaders(headers);
  }
};

// src/cose/key/curve.ts
var Curve = /* @__PURE__ */ ((Curve2) => {
  Curve2[Curve2["P-256"] = 1] = "P-256";
  Curve2[Curve2["P-384"] = 2] = "P-384";
  Curve2[Curve2["P-521"] = 3] = "P-521";
  Curve2[Curve2["X25519"] = 4] = "X25519";
  Curve2[Curve2["X448"] = 5] = "X448";
  Curve2[Curve2["Ed25519"] = 6] = "Ed25519";
  Curve2[Curve2["Ed448"] = 7] = "Ed448";
  return Curve2;
})(Curve || {});

// src/cose/key/key-ops.ts
var JWKKeyOps = /* @__PURE__ */ new Map([
  [1 /* Sign */, "sign"],
  [2 /* Verify */, "verify"],
  [3 /* Encrypt */, "encrypt"],
  [4 /* Decrypt */, "decrypt"],
  [5 /* WrapKey */, "wrapKey"],
  [6 /* UnwrapKey */, "unwrapKey"],
  [7 /* DeriveKey */, "deriveKey"],
  [8 /* DeriveBits */, "deriveBits"],
  //in JWK MAC Create and MAC Verify are sign and verify.
  [9 /* MACCreate */, "sign"],
  [10 /* MACVerify */, "verify"]
]);
var JWKKeyOpsToCOSE = /* @__PURE__ */ new Map([
  ["sign", [1 /* Sign */, 9 /* MACCreate */]],
  ["verify", [2 /* Verify */, 10 /* MACVerify */]],
  ["encrypt", [3 /* Encrypt */]],
  ["decrypt", [4 /* Decrypt */]],
  ["wrapKey", [5 /* WrapKey */]],
  ["unwrapKey", [6 /* UnwrapKey */]],
  ["deriveKey", [7 /* DeriveKey */]],
  ["deriveBits", [8 /* DeriveBits */]]
]);

// src/cose/key/kty.ts
var JWKKeyType = /* @__PURE__ */ ((JWKKeyType2) => {
  JWKKeyType2[JWKKeyType2["OKP"] = 1 /* OKP */] = "OKP";
  JWKKeyType2[JWKKeyType2["EC"] = 2 /* EC */] = "EC";
  JWKKeyType2[JWKKeyType2["oct"] = 4 /* OCT */] = "oct";
  return JWKKeyType2;
})(JWKKeyType || {});

// src/cose/key/params.ts
var reverseMap = (map) => new Map(Array.from(map).map(([k, v]) => [v, k]));
var JWKParam = /* @__PURE__ */ ((JWKParam2) => {
  JWKParam2[JWKParam2["kty"] = 1 /* KeyType */] = "kty";
  JWKParam2[JWKParam2["kid"] = 2 /* KeyID */] = "kid";
  JWKParam2[JWKParam2["alg"] = 3 /* Algorithm */] = "alg";
  JWKParam2[JWKParam2["key_ops"] = 4 /* KeyOps */] = "key_ops";
  JWKParam2[JWKParam2["base_iv"] = 5 /* BaseIV */] = "base_iv";
  JWKParam2[JWKParam2["crv"] = -1 /* Curve */] = "crv";
  JWKParam2[JWKParam2["x"] = -2 /* x */] = "x";
  JWKParam2[JWKParam2["y"] = -3 /* y */] = "y";
  JWKParam2[JWKParam2["d"] = -4 /* d */] = "d";
  JWKParam2[JWKParam2["k"] = -1 /* k */] = "k";
  return JWKParam2;
})(JWKParam || {});
var KTYSpecificJWKParams = {
  EC: /* @__PURE__ */ new Map([
    [-1, "crv"],
    [-2, "x"],
    [-3, "y"],
    [-4, "d"]
  ]),
  OKP: /* @__PURE__ */ new Map([
    [-1, "crv"],
    [-2, "x"],
    [-3, "y"],
    [-4, "d"]
  ]),
  oct: /* @__PURE__ */ new Map([[-1, "k"]])
};
var KTYSpecificJWKParamsRev = Object.fromEntries(
  // biome-ignore lint/style/noNonNullAssertion:
  Object.entries(KTYSpecificJWKParams).map(([k, v]) => [k, reverseMap(v)])
);

// src/cose/key/cose-key.ts
var toArray = (v) => Array.isArray(v) ? v : [v];
function normalize(input) {
  const encoded = input;
  if (encoded instanceof Uint8Array) {
    return uint8ArrayToString(encoded);
  }
  return encoded;
}
var JWKFromCOSEValue = new Map([
  ["kty", (value) => JWKKeyType[value]],
  ["crv", (value) => Curve[value]],
  ["alg", (value) => Algorithms[value]],
  ["kid", (v) => typeof v === "string" ? v : uint8ArrayToBase64Url(v)],
  ["key_ops", (v) => toArray(v).map((value) => JWKKeyOps.get(value))],
  ...["x", "y", "d", "k"].map((param) => [param, (v) => uint8ArrayToBase64Url(v)])
]);
var JWKToCOSEValue = new Map([
  ["kty", (value) => JWKKeyType[value]],
  ["crv", (value) => Curve[value]],
  ["alg", (value) => Algorithms[value]],
  ["kid", (v) => v],
  ["key_ops", (v) => toArray(v).flatMap((value) => JWKKeyOpsToCOSE.get(value))],
  ...["x", "y", "d", "k"].map((label) => [
    label,
    (v) => {
      const normalized = normalize(v);
      return base64UrlToUint8Array(normalized);
    }
  ])
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
]);
var COSEKey = class _COSEKey extends TypedMap {
  /**
   * Import a COSEKey either decoded as Map<number, unknown> or as an encoded CBOR.
   *
   * @param data {Uint8Array | Map<number, unknown>}
   * @returns
   */
  static import(data) {
    if (data instanceof Uint8Array) {
      return new _COSEKey(cborDecode(data));
    }
    return new _COSEKey(data);
  }
  /**
   *
   * Create a COSEKey from a JWK.
   *
   * @param jwk {JWK} - A JWK.
   * @returns
   */
  static fromJWK(jwk) {
    const coseKey = new _COSEKey();
    const kty = jwk.kty;
    for (const [key, value] of Object.entries(jwk)) {
      const jwkKey = KTYSpecificJWKParamsRev[kty]?.get(key) ?? JWKParam[key];
      const formatter = JWKToCOSEValue.get(key);
      if (jwkKey && formatter) {
        coseKey.set(jwkKey, formatter(value));
      }
    }
    return coseKey;
  }
  /**
   *
   * Returns a JWK representation of the COSEKey.
   *
   * @returns {JWK} - The JWK representation of the COSEKey.
   */
  toJWK() {
    const kty = JWKKeyType[this.get(1 /* KeyType */)];
    const result = { kty };
    for (const [key, value] of this) {
      const jwkKey = KTYSpecificJWKParams[kty]?.get(key) ?? JWKParam[key];
      const parser = JWKFromCOSEValue.get(jwkKey);
      if (parser && jwkKey) {
        const parsed = parser(value);
        result[jwkKey] = parsed;
      }
    }
    return result;
  }
  /**
   *
   * Encode the COSEKey as a CBOR buffer.
   *
   * @returns {Uint8Array} - The encoded COSEKey.
   */
  encode() {
    return cborEncode(this.esMap);
  }
};
var COSEKeyToRAW = (key) => {
  let decodedKey;
  if (key instanceof Uint8Array) {
    decodedKey = cborDecode(key);
  } else {
    decodedKey = key;
  }
  const kty = decodedKey.get(1);
  if (kty !== 2) {
    throw new Error(`Expected COSE Key type: EC2 (2), got: ${kty}`);
  }
  if (decodedKey.has(-4)) {
    return decodedKey.get(-4);
  }
  return concatUint8Array(Uint8Array.from([4]), decodedKey.get(-2), decodedKey.get(-3));
};

// src/mdoc/errors.ts
var MDLError = class extends Error {
  constructor(message) {
    super(message);
    this.name = new.target.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var MDLParseError = class extends Error {
  constructor(message) {
    super(message);
    this.name = new.target.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// src/mdoc/check-callback.ts
var defaultCallback = (verification) => {
  if (verification.status !== "FAILED") return;
  throw new MDLError(verification.reason ?? verification.check);
};
var onCatCheck = (onCheck, category) => {
  return (item) => {
    onCheck({ ...item, category });
  };
};

// src/mdoc/issuer-signed-item.ts
var MDL_NAMESPACE = "org.iso.18013.5.1";
var supportedDigestAlgorithms = ["SHA-256", "SHA-384", "SHA-512"];
var _dataItem, _isValid;
var _IssuerSignedItem = class _IssuerSignedItem {
  constructor(dataItem) {
    __privateAdd(this, _dataItem);
    __privateAdd(this, _isValid);
    __privateSet(this, _dataItem, dataItem);
  }
  encode() {
    return __privateGet(this, _dataItem).buffer;
  }
  get dataItem() {
    return __privateGet(this, _dataItem);
  }
  get decodedData() {
    if (!__privateGet(this, _dataItem).data.has("digestID")) {
      throw new Error("Invalid data item");
    }
    return __privateGet(this, _dataItem).data;
  }
  get digestID() {
    return this.decodedData.get("digestID");
  }
  get random() {
    return this.decodedData.get("random");
  }
  get elementIdentifier() {
    return this.decodedData.get("elementIdentifier");
  }
  get elementValue() {
    return this.decodedData.get("elementValue");
  }
  async calculateDigest(alg, ctx) {
    const bytes = cborEncode(__privateGet(this, _dataItem));
    const result = await ctx.crypto.digest({ digestAlgorithm: alg, bytes });
    return result;
  }
  async isValid(nameSpace, { decodedPayload: { valueDigests, digestAlgorithm } }, ctx) {
    if (typeof __privateGet(this, _isValid) !== "undefined") {
      return __privateGet(this, _isValid);
    }
    if (!supportedDigestAlgorithms.includes(digestAlgorithm)) {
      __privateSet(this, _isValid, false);
      return false;
    }
    const digest = await this.calculateDigest(digestAlgorithm, ctx);
    const digests = valueDigests?.get(nameSpace);
    if (typeof digests === "undefined") {
      return false;
    }
    const expectedDigest = digests.get(this.digestID);
    __privateSet(this, _isValid, expectedDigest && areEqualUint8Array(digest, expectedDigest));
    return Boolean(__privateGet(this, _isValid));
  }
  matchCertificate(nameSpace, issuerAuth, ctx) {
    if (nameSpace !== MDL_NAMESPACE) {
      return void 0;
    }
    const issuingCountry = issuerAuth.getIssuingCountry(ctx);
    const issuingStateOrProvince = issuerAuth.getIssuingStateOrProvince(ctx);
    if (this.elementIdentifier === "issuing_country") {
      return issuingCountry === this.elementValue;
    }
    if (this.elementIdentifier === "issuing_jurisdiction") {
      return issuingStateOrProvince === this.elementValue;
    }
    return void 0;
  }
  static create(digestID, elementIdentifier, elementValue, ctx) {
    const random = ctx.crypto.random(32);
    const dataItem = DataItem.fromData(
      /* @__PURE__ */ new Map([
        ["digestID", digestID],
        ["elementIdentifier", elementIdentifier],
        ["elementValue", elementValue],
        ["random", random]
      ])
    );
    return new _IssuerSignedItem(dataItem);
  }
};
_dataItem = new WeakMap();
_isValid = new WeakMap();
var IssuerSignedItem = _IssuerSignedItem;

// src/mdoc/items-request.ts
var _dataRecord, _dataItem2;
var _ItemsRequest = class _ItemsRequest {
  constructor(dataItem) {
    __privateAdd(this, _dataRecord);
    __privateAdd(this, _dataItem2);
    __privateSet(this, _dataItem2, dataItem);
  }
  get dataItem() {
    return __privateGet(this, _dataItem2);
  }
  get data() {
    if (!__privateGet(this, _dataRecord)) {
      __privateSet(this, _dataRecord, cborDecode(__privateGet(this, _dataItem2).buffer, {
        tagUint8Array: false,
        useRecords: true,
        mapsAsObjects: true
      }));
    }
    return __privateGet(this, _dataRecord);
  }
  static create(docType, nameSpaces, requestInfo) {
    const dataItem = DataItem.fromData({
      docType,
      nameSpaces,
      requestInfo
    });
    return new _ItemsRequest(dataItem);
  }
};
_dataRecord = new WeakMap();
_dataItem2 = new WeakMap();
var ItemsRequest = _ItemsRequest;

// src/mdoc/model/device-request.ts
var DeviceRequest = class _DeviceRequest {
  constructor(version, docRequests) {
    this.version = version;
    this.docRequests = docRequests;
  }
  static from(version, docRequests) {
    return new _DeviceRequest(
      version,
      docRequests.map((docRequest) => {
        return {
          ...docRequest,
          itemsRequest: ItemsRequest.create(
            docRequest.itemsRequestData.docType,
            docRequest.itemsRequestData.nameSpaces,
            docRequest.itemsRequestData.requestInfo
          )
        };
      })
    );
  }
  static parse(cbor) {
    const res = cborDecode(cbor, {
      tagUint8Array: false,
      useRecords: true,
      mapsAsObjects: true
      // biome-ignore lint/suspicious/noExplicitAny:
    });
    const { version, docRequests } = res;
    const parsedDocRequests = docRequests.map((docRequest) => {
      const itemsRequest = new ItemsRequest(docRequest.itemsRequest);
      return {
        ...docRequest,
        itemsRequest
      };
    });
    return new _DeviceRequest(version, parsedDocRequests);
  }
  static encodeDocRequest(r) {
    return /* @__PURE__ */ new Map([
      ["itemsRequest", r.itemsRequest.dataItem],
      ["readerAuth", r.readerAuth]
    ]);
  }
  encode() {
    return cborEncode({
      version: this.version,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      docRequests: this.docRequests.map(_DeviceRequest.encodeDocRequest)
    });
  }
};

// src/cose/cose-base.ts
var _encodedProtectedHeaders;
var COSEBase = class {
  constructor(protectedHeaders, unprotectedHeaders) {
    this.unprotectedHeaders = unprotectedHeaders;
    __privateAdd(this, _encodedProtectedHeaders);
    if (protectedHeaders instanceof Uint8Array) {
      __privateSet(this, _encodedProtectedHeaders, protectedHeaders);
      this.protectedHeaders = protectedHeaders.length === 0 ? /* @__PURE__ */ new Map() : cborDecodeUnknown(protectedHeaders);
    } else {
      this.protectedHeaders = protectedHeaders;
      __privateSet(this, _encodedProtectedHeaders, cborEncode(protectedHeaders));
    }
  }
  get encodedProtectedHeaders() {
    return __privateGet(this, _encodedProtectedHeaders);
  }
  encode() {
    return cborEncode(this);
  }
};
_encodedProtectedHeaders = new WeakMap();

// src/cose/e-cose.ts
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
var UnknownCauseError = class extends Error {
};
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type = typeof cause;
  if (type === "undefined" || type === "function" || cause === null) {
    return void 0;
  }
  if (type !== "object") {
    return new Error(String(cause));
  }
  if (isObject(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
var CoseError = class extends Error {
  constructor(opts) {
    const cause = getCauseFromUnknown(opts.cause);
    const message = opts.message ?? cause?.message ?? opts.code;
    super(message, { cause });
    this.code = opts.code;
    this.name = "CoseError";
    if (!this.cause) {
      this.cause = cause;
    }
  }
};

// src/cose/validate-algorithms.ts
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "number"))) {
    throw new TypeError(`"${option}" option must be an array of numbers`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
};

// src/cose/mac0.ts
var _Mac0 = class _Mac0 extends COSEBase {
  constructor(protectedHeaders, unprotectedHeaders, payload, _tag) {
    super(protectedHeaders, unprotectedHeaders);
    this.payload = payload;
    this._tag = _tag;
  }
  static createMAC0(protectedHeaders, applicationHeaders, payload) {
    return cborEncode(["MAC0", protectedHeaders, applicationHeaders, payload]);
  }
  getContentForEncoding() {
    return [this.encodedProtectedHeaders, this.unprotectedHeaders, this.payload, this.tag];
  }
  get tag() {
    if (!this._tag) {
      throw new Error("No signature present");
    }
    return this._tag;
  }
  set tag(sig) {
    this._tag = sig;
  }
  get alg() {
    return this.protectedHeaders.get(1 /* Algorithm */);
  }
  get algName() {
    return this.alg ? MacAlgorithmNames.get(this.alg) : void 0;
  }
  hasSupportedAlg() {
    return !!this.algName;
  }
  static create(protectedHeaders, unprotectedHeaders, payload, signature) {
    const wProtectedHeaders = MacProtectedHeaders.wrap(protectedHeaders);
    const mac0AlgName = wProtectedHeaders.get(1 /* Algorithm */);
    const alg = mac0AlgName ? MacAlgorithmNames.get(mac0AlgName) : void 0;
    if (!alg) {
      throw new CoseError({
        code: "COSE_INVALID_ALG",
        message: `The [${1 /* Algorithm */}] (Algorithm) header must be set.`
      });
    }
    const encodedProtectedHeaders = cborEncode(wProtectedHeaders.esMap);
    const wUnprotectedHeaders = UnprotectedHeaders.wrap(unprotectedHeaders);
    return new _Mac0(encodedProtectedHeaders, wUnprotectedHeaders.esMap, payload, signature);
  }
  getRawSigningData() {
    const algName = this.algName;
    if (!algName) {
      throw new CoseError({
        code: "COSE_INVALID_ALG",
        message: "Cannot get raw signing data. Mac alg is not defined"
      });
    }
    const toBeSigned = _Mac0.createMAC0(
      cborEncode(ProtectedHeaders.wrap(this.protectedHeaders).esMap),
      new Uint8Array(),
      this.payload
    );
    return { data: toBeSigned, alg: algName };
  }
  getRawVerificationData(options) {
    const mac0Structure = _Mac0.createMAC0(
      this.encodedProtectedHeaders ?? new Uint8Array(),
      options?.externalAAD ?? new Uint8Array(),
      options?.detachedPayload ?? this.payload
    );
    if (!this.alg || !this.algName || !MacAlgorithmNames.has(this.alg)) {
      throw new CoseError({
        code: "COSE_UNSUPPORTED_MAC",
        message: `Unsupported MAC algorithm '${this.alg}'`
      });
    }
    const algorithms = options && validateAlgorithms("algorithms", options.algorithms);
    if (algorithms && !algorithms.has(this.alg)) {
      throw new CoseError({
        code: "COSE_UNSUPPORTED_ALG",
        message: `[${1 /* Algorithm */}] (algorithm) Header Parameter not allowed`
      });
    }
    return {
      alg: this.algName,
      signature: this.tag,
      data: mac0Structure
    };
  }
};
_Mac0.tag = 17;
var Mac0 = _Mac0;
addExtension2({
  Class: Mac0,
  tag: Mac0.tag,
  encode(instance, encodeFn) {
    return encodeFn(instance.getContentForEncoding());
  },
  decode: (data) => {
    return new Mac0(data[0], data[1], data[2], data[3]);
  }
});

// src/cose/signature-base.ts
var SignatureBase = class extends COSEBase {
  constructor(protectedHeaders, unprotectedHeaders, _signature) {
    super(protectedHeaders, unprotectedHeaders);
    this._signature = _signature;
  }
  get signature() {
    if (!this._signature) {
      throw new Error("No signature present");
    }
    return this._signature;
  }
  set signature(sig) {
    this._signature = sig;
  }
  /**
      This parameter is used to indicate the algorithm used for the
      security processing.  This parameter MUST be authenticated where
      the ability to do so exists.  This support is provided by AEAD
      algorithms or construction (COSE_Sign, COSE_Sign0, COSE_Mac, and
      COSE_Mac0).  This authentication can be done either by placing the
      header in the protected header bucket or as part of the externally
      supplied data.  The value is taken from the "COSE Algorithms"
      registry (see Section 16.4).
   */
  get alg() {
    return this.protectedHeaders.get(1 /* Algorithm */) ?? this.unprotectedHeaders.get(1 /* Algorithm */);
  }
  get algName() {
    return this.alg ? AlgorithmNames.get(this.alg) : void 0;
  }
  /**
      This parameter identifies one piece of data that can be used as
      input to find the needed cryptographic key.  The value of this
      parameter can be matched against the 'kid' member in a COSE_Key
      structure.  Other methods of key distribution can define an
      equivalent field to be matched.  Applications MUST NOT assume that
      'kid' values are unique.  There may be more than one key with the
      same 'kid' value, so all of the keys associated with this 'kid'
      may need to be checked.  The internal structure of 'kid' values is
      not defined and cannot be relied on by applications.  Key
      identifier values are hints about which key to use.  This is not a
      security-critical field.  For this reason, it can be placed in the
      unprotected headers bucket.
   */
  get kid() {
    return this.protectedHeaders.get(4 /* KeyID */) ?? this.unprotectedHeaders.get(4 /* KeyID */);
  }
  get x5chain() {
    const x5chain = this.protectedHeaders.get(33 /* X5Chain */) ?? this.unprotectedHeaders.get(33 /* X5Chain */);
    if (!x5chain?.[0]) {
      return void 0;
    }
    return Array.isArray(x5chain) ? x5chain : [x5chain];
  }
  internalGetRawVerificationData(payload, options) {
    if (!this.alg || !this.algName || !AlgorithmNames.has(this.alg)) {
      throw new CoseError({
        code: "COSE_UNSUPPORTED_ALG",
        message: `Unsupported alg '${this.alg}'`
      });
    }
    const algorithms = options?.algorithms && validateAlgorithms("algorithms", options.algorithms);
    if (algorithms && !algorithms.has(this.alg)) {
      throw new CoseError({
        code: "COSE_INVALID_ALG",
        message: `[${1 /* Algorithm */}] (algorithm) Header Parameter not allowed`
      });
    }
    return {
      alg: this.algName,
      signature: this.signature,
      data: payload
    };
  }
};

// src/cose/sign1.ts
var _Sign1 = class _Sign1 extends SignatureBase {
  constructor(protectedHeaders, unprotectedHeaders, payload, _signature) {
    super(protectedHeaders, unprotectedHeaders, _signature);
    this.payload = payload;
  }
  getContentForEncoding() {
    return [this.encodedProtectedHeaders, this.unprotectedHeaders, this.payload, this.signature];
  }
  static Signature1(protectedHeaders, applicationHeaders, payload) {
    return cborEncode(["Signature1", protectedHeaders, applicationHeaders, payload]);
  }
  static create(protectedHeaders, unprotectedHeaders, payload, signature) {
    const wProtectedHeaders = ProtectedHeaders.wrap(protectedHeaders);
    const sig1AlgName = wProtectedHeaders.get(1 /* Algorithm */);
    const alg = sig1AlgName ? AlgorithmNames.get(sig1AlgName) : void 0;
    if (!alg) {
      throw new CoseError({
        code: "COSE_INVALID_ALG",
        message: `The [${1 /* Algorithm */}] (Algorithm) header must be set.`
      });
    }
    const encodedProtectedHeaders = cborEncode(wProtectedHeaders.esMap);
    const wUnprotectedHeaders = UnprotectedHeaders.wrap(unprotectedHeaders);
    return new _Sign1(encodedProtectedHeaders, wUnprotectedHeaders.esMap, payload, signature);
  }
  getRawSigningData() {
    const alg = this.algName;
    if (!alg) {
      throw new CoseError({
        code: "COSE_INVALID_ALG",
        message: "Cannot get raw signing data. Alg is not defined"
      });
    }
    const toBeSigned = _Sign1.Signature1(
      cborEncode(ProtectedHeaders.wrap(this.protectedHeaders).esMap),
      new Uint8Array(),
      this.payload
    );
    return {
      data: toBeSigned,
      alg
    };
  }
  getRawVerificationData(options) {
    const toBeSigned = _Sign1.Signature1(
      this.encodedProtectedHeaders ?? new Uint8Array(),
      options?.externalAAD ?? new Uint8Array(),
      options?.detachedPayload ?? this.payload
    );
    return this.internalGetRawVerificationData(toBeSigned);
  }
};
_Sign1.tag = 18;
var Sign1 = _Sign1;
addExtension2({
  Class: Sign1,
  tag: Sign1.tag,
  encode(instance, encodeFn) {
    return encodeFn(instance.getContentForEncoding());
  },
  decode: (data) => {
    return new Sign1(data[0], data[1], data[2], data[3]);
  }
});

// src/mdoc/parser.ts
import { compareVersions } from "compare-versions";

// src/mdoc/model/issuer-signed-document.ts
var IssuerSignedDocument = class {
  constructor(docType, issuerSigned) {
    this.docType = docType;
    this.issuerSigned = issuerSigned;
  }
  /**
   * Create the structure for encoding a document.
   *
   * @returns {Map<string, unknown>} - The document as a map
   */
  prepare() {
    const nameSpaces = new Map(
      Object.entries(this.issuerSigned.nameSpaces).map(([nameSpace, items]) => {
        return [nameSpace, items.map((item) => item.dataItem)];
      })
    );
    const docMap = new Map(
      Object.entries({
        docType: this.docType,
        issuerSigned: {
          nameSpaces,
          issuerAuth: this.issuerSigned.issuerAuth.getContentForEncoding()
        }
      })
    );
    return docMap;
  }
  /**
   * Helper method to get the values in a namespace as a JS object.
   *
   * @param {string} namespace - The namespace to add.
   * @returns {Record<string, unknown>} - The values in the namespace as an object
   */
  getIssuerNameSpace(namespace) {
    const nameSpace = this.issuerSigned.nameSpaces[namespace];
    if (!nameSpace) return void 0;
    return Object.fromEntries(nameSpace.map((item) => [item.elementIdentifier, item.elementValue]));
  }
  /**
   * List of namespaces in the document.
   */
  get issuerSignedNameSpaces() {
    return Object.keys(this.issuerSigned.nameSpaces);
  }
  get allIssuerSignedNamespaces() {
    const namespaces = this.issuerSignedNameSpaces;
    return Object.fromEntries(
      namespaces.map((namespace) => {
        const namespaceValues = this.getIssuerNameSpace(namespace);
        if (!namespaceValues) {
          throw new Error(`Cannot extract the namespace '${namespace}' from the mdoc.`);
        }
        return [namespace, namespaceValues];
      })
    );
  }
};

// src/mdoc/model/device-signed-document.ts
var DeviceSignedDocument = class extends IssuerSignedDocument {
  constructor(docType, issuerSigned, deviceSigned) {
    super(docType, issuerSigned);
    this.deviceSigned = deviceSigned;
  }
  prepare() {
    const doc = super.prepare();
    const deviceSignature = this.deviceSigned.deviceAuth.deviceSignature?.getContentForEncoding();
    const deviceMac = this.deviceSigned.deviceAuth.deviceMac?.getContentForEncoding();
    if (deviceMac) {
      deviceMac[2] = void 0;
    }
    if (deviceSignature) {
      deviceSignature[2] = void 0;
    }
    doc.set("deviceSigned", {
      ...this.deviceSigned,
      nameSpaces: DataItem.fromData(this.deviceSigned.nameSpaces),
      // TODO: ERRORS MISSING
      deviceAuth: {
        ...this.deviceSigned.deviceAuth,
        deviceSignature,
        deviceMac
      }
    });
    return doc;
  }
  /**
   * Helper method to get the values in a namespace as a JS object.
   *
   * @param {string} namespace - The namespace to add.
   * @returns {Record<string, unknown>} - The values in the namespace as an object
   */
  getDeviceNameSpace(namespace) {
    return this.deviceSigned.nameSpaces[namespace];
  }
  /**
   * List of namespaces in the document.
   */
  get deviceSignedNameSpaces() {
    return Object.keys(this.deviceSigned.nameSpaces);
  }
  get allDeviceSignedNamespaces() {
    const namespaces = this.deviceSignedNameSpaces;
    return Object.fromEntries(
      namespaces.map((namespace) => {
        const namespaceValues = this.getDeviceNameSpace(namespace);
        if (!namespaceValues) {
          throw new Error(`Cannot extract the namespace '${namespace}' from the mdoc.`);
        }
        return [namespace, namespaceValues];
      })
    );
  }
};

// src/mdoc/model/issuer-auth.ts
var _decodedPayload, _x5chain;
var _IssuerAuth = class _IssuerAuth extends Sign1 {
  constructor() {
    super(...arguments);
    __privateAdd(this, _decodedPayload);
    __privateAdd(this, _x5chain);
  }
  get decodedPayload() {
    if (__privateGet(this, _decodedPayload)) {
      return __privateGet(this, _decodedPayload);
    }
    let decoded = cborDecode(this.payload);
    decoded = decoded instanceof DataItem ? decoded.data : decoded;
    decoded = Object.fromEntries(decoded);
    const mapValidityInfo = (validityInfo) => {
      if (!validityInfo) {
        return validityInfo;
      }
      return Object.fromEntries(
        [...validityInfo.entries()].map(([key, value]) => {
          return [key, value instanceof Uint8Array ? cborDecode(value) : value];
        })
      );
    };
    const result = {
      ...decoded,
      validityInfo: mapValidityInfo(decoded.validityInfo),
      validityDigests: decoded.validityDigests ? Object.fromEntries(decoded.validityDigests) : void 0,
      deviceKeyInfo: decoded.deviceKeyInfo ? Object.fromEntries(decoded.deviceKeyInfo) : void 0
    };
    __privateSet(this, _decodedPayload, result);
    return result;
  }
  get certificateChain() {
    if (__privateGet(this, _x5chain)) return __privateGet(this, _x5chain);
    __privateSet(this, _x5chain, this.x5chain);
    if (!__privateGet(this, _x5chain)) {
      throw new Error("No certificate found");
    }
    return __privateGet(this, _x5chain);
  }
  get certificate() {
    return this.certificateChain[0];
  }
  getIssuingCountry(ctx) {
    const countryName = ctx.x509.getIssuerNameField({
      certificate: this.certificate,
      field: "C"
    })[0];
    return countryName;
  }
  getIssuingStateOrProvince(ctx) {
    const stateOrProvince = ctx.x509.getIssuerNameField({
      certificate: this.certificate,
      field: "ST"
    })[0];
    return stateOrProvince;
  }
  static create(protectedHeaders, unprotectedHeaders, payload) {
    const sign1 = Sign1.create(protectedHeaders, unprotectedHeaders, payload);
    return new _IssuerAuth(sign1.protectedHeaders, sign1.unprotectedHeaders, sign1.payload);
  }
};
_decodedPayload = new WeakMap();
_x5chain = new WeakMap();
var IssuerAuth = _IssuerAuth;

// src/mdoc/model/mdoc.ts
var MDocStatus = /* @__PURE__ */ ((MDocStatus2) => {
  MDocStatus2[MDocStatus2["OK"] = 0] = "OK";
  MDocStatus2[MDocStatus2["GeneralError"] = 10] = "GeneralError";
  MDocStatus2[MDocStatus2["CBORDecodingError"] = 11] = "CBORDecodingError";
  MDocStatus2[MDocStatus2["CBORValidationError"] = 12] = "CBORValidationError";
  return MDocStatus2;
})(MDocStatus || {});
var MDoc = class {
  constructor(documents = [], version = "1.0", status = 0 /* OK */, documentErrors = []) {
    this.documents = documents;
    this.version = version;
    this.status = status;
    this.documentErrors = documentErrors;
  }
  addDocument(document) {
    if (typeof document.issuerSigned === "undefined") {
      throw new Error("Cannot add an unsigned document");
    }
    this.documents.push(document);
  }
  encode() {
    return cborEncode({
      version: this.version,
      documents: this.documents.map((doc) => doc.prepare()),
      status: this.status
    });
  }
};

// src/mdoc/parser.ts
var parseIssuerAuthElement = (rawIssuerAuth, expectedDocType) => {
  const issuerAuth = new IssuerAuth(...rawIssuerAuth);
  const { decodedPayload } = issuerAuth;
  const { docType, version } = decodedPayload;
  if (expectedDocType && docType !== expectedDocType) {
    throw new MDLParseError(`The issuerAuth docType must be ${expectedDocType}`);
  }
  if (!version || compareVersions(version, "1.0") !== 0) {
    throw new MDLParseError("The issuerAuth version must be '1.0'");
  }
  return issuerAuth;
};
var parseDeviceAuthElement = (rawDeviceAuth) => {
  const { deviceSignature, deviceMac } = Object.fromEntries(rawDeviceAuth);
  if (deviceSignature) {
    return { deviceSignature: new Sign1(...deviceSignature) };
  }
  if (deviceMac) {
    return { deviceMac: new Mac0(...deviceMac) };
  }
  throw new MDLParseError(`Invalid deviceAuth element. Missing 'deviceSignature' and 'deviceMac'`);
};
var namespaceToArray = (entries) => {
  return entries.map((di) => new IssuerSignedItem(di));
};
var mapIssuerNameSpaces = (namespace) => {
  return Array.from(namespace.entries()).reduce((prev, [nameSpace, entries]) => {
    const mappedNamespace = namespaceToArray(entries);
    return {
      ...prev,
      [nameSpace]: mappedNamespace
    };
  }, {});
};
var mapDeviceNameSpaces = (namespace) => {
  const entries = Array.from(namespace.entries()).map(([ns, attrs]) => {
    return [ns, Object.fromEntries(attrs.entries())];
  });
  return Object.fromEntries(entries);
};
var parseIssuerSigned = (issuerSigned, expectedDocType) => {
  let issuerSignedDecoded;
  try {
    issuerSignedDecoded = issuerSigned instanceof Map ? issuerSigned : cborDecode(issuerSigned);
  } catch (err) {
    throw new MDLParseError(
      `Unable to decode issuer signed document: ${err instanceof Error ? err.message : "Unknown error"}`
    );
  }
  const issuerAuth = parseIssuerAuthElement(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    issuerSignedDecoded.get("issuerAuth"),
    expectedDocType
  );
  const parsedIssuerSigned = {
    ...issuerSignedDecoded,
    nameSpaces: mapIssuerNameSpaces(
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      issuerSignedDecoded.get("nameSpaces")
    ),
    issuerAuth
  };
  return new IssuerSignedDocument(issuerAuth.decodedPayload.docType, parsedIssuerSigned);
};
var parseDeviceSigned = (deviceSigned, issuerSigned, expectedDocType) => {
  let deviceSignedDecoded;
  try {
    deviceSignedDecoded = deviceSigned instanceof Map ? deviceSigned : cborDecode(deviceSigned);
  } catch (err) {
    throw new MDLParseError(
      `Unable to decode device signed document : ${err instanceof Error ? err.message : "Unknown error"}`
    );
  }
  const deviceSignedParsed = {
    ...deviceSignedDecoded,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
    nameSpaces: mapDeviceNameSpaces(deviceSignedDecoded.get("nameSpaces").data),
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    deviceAuth: parseDeviceAuthElement(deviceSignedDecoded.get("deviceAuth"))
  };
  const issuerSignedDocument = parseIssuerSigned(issuerSigned, expectedDocType);
  return new DeviceSignedDocument(issuerSignedDocument.docType, issuerSignedDocument.issuerSigned, deviceSignedParsed);
};
var parseDeviceResponse = (encoded) => {
  let deviceResponse;
  try {
    deviceResponse = cborDecode(encoded);
  } catch (err) {
    throw new MDLParseError(`Unable to decode device response: ${err instanceof Error ? err.message : "Unknown error"}`);
  }
  const { version, documents, status } = Object.fromEntries(deviceResponse);
  const parsedDocuments = documents.map((doc) => {
    const docType = doc.get("docType");
    const issuerSigned = doc.get("issuerSigned");
    const deviceSigned = doc.get("deviceSigned");
    if (deviceSigned) {
      return parseDeviceSigned(deviceSigned, issuerSigned, docType);
    }
    return parseIssuerSigned(issuerSigned, docType);
  });
  return new MDoc(parsedDocuments, version, status);
};

// src/mdoc/utils.ts
var calculateDeviceAutenticationBytes = (sessionTranscript, docType, nameSpaces) => {
  let decodedSessionTranscript;
  if (sessionTranscript instanceof Uint8Array) {
    decodedSessionTranscript = cborDecode(sessionTranscript).data;
  } else {
    decodedSessionTranscript = sessionTranscript;
  }
  const nameSpacesAsMap = new Map(Object.entries(nameSpaces).map(([ns, items]) => [ns, new Map(Object.entries(items))]));
  const encode2 = DataItem.fromData([
    "DeviceAuthentication",
    decodedSessionTranscript,
    docType,
    DataItem.fromData(nameSpacesAsMap)
  ]);
  const result = cborEncode(encode2);
  return result;
};
function fromPEM(pem) {
  const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/gm, "").replace(/\s/gm, "");
  return base64ToUint8Array(base64);
}

// src/mdoc/model/pex-limit-disclosure.ts
var limitDisclosureToDeviceRequestNameSpaces = (mdoc, deviceRequestNameSpaces) => {
  const nameSpaces = {};
  for (const [nameSpace, nameSpaceFields] of Object.entries(deviceRequestNameSpaces)) {
    const nsAttrs = mdoc.issuerSigned.nameSpaces[nameSpace] ?? [];
    const digests = Object.entries(nameSpaceFields).map(([elementIdentifier, _]) => {
      const digest = prepareDigest(elementIdentifier, nsAttrs);
      if (!digest) {
        throw new Error(`No matching field found for '${elementIdentifier}'`);
      }
      return digest;
    });
    nameSpaces[nameSpace] = digests;
  }
  return nameSpaces;
};
var prepareDigest = (elementIdentifier, nsAttrs) => {
  if (elementIdentifier.startsWith("age_over_")) {
    const digest2 = handleAgeOverNN(elementIdentifier, nsAttrs);
    return digest2;
  }
  const digest = nsAttrs.find((d) => d.elementIdentifier === elementIdentifier);
  return digest ?? null;
};
var prepareDigestForInputDescriptor = (paths, issuerNameSpaces) => {
  for (const path of paths) {
    const { nameSpace, elementIdentifier } = parsePath(path);
    const nsAttrs = issuerNameSpaces[nameSpace] ?? [];
    const digest = prepareDigest(elementIdentifier, nsAttrs);
    if (digest) return { nameSpace, digest };
  }
  return null;
};
var parsePath = (path) => {
  const matches = [...path.matchAll(/\['(.*?)'\]/g)];
  if (matches.length !== 2) {
    throw new Error(`Invalid path format: "${path}"`);
  }
  const [nameSpaceMatch, elementIdentifierMatch] = matches;
  const nameSpace = nameSpaceMatch?.[1];
  const elementIdentifier = elementIdentifierMatch?.[1];
  if (!nameSpace || !elementIdentifier) {
    throw new Error(`Failed to parse path: "${path}"`);
  }
  return { nameSpace, elementIdentifier };
};
var handleAgeOverNN = (request, attributes) => {
  const ageOverList = attributes.map((a, i) => {
    const { elementIdentifier: key, elementValue: value } = a;
    return { key, value, index: i };
  }).filter((i) => i.key.startsWith("age_over_")).map((i) => ({
    nn: Number.parseInt(i.key.replace("age_over_", ""), 10),
    ...i
  })).sort((a, b) => a.nn - b.nn);
  const reqNN = Number.parseInt(request.replace("age_over_", ""), 10);
  let item;
  item = ageOverList.find((i) => i.value === true && i.nn >= reqNN);
  if (!item) {
    item = ageOverList.sort((a, b) => b.nn - a.nn).find((i) => i.value === false && i.nn <= reqNN);
  }
  if (!item) {
    return null;
  }
  return attributes[item.index];
};
var findMdocMatchingDocType = (mdoc, docType) => {
  const matchingMdoc = mdoc.documents.filter((document) => document.docType === docType);
  if (!matchingMdoc[0]) {
    throw new Error(`Cannot limit the disclosure. No credential is matching the requested DocType '${docType}'`);
  }
  if (matchingMdoc.length > 1) {
    throw new Error(`Cannot limit the disclosure. Multiple credentials are matching the requested DocType '${docType}'`);
  }
  return matchingMdoc[0];
};
var limitDisclosureToInputDescriptor = (mdoc, inputDescriptor) => {
  const nameSpaces = {};
  for (const field of inputDescriptor.constraints.fields) {
    const result = prepareDigestForInputDescriptor(field.path, mdoc.issuerSigned.nameSpaces);
    if (!result) {
      throw new Error(
        `Cannot limit the disclosure to the input descriptor. No matching field found for '${field.path.join(".")}'`
      );
    }
    const { nameSpace, digest } = result;
    if (!nameSpaces[nameSpace]) nameSpaces[nameSpace] = [];
    nameSpaces[nameSpace].push(digest);
  }
  return nameSpaces;
};

// src/mdoc/model/device-response.ts
var DeviceResponse = class _DeviceResponse {
  constructor(mdoc) {
    this.useMac = true;
    this.nameSpaces = {};
    this.mdoc = mdoc;
  }
  /**
   * Create a DeviceResponse builder.
   *
   * @param {MDoc | Uint8Array} mdoc - The mdoc to use as a base for the device response.
   *                                   It can be either a parsed MDoc or a CBOR encoded MDoc.
   * @returns {DeviceResponse} - A DeviceResponse builder.
   */
  static from(mdoc) {
    if (mdoc instanceof Uint8Array) {
      return new _DeviceResponse(parseDeviceResponse(mdoc));
    }
    return new _DeviceResponse(mdoc);
  }
  /**
   *
   * @param pd - The presentation definition to use for the device response.
   * @returns {DeviceResponse}
   */
  usingPresentationDefinition(pd) {
    if (!pd.input_descriptors.length) {
      throw new Error("The Presentation Definition must have at least one Input Descriptor object.");
    }
    const hasDuplicates = pd.input_descriptors.some(
      (id1, idx) => pd.input_descriptors.findIndex((id2) => id2.id === id1.id) !== idx
    );
    if (hasDuplicates) {
      throw new Error("Each Input Descriptor object must have a unique id property.");
    }
    this.pd = pd;
    return this;
  }
  /**
   *
   * @param deviceRequest - The device request
   * @returns {DeviceResponse}
   */
  usingDeviceRequest(deviceRequest) {
    if (!deviceRequest.docRequests.length) {
      throw new Error("The deviceRequest must have at least one docRequest object.");
    }
    this.deviceRequest = deviceRequest;
    return this;
  }
  /**
   * Set the session transcript data to use for the device response.
   *
   * This is arbitrary and should match the session transcript as it will be calculated by the verifier.
   * The transcript must be a CBOR encoded DataItem of an array, there is no further requirement.
   *
   * Example: `usingSessionTranscriptBytes(cborEncode(DataItem.fromData([a,b,c])))` where `a`, `b` and `c` can be anything including `null`.
   *
   * It is preferable to use {@link usingSessionTranscriptForOID4VP} or {@link usingSessionTranscriptForWebAPI} when possible.
   *
   * @param {Uint8Array} sessionTranscriptBytes - The sessionTranscriptBytes data to use in the session transcript.
   * @returns {DeviceResponse}
   */
  usingSessionTranscriptBytes(sessionTranscriptBytes) {
    if (this.sessionTranscriptBytes) {
      throw new Error(
        "A session transcript has already been set, either with .usingSessionTranscriptForOID4VP, .usingSessionTranscriptForWebAPI or .usingSessionTranscriptBytes"
      );
    }
    this.sessionTranscriptBytes = sessionTranscriptBytes;
    return this;
  }
  /**
   * Set the session transcript data to use for the device response as defined in ISO/IEC 18013-7 in Annex B (OID4VP), 2023 draft.
   *
   * This should match the session transcript as it will be calculated by the verifier.
   *
   * @param {string} mdocGeneratedNonce - A cryptographically random number with sufficient entropy.
   * @param {string} clientId - The client_id Authorization Request parameter from the Authorization Request Object.
   * @param {string} responseUri - The response_uri Authorization Request parameter from the Authorization Request Object.
   * @param {string} verifierGeneratedNonce - The nonce Authorization Request parameter from the Authorization Request Object.
   * @returns {DeviceResponse}
   */
  usingSessionTranscriptForOID4VP(input) {
    const bytes = _DeviceResponse.calculateSessionTranscriptForOID4VP(input);
    this.usingSessionTranscriptBytes(bytes);
    return this;
  }
  static calculateSessionTranscriptForOID4VP(input) {
    const { mdocGeneratedNonce, clientId, responseUri, verifierGeneratedNonce } = input;
    return cborEncode(
      DataItem.fromData([
        null,
        // deviceEngagementBytes
        null,
        // eReaderKeyBytes
        [mdocGeneratedNonce, clientId, responseUri, verifierGeneratedNonce]
      ])
    );
  }
  /**
   * Set the session transcript data to use for the device response as defined in ISO/IEC 18013-7 in Annex A (Web API), 2023 draft.
   *
   * This should match the session transcript as it will be calculated by the verifier.
   *
   * @param {Uint8Array} deviceEngagementBytes - The device engagement, encoded as a Tagged 24 cbor
   * @param {Uint8Array} readerEngagementBytes - The reader engagement, encoded as a Tagged 24 cbor
   * @param {Uint8Array} eReaderKeyBytes - The reader ephemeral public key as a COSE Key, encoded as a Tagged 24 cbor
   * @returns {DeviceResponse}
   */
  usingSessionTranscriptForWebAPI(input) {
    const bytes = _DeviceResponse.calculateSessionTranscriptForWebApi(input);
    this.usingSessionTranscriptBytes(bytes);
    return this;
  }
  static calculateSessionTranscriptForWebApi(input) {
    const { deviceEngagementBytes, eReaderKeyBytes, readerEngagementBytes } = input;
    return cborEncode(
      DataItem.fromData([
        new DataItem({ buffer: deviceEngagementBytes }),
        new DataItem({ buffer: eReaderKeyBytes }),
        readerEngagementBytes
      ])
    );
  }
  /**
   * Add a namespace to the device response.
   *
   * @param {string} nameSpace - The name space to add to the device response.
   * @param {Record<string, any>} data - The data to add to the name space.
   * @returns {DeviceResponse}
   */
  addDeviceNameSpace(nameSpace, data) {
    this.nameSpaces[nameSpace] = data;
    return this;
  }
  /**
   * Set the device's private key to be used for signing the device response.
   *
   * @param  {JWK} devicePrivateKey - The device's private key either as a JWK or a COSEKey.
   * @param  {SupportedAlgs} alg - The algorithm to use for signing the device response.
   * @returns {DeviceResponse}
   */
  authenticateWithSignature(devicePrivateKey, alg) {
    this.devicePrivateKey = devicePrivateKey;
    this.alg = alg;
    this.useMac = false;
    return this;
  }
  /**
   * Set the reader shared key to be used for signing the device response with MAC.
   *
   * @param  {JWK} devicePrivateKey - The device's private key either as a JWK or a COSEKey.
   * @param  {JWK} ephemeralPublicKey - The public part of the ephemeral key generated by the MDOC.
   * @param  {SupportedAlgs} alg - The algorithm to use for signing the device response.
   * @returns {DeviceResponse}
   */
  authenticateWithMAC(devicePrivateKey, ephemeralPublicKey, alg) {
    this.devicePrivateKey = devicePrivateKey;
    this.ephemeralPublicKey = ephemeralPublicKey;
    this.macAlg = alg;
    this.useMac = true;
    return this;
  }
  /**
   * Sign the device response and return the MDoc.
   *
   * @returns {Promise<MDoc>} - The device response as an MDoc.
   */
  async sign(ctx) {
    const requests = this.pd?.input_descriptors ?? this.deviceRequest?.docRequests;
    if (!requests) {
      throw new Error(
        "Must provide a presentation definition or device request with .usingPresentationDefinition() or .usingDeviceRequest()"
      );
    }
    if (!this.sessionTranscriptBytes) {
      throw new Error(
        "Must provide the session transcript with either .usingSessionTranscriptForOID4VP, .usingSessionTranscriptForWebAPI or .usingSessionTranscriptBytes"
      );
    }
    const limitedDeviceSignedDocuments = await Promise.all(
      requests.map(async (request) => {
        const isDeviceRequest = (r) => "itemsRequest" in request;
        let mdoc;
        let disclosedNameSpaces;
        if (isDeviceRequest(request)) {
          const docType = request.itemsRequest.data.docType;
          mdoc = findMdocMatchingDocType(this.mdoc, docType);
          disclosedNameSpaces = limitDisclosureToDeviceRequestNameSpaces(mdoc, request.itemsRequest.data.nameSpaces);
        } else {
          mdoc = findMdocMatchingDocType(this.mdoc, request.id);
          disclosedNameSpaces = limitDisclosureToInputDescriptor(mdoc, request);
        }
        return new DeviceSignedDocument(
          mdoc.docType,
          {
            nameSpaces: disclosedNameSpaces,
            issuerAuth: mdoc.issuerSigned.issuerAuth
          },
          await this.getDeviceSigned(mdoc.docType, ctx)
        );
      })
    );
    return new MDoc(limitedDeviceSignedDocuments);
  }
  async getDeviceSigned(docType, ctx) {
    const deviceAuthenticationBytes = calculateDeviceAutenticationBytes(
      this.sessionTranscriptBytes,
      docType,
      this.nameSpaces
    );
    let deviceAuth;
    if (this.useMac) {
      if (!this.sessionTranscriptBytes) {
        throw new Error("Missing sessionTranscriptBytes for getDeviceSigned");
      }
      deviceAuth = await this.getDeviceAuthMac(deviceAuthenticationBytes, this.sessionTranscriptBytes, ctx);
    } else {
      deviceAuth = await this.getDeviceAuthSign(deviceAuthenticationBytes, ctx);
    }
    const deviceSigned = {
      nameSpaces: this.nameSpaces,
      deviceAuth
    };
    return deviceSigned;
  }
  async getDeviceAuthMac(deviceAuthenticationBytes, sessionTranscriptBytes, ctx) {
    if (!this.devicePrivateKey) {
      throw new Error("Missing devicePrivateKey for getDeviceAuthMac");
    }
    if (!this.ephemeralPublicKey) {
      throw new Error("Missing ephemeralPublicKey for getDeviceAuthMac");
    }
    const { kid } = this.devicePrivateKey;
    const ephemeralMacKeyJwk = await ctx.crypto.calculateEphemeralMacKeyJwk({
      privateKey: COSEKeyToRAW(COSEKey.fromJWK(this.devicePrivateKey).encode()),
      publicKey: COSEKeyToRAW(COSEKey.fromJWK(this.ephemeralPublicKey).encode()),
      sessionTranscriptBytes
    });
    if (!this.macAlg) throw new Error("Missing macAlg");
    const protectedHeaders = MacProtectedHeaders.from([[1 /* Algorithm */, MacAlgorithms[this.macAlg]]]);
    const unprotectedHeaders = kid ? UnprotectedHeaders.from([[4 /* KeyID */, stringToUint8Array(kid)]]) : void 0;
    const mac0 = Mac0.create(protectedHeaders, unprotectedHeaders, deviceAuthenticationBytes, void 0);
    const tag = await ctx.cose.mac0.sign({ mac0, jwk: ephemeralMacKeyJwk });
    mac0.tag = tag;
    return { deviceMac: mac0 };
  }
  async getDeviceAuthSign(cborData, ctx) {
    if (!this.devicePrivateKey) throw new Error("Missing devicePrivateKey");
    if (!this.alg) {
      throw new Error("The alg header must be set.");
    }
    const { kid } = this.devicePrivateKey;
    const unprotectedHeaders = kid ? UnprotectedHeaders.from([[4 /* KeyID */, stringToUint8Array(kid)]]) : void 0;
    const sign1 = Sign1.create(
      ProtectedHeaders.from([[1 /* Algorithm */, Algorithms[this.alg]]]),
      unprotectedHeaders,
      cborData
    );
    const signature = await ctx.cose.sign1.sign({
      sign1,
      jwk: this.devicePrivateKey
    });
    sign1.signature = signature;
    return { deviceSignature: sign1 };
  }
};

// src/mdoc/model/document.ts
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var DEFAULT_NS = "org.iso.18013.5.1";
var getAgeInYears = (birth) => {
  const birthDate = new Date(birth);
  birthDate.setHours(0, 0, 0, 0);
  const ageDifMs = Date.now() - birthDate;
  const ageDate = new Date(ageDifMs);
  return Math.abs(ageDate.getUTCFullYear() - 1970);
};
var addYears = (date, years) => {
  const r = new Date(date.getTime());
  r.setFullYear(date.getFullYear() + years);
  return r;
};
var _issuerNameSpaces, _deviceKeyInfo, _validityInfo, _digestAlgorithm;
var Document = class {
  constructor(doc, ctx) {
    __privateAdd(this, _issuerNameSpaces, {});
    __privateAdd(this, _deviceKeyInfo);
    __privateAdd(this, _validityInfo, {
      signed: /* @__PURE__ */ new Date(),
      validFrom: /* @__PURE__ */ new Date(),
      validUntil: addYears(/* @__PURE__ */ new Date(), 1),
      expectedUpdate: void 0
    });
    __privateAdd(this, _digestAlgorithm, "SHA-256");
    this.docType = doc;
    this.ctx = ctx;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  validateValues(values) {
  }
  /**
   * Add a namespace to an unsigned document.
   *
   * @param {string} namespace - The namespace to add.
   * @param {Record<string, any>} values - The values to add to the namespace.
   * @returns {Document} - The document
   */
  addIssuerNameSpace(namespace, values) {
    if (namespace === DEFAULT_NS) {
      this.validateValues(values);
    }
    const namespaceRecord = __privateGet(this, _issuerNameSpaces)[namespace] ?? [];
    const addAttribute = (key, value) => {
      let elementValue = value;
      if (namespace === DEFAULT_NS) {
        if (["birth_date", "issue_date", "expiry_date"].includes(key) && typeof elementValue === "string") {
          elementValue = new DateOnly(elementValue);
        }
        if (key === "driving_privileges" && Array.isArray(elementValue)) {
          elementValue.forEach((v, i) => {
            if (isObject2(v) && typeof v.issue_date === "string") {
              elementValue[i].issue_date = new DateOnly(v.issue_date);
            }
            if (isObject2(v) && typeof v.expiry_date === "string") {
              elementValue[i].expiry_date = new DateOnly(v.expiry_date);
            }
          });
        }
      }
      const digestID = namespaceRecord.length;
      const issuerSignedItem = IssuerSignedItem.create(digestID, key, value, this.ctx);
      namespaceRecord.push(issuerSignedItem);
    };
    for (const [key, value] of Object.entries(values)) {
      addAttribute(key, value);
      if (this.docType === "org.iso.18013.5.1.mDL" && key === "birth_date") {
        if (typeof value !== "string") {
          throw new Error(`Invalid type for 'birth_date'. Expected 'string', received '${typeof value}'`);
        }
        const ageInYears = getAgeInYears(value);
        addAttribute("age_over_21", ageInYears >= 21);
        addAttribute(`age_over_${Math.floor(ageInYears)}`, true);
      }
    }
    __privateGet(this, _issuerNameSpaces)[namespace] = namespaceRecord;
    return this;
  }
  /**
   * Get the values in a namespace.
   *
   * @param {string} namespace - The namespace to add.
   * @returns {Record<string, any>} - The values in the namespace as an object
   */
  getIssuerNameSpace(namespace) {
    const nameSpace = __privateGet(this, _issuerNameSpaces)[namespace];
    if (!nameSpace) return void 0;
    return Object.fromEntries(nameSpace.map((item) => [item.elementIdentifier, item.elementValue]));
  }
  /**
   * Add the device public key which will be include in the issuer signature.
   * The device public key could be in JWK format or as COSE_Key format.
   *
   * @param params
   * @param {JWK | Uint8Array} params.devicePublicKey - The device public key.
   */
  addDeviceKeyInfo({ deviceKey }) {
    const deviceKeyCOSEKey = deviceKey instanceof Uint8Array ? deviceKey : COSEKey.fromJWK(deviceKey).encode();
    const decodedCoseKey = cborDecode(deviceKeyCOSEKey);
    __privateSet(this, _deviceKeyInfo, {
      deviceKey: decodedCoseKey
    });
    return this;
  }
  /**
   * Add validity info to the document that will be used in the issuer signature.
   *
   * @param info - the validity info
   * @param {Date} [info.signed] - The date the document is signed. default: now
   * @param {Date} [info.validFrom] - The date the document is valid from. default: signed
   * @param {Date} [info.validUntil] - The date the document is valid until. default: signed + 1 year
   * @param {Date} [info.expectedUpdate] - The date the document is expected to be updated. default: null
   * @returns
   */
  addValidityInfo(info = {}) {
    const signed = info.signed ?? /* @__PURE__ */ new Date();
    const validFrom = info.validFrom ?? signed;
    const validUntil = info.validUntil ?? addYears(signed, 1);
    __privateSet(this, _validityInfo, {
      signed,
      validFrom,
      validUntil,
      expectedUpdate: info.expectedUpdate
    });
    return this;
  }
  /**
   * Set the digest algorithm used for the value digests in the issuer signature.
   *
   * The default is SHA-256.
   *
   * @param {DigestAlgorithm} digestAlgorithm - The digest algorithm to use.
   * @returns
   */
  useDigestAlgorithm(digestAlgorithm) {
    __privateSet(this, _digestAlgorithm, digestAlgorithm);
    return this;
  }
  /**
   * Generate the issuer signature for the document.
   *
   * @param {Object} params - The parameters object
   * @param {JWK | Uint8Array} params.issuerPrivateKey - The issuer's private key either in JWK format or COSE_KEY format as buffer.
   * @param {string | Uint8Array} params.issuerCertificate - The issuer's certificate in pem format or as a buffer.
   * @param {SupportedAlgs} params.alg - The algorhitm used for the MSO signature.
   * @param {string | Uint8Array} [params.kid] - The key id of the issuer's private key. default: issuerPrivateKey.kid
   * @returns {Promise<IssuerSignedDoc>} - The signed document
   */
  async sign(params, ctx) {
    if (!__privateGet(this, _issuerNameSpaces)) {
      throw new Error("No namespaces added");
    }
    const issuerPublicKeyBuffer = typeof params.issuerCertificate === "string" ? fromPEM(params.issuerCertificate) : params.issuerCertificate;
    const issuerPrivateKeyJWK = params.issuerPrivateKey instanceof Uint8Array ? COSEKey.import(params.issuerPrivateKey).toJWK() : params.issuerPrivateKey;
    const valueDigests = new Map(
      await Promise.all(
        Object.entries(__privateGet(this, _issuerNameSpaces)).map(async ([namespace, items]) => {
          const digestMap = /* @__PURE__ */ new Map();
          await Promise.all(
            items.map(async (item, index) => {
              const hash = await item.calculateDigest(__privateGet(this, _digestAlgorithm), ctx);
              digestMap.set(index, new Uint8Array(hash));
            })
          );
          return [namespace, digestMap];
        })
      )
    );
    const mso = {
      version: "1.0",
      digestAlgorithm: __privateGet(this, _digestAlgorithm),
      valueDigests,
      deviceKeyInfo: __privateGet(this, _deviceKeyInfo),
      docType: this.docType,
      validityInfo: __privateGet(this, _validityInfo)
    };
    const payload = cborEncode(DataItem.fromData(mso));
    const protectedHeader = ProtectedHeaders.from([[1 /* Algorithm */, Algorithms[params.alg]]]);
    const _kid = params.kid ?? issuerPrivateKeyJWK.kid;
    const kid = typeof _kid === "string" ? stringToUint8Array(_kid) : _kid;
    const headers = kid ? [
      [4 /* KeyID */, kid],
      [33 /* X5Chain */, [issuerPublicKeyBuffer]]
    ] : [[33 /* X5Chain */, [issuerPublicKeyBuffer]]];
    const unprotectedHeader = UnprotectedHeaders.from(headers);
    const issuerAuth = IssuerAuth.create(protectedHeader, unprotectedHeader, payload);
    const signature = await ctx.cose.sign1.sign({
      sign1: issuerAuth,
      jwk: issuerPrivateKeyJWK
    });
    issuerAuth.signature = signature;
    const issuerSigned = {
      issuerAuth,
      nameSpaces: __privateGet(this, _issuerNameSpaces)
    };
    return new IssuerSignedDocument(this.docType, issuerSigned);
  }
};
_issuerNameSpaces = new WeakMap();
_deviceKeyInfo = new WeakMap();
_validityInfo = new WeakMap();
_digestAlgorithm = new WeakMap();

// src/mdoc/verifier.ts
import { compareVersions as compareVersions2 } from "compare-versions";
var DIGEST_ALGS = {
  "SHA-256": "sha256",
  "SHA-384": "sha384",
  "SHA-512": "sha512"
};
var Verifier = class {
  /**
   *
   * @param input.trustedCertificates The IACA root certificates list of the supported issuers.
   */
  async verifyIssuerSignature(input, ctx) {
    const { issuerAuth, disableCertificateChainValidation, onCheckG } = input;
    const onCheck = onCatCheck(onCheckG ?? defaultCallback, "ISSUER_AUTH");
    const { certificateChain } = issuerAuth;
    const countryName = issuerAuth.getIssuingCountry(ctx);
    if (!certificateChain) {
      onCheck({
        status: "FAILED",
        check: "Missing x509 certificate in issuerAuth"
      });
      return;
    }
    if (!issuerAuth.algName) {
      onCheck({
        status: "FAILED",
        check: "IssuerAuth must have an alg property"
      });
      return;
    }
    if (!disableCertificateChainValidation) {
      const trustedCertificates = input.trustedCertificates;
      try {
        if (!trustedCertificates[0]) {
          throw new Error("No trusted certificates found. Cannot verify issuer signature.");
        }
        await ctx.x509.validateCertificateChain({
          trustedCertificates,
          x5chain: certificateChain
        });
        onCheck({
          status: "PASSED",
          check: "Issuer certificate must be valid"
        });
      } catch (err) {
        onCheck({
          status: "FAILED",
          check: "Issuer certificate must be valid",
          reason: err instanceof Error ? err.message : "Unknown error"
        });
      }
    }
    const verificationJwk = await ctx.x509.getPublicKey({
      certificate: issuerAuth.certificate,
      alg: issuerAuth.algName
    });
    const verificationResult = await ctx.cose.sign1.verify({
      sign1: issuerAuth,
      jwk: verificationJwk
    });
    onCheck({
      status: verificationResult ? "PASSED" : "FAILED",
      check: "Issuer signature must be valid"
    });
    const { validityInfo } = issuerAuth.decodedPayload;
    const now = input.now ?? /* @__PURE__ */ new Date();
    const certificateData = await ctx.x509.getCertificateData({
      certificate: issuerAuth.certificate
    });
    onCheck({
      status: validityInfo.signed < certificateData.notBefore || validityInfo.signed > certificateData.notAfter ? "FAILED" : "PASSED",
      check: "The MSO signed date must be within the validity period of the certificate",
      reason: `The MSO signed date (${validityInfo.signed.toUTCString()}) must be within the validity period of the certificate (${certificateData.notBefore.toUTCString()} to ${certificateData.notAfter.toUTCString()})`
    });
    onCheck({
      status: now < validityInfo.validFrom || now > validityInfo.validUntil ? "FAILED" : "PASSED",
      check: "The MSO must be valid at the time of verification",
      reason: `The MSO must be valid at the time of verification (${now.toUTCString()})`
    });
    onCheck({
      status: countryName ? "PASSED" : "FAILED",
      check: "Country name (C) must be present in the issuer certificate's subject distinguished name"
    });
  }
  async verifyDeviceSignature(input, ctx) {
    const { deviceSigned, sessionTranscriptBytes, ephemeralPrivateKey } = input;
    const onCheck = onCatCheck(input.onCheckG ?? defaultCallback, "DEVICE_AUTH");
    const { deviceAuth, nameSpaces } = deviceSigned.deviceSigned;
    const { docType } = deviceSigned;
    const { deviceKeyInfo } = deviceSigned.issuerSigned.issuerAuth.decodedPayload;
    const { deviceKey: deviceKeyCoseKey } = deviceKeyInfo ?? {};
    if (!deviceAuth.deviceMac && !deviceAuth.deviceSignature) {
      onCheck({
        status: "FAILED",
        check: "Device Auth must contain a deviceSignature or deviceMac element"
      });
      return;
    }
    if (!sessionTranscriptBytes) {
      onCheck({
        status: "FAILED",
        check: "Session Transcript Bytes missing from options, aborting device signature check"
      });
      return;
    }
    const deviceAuthenticationBytes = calculateDeviceAutenticationBytes(sessionTranscriptBytes, docType, nameSpaces);
    if (!deviceKeyCoseKey) {
      onCheck({
        status: "FAILED",
        check: "Issuer signature must contain the device key.",
        reason: "Unable to verify deviceAuth signature: missing device key in issuerAuth"
      });
      return;
    }
    if (deviceAuth.deviceSignature) {
      const deviceKey = COSEKey.import(deviceKeyCoseKey);
      try {
        const ds = deviceAuth.deviceSignature;
        const sign1 = new Sign1(ds.protectedHeaders, ds.unprotectedHeaders, deviceAuthenticationBytes, ds.signature);
        const jwk = deviceKey.toJWK();
        const verificationResult = await ctx.cose.sign1.verify({ sign1, jwk });
        onCheck({
          status: verificationResult ? "PASSED" : "FAILED",
          check: "Device signature must be valid"
        });
      } catch (err) {
        onCheck({
          status: "FAILED",
          check: "Device signature must be valid",
          reason: `Unable to verify deviceAuth signature (ECDSA/EdDSA): ${err instanceof Error ? err.message : "Unknown error"}`
        });
      }
      return;
    }
    onCheck({
      status: deviceAuth.deviceMac ? "PASSED" : "FAILED",
      check: "Device MAC must be present when using MAC authentication"
    });
    if (!deviceAuth.deviceMac) {
      return;
    }
    onCheck({
      status: deviceAuth.deviceMac.hasSupportedAlg() ? "PASSED" : "FAILED",
      check: "Device MAC must use alg 5 (HMAC 256/256)"
    });
    if (!deviceAuth.deviceMac.hasSupportedAlg()) {
      return;
    }
    onCheck({
      status: ephemeralPrivateKey ? "PASSED" : "FAILED",
      check: "Ephemeral private key must be present when using MAC authentication"
    });
    if (!ephemeralPrivateKey) {
      return;
    }
    try {
      const deviceKeyRaw = COSEKeyToRAW(deviceKeyCoseKey);
      const ephemeralMacKeyJwk = await ctx.crypto.calculateEphemeralMacKeyJwk({
        privateKey: ephemeralPrivateKey instanceof Uint8Array ? ephemeralPrivateKey : COSEKeyToRAW(COSEKey.fromJWK(ephemeralPrivateKey).encode()),
        publicKey: deviceKeyRaw,
        sessionTranscriptBytes
      });
      const isValid = await ctx.cose.mac0.verify({
        mac0: deviceAuth.deviceMac,
        jwk: ephemeralMacKeyJwk,
        options: { detachedPayload: deviceAuthenticationBytes }
      });
      onCheck({
        status: isValid ? "PASSED" : "FAILED",
        check: "Device MAC must be valid"
      });
    } catch (err) {
      onCheck({
        status: "FAILED",
        check: "Device MAC must be valid",
        reason: `Unable to verify deviceAuth MAC: ${err instanceof Error ? err.message : "Unknown error"}`
      });
    }
  }
  async verifyData(input, ctx) {
    const { mdoc, onCheckG } = input;
    const { issuerAuth } = mdoc.issuerSigned;
    const { valueDigests, digestAlgorithm } = issuerAuth.decodedPayload;
    const onCheck = onCatCheck(onCheckG ?? defaultCallback, "DATA_INTEGRITY");
    onCheck({
      status: digestAlgorithm && DIGEST_ALGS[digestAlgorithm] ? "PASSED" : "FAILED",
      check: "Issuer Auth must include a supported digestAlgorithm element"
    });
    const nameSpaces = mdoc.issuerSigned.nameSpaces ?? {};
    await Promise.all(
      Object.entries(nameSpaces).map(async ([ns, nsItems]) => {
        onCheck({
          status: valueDigests?.has(ns) ? "PASSED" : "FAILED",
          check: `Issuer Auth must include digests for namespace: ${ns}`
        });
        const verifications = await Promise.all(
          nsItems.map(async (ev) => {
            const isValid = await ev.isValid(ns, issuerAuth, ctx);
            return { ev, ns, isValid };
          })
        );
        verifications.filter((v) => v.isValid).forEach((v) => {
          onCheck({
            status: "PASSED",
            check: `The calculated digest for ${ns}/${v.ev.elementIdentifier} attribute must match the digest in the issuerAuth element`
          });
        });
        verifications.filter((v) => !v.isValid).forEach((v) => {
          onCheck({
            status: "FAILED",
            check: `The calculated digest for ${ns}/${v.ev.elementIdentifier} attribute must match the digest in the issuerAuth element`
          });
        });
        if (ns === MDL_NAMESPACE) {
          const certificateData = await ctx.x509.getCertificateData({
            certificate: issuerAuth.certificate
          });
          if (!certificateData.issuerName) {
            onCheck({
              status: "FAILED",
              check: "The 'issuing_country' if present must match the 'countryName' in the subject field within the DS certificate",
              reason: "The 'issuing_country' and 'issuing_jurisdiction' cannot be verified because the DS certificate was not provided"
            });
          } else {
            const invalidCountry = verifications.filter((v) => v.ns === ns && v.ev.elementIdentifier === "issuing_country").find((v) => !v.isValid || !v.ev.matchCertificate(ns, issuerAuth, ctx));
            onCheck({
              status: invalidCountry ? "FAILED" : "PASSED",
              check: "The 'issuing_country' if present must match the 'countryName' in the subject field within the DS certificate",
              reason: invalidCountry ? (
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `The 'issuing_country' (${invalidCountry.ev.elementValue}) must match the 'countryName' (${issuerAuth.getIssuingCountry(ctx)}) in the subject field within the issuer certificate`
              ) : void 0
            });
            const invalidJurisdiction = verifications.filter((v) => v.ns === ns && v.ev.elementIdentifier === "issuing_jurisdiction").find((v) => !v.isValid || !v.ev.matchCertificate(ns, issuerAuth, ctx));
            onCheck({
              status: invalidJurisdiction ? "FAILED" : "PASSED",
              check: "The 'issuing_jurisdiction' if present must match the 'stateOrProvinceName' in the subject field within the DS certificate",
              reason: invalidJurisdiction ? (
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `The 'issuing_jurisdiction' (${invalidJurisdiction.ev.elementValue}) must match the 'stateOrProvinceName' (${issuerAuth.getIssuingStateOrProvince(ctx)}) in the subject field within the issuer certificate`
              ) : void 0
            });
          }
        }
      })
    );
  }
  /**
   * Parse and validate a DeviceResponse as specified in ISO/IEC 18013-5 (Device Retrieval section).
   *
   * @param input.encodedDeviceResponse
   * @param input.encodedSessionTranscript The CBOR encoded SessionTranscript.
   * @param input.ephemeralReaderKey The private part of the ephemeral key used in the session where the DeviceResponse was obtained. This is only required if the DeviceResponse is using the MAC method for device authentication.
   */
  async verifyDeviceResponse(input, ctx) {
    const { encodedDeviceResponse, now, trustedCertificates } = input;
    const onCheck = input.onCheck ?? defaultCallback;
    const dr = parseDeviceResponse(encodedDeviceResponse);
    onCheck({
      status: dr.version ? "PASSED" : "FAILED",
      check: 'Device Response must include "version" element.',
      category: "DOCUMENT_FORMAT"
    });
    onCheck({
      status: compareVersions2(dr.version, "1.0") >= 0 ? "PASSED" : "FAILED",
      check: "Device Response version must be 1.0 or greater",
      category: "DOCUMENT_FORMAT"
    });
    onCheck({
      status: dr.documents.length > 0 ? "PASSED" : "FAILED",
      check: "Device Response must include at least one document.",
      category: "DOCUMENT_FORMAT"
    });
    for (const document of dr.documents) {
      const { issuerAuth } = document.issuerSigned;
      if (!(document instanceof DeviceSignedDocument)) {
        onCheck({
          status: "FAILED",
          category: "DEVICE_AUTH",
          check: `The document is not signed by the device. ${document.docType}`
        });
        continue;
      }
      await this.verifyIssuerSignature(
        {
          issuerAuth,
          disableCertificateChainValidation: input.disableCertificateChainValidation ?? false,
          now,
          onCheckG: onCheck,
          trustedCertificates
        },
        ctx
      );
      await this.verifyDeviceSignature(
        {
          deviceSigned: document,
          ephemeralPrivateKey: input.ephemeralReaderKey,
          sessionTranscriptBytes: input.encodedSessionTranscript,
          onCheckG: onCheck
        },
        ctx
      );
      await this.verifyData({ mdoc: document, onCheckG: onCheck }, ctx);
    }
    return dr;
  }
  async getDiagnosticInformation(encodedDeviceResponse, options, ctx) {
    const { trustedCertificates } = options;
    const dr = [];
    const decoded = await this.verifyDeviceResponse(
      {
        encodedDeviceResponse,
        ...options,
        onCheck: (check) => dr.push(check),
        trustedCertificates
      },
      ctx
    );
    const document = decoded.documents[0];
    if (!document) {
      throw new Error("No documents found for getting diagnostic information.");
    }
    const { issuerAuth } = document.issuerSigned;
    const issuerCert = issuerAuth.certificate;
    const attributes = (await Promise.all(
      Object.keys(document.issuerSigned.nameSpaces).map(async (ns) => {
        const items = document.issuerSigned.nameSpaces[ns] ?? [];
        return Promise.all(
          items.map(async (item) => {
            const isValid = await item.isValid(ns, issuerAuth, ctx);
            return {
              ns,
              id: item.elementIdentifier,
              value: item.elementValue,
              isValid,
              matchCertificate: item.matchCertificate(ns, issuerAuth, ctx)
            };
          })
        );
      })
    )).flat();
    const deviceAttributes = document instanceof DeviceSignedDocument ? Object.entries(document.deviceSigned.nameSpaces).flatMap(([ns, items]) => {
      return Object.entries(items).map(([id, value]) => {
        return {
          ns,
          id,
          value
        };
      });
    }) : void 0;
    let deviceKey = void 0;
    if (document.issuerSigned.issuerAuth) {
      const { deviceKeyInfo } = document.issuerSigned.issuerAuth.decodedPayload;
      if (deviceKeyInfo?.deviceKey) {
        deviceKey = COSEKey.import(deviceKeyInfo.deviceKey).toJWK();
      }
    }
    const disclosedAttributes = attributes.filter((attr) => attr.isValid).length;
    const totalAttributes = Array.from(
      document.issuerSigned.issuerAuth.decodedPayload.valueDigests?.entries() ?? []
    ).reduce((prev, [, digests]) => prev + digests.size, 0);
    return {
      general: {
        version: decoded.version,
        type: "DeviceResponse",
        status: decoded.status,
        documents: decoded.documents.length
      },
      validityInfo: document.issuerSigned.issuerAuth.decodedPayload.validityInfo,
      issuerCertificate: await ctx.x509.getCertificateData({
        certificate: issuerCert
      }),
      issuerSignature: {
        // TODO
        // biome-ignore lint/style/noNonNullAssertion: <explanation>
        alg: document.issuerSigned.issuerAuth.algName,
        isValid: dr.filter((check) => check.category === "ISSUER_AUTH").every((check) => check.status === "PASSED"),
        reasons: dr.filter((check) => check.category === "ISSUER_AUTH" && check.status === "FAILED").map((check) => check.reason ?? check.check),
        digests: Object.fromEntries(
          Array.from(document.issuerSigned.issuerAuth.decodedPayload.valueDigests?.entries() ?? []).map(
            ([ns, digests]) => [ns, digests.size]
          )
        )
      },
      deviceKey: {
        jwk: deviceKey
      },
      deviceSignature: document instanceof DeviceSignedDocument ? {
        alg: document.deviceSigned.deviceAuth.deviceSignature?.algName ?? document.deviceSigned.deviceAuth.deviceMac?.algName,
        isValid: dr.filter((check) => check.category === "DEVICE_AUTH").every((check) => check.status === "PASSED"),
        reasons: dr.filter((check) => check.category === "DEVICE_AUTH" && check.status === "FAILED").map((check) => check.reason ?? check.check)
      } : void 0,
      dataIntegrity: {
        disclosedAttributes: `${disclosedAttributes} of ${totalAttributes}`,
        isValid: dr.filter((check) => check.category === "DATA_INTEGRITY").every((check) => check.status === "PASSED"),
        reasons: dr.filter((check) => check.category === "DATA_INTEGRITY" && check.status === "FAILED").map((check) => check.reason ?? check.check)
      },
      attributes,
      deviceAttributes
      // TODO!!!!
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    };
  }
};

// src/u-hex.ts
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
function hexToUint8Array(hexString) {
  const bytes = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    bytes[i / 2] = Number.parseInt(hexString.substr(i, 2), 16);
  }
  return bytes;
}
export {
  COSEKey,
  COSEKeyToRAW,
  DataItem,
  DateOnly,
  DeviceRequest,
  DeviceResponse,
  DeviceSignedDocument,
  Document,
  IssuerSignedDocument,
  IssuerSignedItem,
  MDoc,
  MDocStatus,
  Verifier,
  areEqualUint8Array,
  cborDecode,
  cborDecodeUnknown,
  cborEncode,
  defaultCallback,
  hexToUint8Array,
  limitDisclosureToInputDescriptor,
  parseDeviceResponse,
  parseDeviceSigned,
  parseIssuerSigned,
  stringToUint8Array,
  uint8ArrayToBase64Url,
  uint8ArrayToHex
};
//# sourceMappingURL=index.mjs.map