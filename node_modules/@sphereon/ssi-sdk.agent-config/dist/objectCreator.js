"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createObjects = void 0;
const jsonpointer_1 = require("jsonpointer");
const url_parse_1 = __importDefault(require("url-parse"));
/**
 * Creates objects from a configuration object and a set of pointers.
 *
 * Example:
 * ```ts
 * const { url } = createObjects({ "rpcUrl": "http://localhost:8545", }, { url: '/rpcUrl' })
 * ```
 *
 * The config can contain references (`$ref`) to other objects within using JSON pointers.
 * Example:
 * ```json
 * {
 *   "rpcUrl": "http://localhost:8545",
 *   "endpoint": {
 *     "url": {
 *       "$ref": "/rpcUrl"
 *     }
 *   }
 * }
 * ```
 *
 * The config object can also contain references to NPM modules using the `$require` property.
 * Example:
 * ```json
 * {
 *   "agent": {
 *     "$require": "@veramo/core#Agent",
 *     "$args": {
 *       "plugins": [
 *         { "$require": "@veramo/did-comm#DIDComm" },
 *       ]
 *     }
 *   }
 * }
 * ```
 *
 * Environment variables can also be specified using the `$env` property.
 *
 * @see Please see {@link https://veramo.io/docs/veramo_agent/configuration_internals | Configuration Internals} for
 *   more information.
 *
 * @param config - The configuration object
 * @param pointers - A map of JSON pointers to objects within that config that you wish to create
 *
 * @beta - This API may change without a major version bump
 */
function createObjects(config, pointers) {
    return __awaiter(this, void 0, void 0, function* () {
        const objects = {};
        function resolveRefs(input) {
            return __awaiter(this, void 0, void 0, function* () {
                if (Array.isArray(input)) {
                    const resolved = [];
                    for (const item of input) {
                        resolved.push(yield resolveRefs(item));
                    }
                    return resolved;
                }
                if (typeof input === 'object') {
                    const resolved = {};
                    for (const property in input) {
                        if (input.hasOwnProperty(property)) {
                            if (property === '$ref') {
                                const pointer = input[property];
                                return yield objectFromPointer(pointer);
                            }
                            else if (property === '$require') {
                                return yield objectFromConfig(input);
                            }
                            else if (property === '$env') {
                                return process.env[input[property]];
                            }
                            else {
                                resolved[property] = yield resolveRefs(input[property]);
                            }
                        }
                    }
                    return resolved;
                }
                return input;
            });
        }
        function objectFromConfig(objectConfig) {
            return __awaiter(this, void 0, void 0, function* () {
                let object;
                // console.log('Requiring', objectConfig['$require'])
                const parsed = (0, url_parse_1.default)(objectConfig['$require'], {}, true);
                let module = parsed.pathname;
                const member = parsed.hash.length > 1 ? parsed.hash.slice(1) : undefined;
                const type = parsed.query['t'] || 'class';
                const pointer = parsed.query['p'];
                const args = objectConfig['$args'];
                // console.log({module, member, type, query: parsed.query})
                if (module.slice(0, 2) === './' || module.slice(0, 3) === '../') {
                    const { resolve } = yield Promise.resolve().then(() => __importStar(require('path')));
                    module = resolve(module);
                }
                const resolvedArgs = args !== undefined ? yield resolveRefs(args) : [];
                try {
                    let required = member ? (yield Promise.resolve(`${module}`).then(s => __importStar(require(s))))[member] : yield Promise.resolve(`${module}`).then(s => __importStar(require(s)));
                    if (type === 'class') {
                        object = new required(...resolvedArgs);
                    }
                    else if (type === 'function') {
                        object = required(...resolvedArgs);
                    }
                    else if (type === 'object') {
                        object = required;
                    }
                }
                catch (e) {
                    throw new Error(`Error creating ${module}['${member}']: ${e.message}`);
                }
                if (pointer) {
                    return (0, jsonpointer_1.get)(object, pointer);
                }
                return object;
            });
        }
        function objectFromPointer(pointer) {
            return __awaiter(this, void 0, void 0, function* () {
                const existingObject = (0, jsonpointer_1.get)(objects, pointer);
                if (existingObject) {
                    // console.log('Existing', pointer)
                    return existingObject;
                }
                else {
                    // console.log('New', pointer)
                    const objectConfig = (0, jsonpointer_1.get)(config, pointer);
                    if (!objectConfig)
                        throw Error('Pointer not found: ' + pointer);
                    try {
                        let object;
                        if (objectConfig['$require']) {
                            object = yield objectFromConfig(objectConfig);
                        }
                        else if (objectConfig['$env']) {
                            object = process.env[objectConfig['$env']];
                        }
                        else {
                            object = yield resolveRefs(objectConfig);
                        }
                        (0, jsonpointer_1.set)(objects, pointer, object);
                        return object;
                    }
                    catch (e) {
                        throw Error(e.message + '. While creating object from pointer: ' + pointer);
                    }
                }
            });
        }
        const result = {};
        for (const key of Object.keys(pointers)) {
            if (pointers.hasOwnProperty(key)) {
                result[key] = yield objectFromPointer(pointers[key]);
            }
        }
        return result;
    });
}
exports.createObjects = createObjects;
//# sourceMappingURL=objectCreator.js.map