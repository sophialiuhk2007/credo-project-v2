"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetDatabase = exports.revertMigration = exports.dropDatabase = exports.getDbConnection = exports.DataSources = void 0;
const debug_1 = __importDefault(require("debug"));
const typeorm_1 = require("typeorm");
const debug = (0, debug_1.default)(`sphereon:ssi-sdk:database`);
class DataSources {
    get defaultDbType() {
        return this._defaultDbType;
    }
    set defaultDbType(value) {
        this._defaultDbType = value;
    }
    static singleInstance() {
        if (!DataSources.singleton) {
            DataSources.singleton = new DataSources();
        }
        return DataSources.singleton;
    }
    static newInstance(configs) {
        return new DataSources(configs);
    }
    constructor(configs) {
        this.dataSources = new Map();
        this.configs = new Map();
        this._defaultDbType = 'sqlite';
        ;
        (configs !== null && configs !== void 0 ? configs : new Map()).forEach((config, name) => this.addConfig(name, config));
    }
    addConfig(dbName, config) {
        this.configs.set(dbName, config);
        // yes we are aware last one wins
        this._defaultDbType = config.type;
        return this;
    }
    deleteConfig(dbName) {
        this.configs.delete(dbName);
        return this;
    }
    has(dbName) {
        return this.configs.has(dbName) && this.dataSources.has(dbName);
    }
    delete(dbName) {
        this.deleteConfig(dbName);
        this.dataSources.delete(dbName);
        return this;
    }
    getConfig(dbName) {
        const config = this.configs.get(dbName);
        if (!config) {
            throw Error(`No DB config found for ${dbName}`);
        }
        return config;
    }
    getDbNames() {
        return [...this.configs.keys()];
    }
    getDbConnection(dbName) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = this.getConfig(dbName);
            if (!this._defaultDbType) {
                this._defaultDbType = config.type;
            }
            /*if (config.synchronize) {
                        return Promise.reject(
                            `WARNING: Automatic migrations need to be disabled in this app! Adjust the database configuration and set synchronize to false`
                        )
                    }*/
            let dataSource = this.dataSources.get(dbName);
            if (dataSource) {
                return dataSource;
            }
            dataSource = yield new typeorm_1.DataSource(Object.assign(Object.assign({}, config), { name: dbName })).initialize();
            this.dataSources.set(dbName, dataSource);
            if (config.synchronize) {
                debug(`WARNING: Automatic migrations need to be disabled in this app! Adjust the database configuration and set synchronize to false`);
            }
            else if (config.migrationsRun) {
                debug(`Migrations are currently managed from config. Please set migrationsRun and synchronize to false to get consistent behaviour. We run migrations from code explicitly`);
            }
            else {
                debug(`Running ${dataSource.migrations.length} migration(s) from code if needed...`);
                yield dataSource.runMigrations();
                debug(`${dataSource.migrations.length} migration(s) from code were inspected and applied`);
            }
            return dataSource;
        });
    }
}
exports.DataSources = DataSources;
/**
 * Gets the database connection.
 *
 * Also makes sure that migrations are run (versioning for DB schema's), so we can properly update over time
 *
 * @param connectionName The database name
 * @param opts
 */
const getDbConnection = (connectionName, opts) => __awaiter(void 0, void 0, void 0, function* () {
    if (!DataSources.singleInstance().has(connectionName) && (opts === null || opts === void 0 ? void 0 : opts.config)) {
        DataSources.singleInstance().addConfig(connectionName, opts === null || opts === void 0 ? void 0 : opts.config);
    }
    return DataSources.singleInstance().getDbConnection(connectionName);
});
exports.getDbConnection = getDbConnection;
const dropDatabase = (dbName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!DataSources.singleInstance().has(dbName)) {
        return Promise.reject(Error(`No database present with name: ${dbName}`));
    }
    const connection = yield (0, exports.getDbConnection)(dbName);
    yield connection.dropDatabase();
    DataSources.singleInstance().delete(dbName);
});
exports.dropDatabase = dropDatabase;
/**
 * Runs a migration down (drops DB schema)
 * @param dataSource
 */
const revertMigration = (dataSource) => __awaiter(void 0, void 0, void 0, function* () {
    if (dataSource.isInitialized) {
        yield dataSource.undoLastMigration();
    }
    else {
        console.error('DataSource is not initialized');
    }
});
exports.revertMigration = revertMigration;
const resetDatabase = (dbName) => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, exports.dropDatabase)(dbName);
    yield (0, exports.getDbConnection)(dbName);
});
exports.resetDatabase = resetDatabase;
//# sourceMappingURL=dataSources.js.map