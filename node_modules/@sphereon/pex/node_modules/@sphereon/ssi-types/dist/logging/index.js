"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleRecordLogger = exports.SimpleLogger = exports.Loggers = exports.LogMethod = exports.LoggingEventType = exports.LogLevel = void 0;
exports.logOptions = logOptions;
const debug_1 = require("debug");
const events_1 = require("events");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 0] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARNING"] = 3] = "WARNING";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
var LoggingEventType;
(function (LoggingEventType) {
    LoggingEventType["AUDIT"] = "audit";
    LoggingEventType["ACTIVITY"] = "activity";
    LoggingEventType["GENERAL"] = "general";
})(LoggingEventType || (exports.LoggingEventType = LoggingEventType = {}));
var LogMethod;
(function (LogMethod) {
    LogMethod[LogMethod["DEBUG_PKG"] = 0] = "DEBUG_PKG";
    LogMethod[LogMethod["CONSOLE"] = 1] = "CONSOLE";
    LogMethod[LogMethod["EVENT"] = 2] = "EVENT";
})(LogMethod || (exports.LogMethod = LogMethod = {}));
function logOptions(opts) {
    var _a, _b, _c, _d;
    return {
        namespace: (_a = opts === null || opts === void 0 ? void 0 : opts.namespace) !== null && _a !== void 0 ? _a : 'sphereon',
        eventName: (_b = opts === null || opts === void 0 ? void 0 : opts.eventName) !== null && _b !== void 0 ? _b : 'sphereon:default',
        defaultLogLevel: (_c = opts === null || opts === void 0 ? void 0 : opts.defaultLogLevel) !== null && _c !== void 0 ? _c : LogLevel.INFO,
        methods: (_d = opts === null || opts === void 0 ? void 0 : opts.methods) !== null && _d !== void 0 ? _d : [LogMethod.DEBUG_PKG, LogMethod.EVENT],
    };
}
class Loggers {
    constructor(defaultOptions) {
        this.namespaceOptions = new Map();
        this.loggers = new WeakMap();
        this.defaultOptions(logOptions(defaultOptions));
    }
    options(namespace, options) {
        this.namespaceOptions.set(namespace, logOptions(Object.assign(Object.assign({}, options), { namespace })));
        return this;
    }
    defaultOptions(options) {
        this.options(Loggers.DEFAULT_KEY, options);
        return this;
    }
    register(namespace, logger) {
        return this.get(namespace, logger);
    }
    get(namespace, registerLogger) {
        var _a, _b;
        const options = (_b = (_a = this.namespaceOptions.get(namespace)) !== null && _a !== void 0 ? _a : registerLogger === null || registerLogger === void 0 ? void 0 : registerLogger.options) !== null && _b !== void 0 ? _b : this.namespaceOptions.get(Loggers.DEFAULT_KEY);
        if (!options) {
            throw Error(`No logging options found for namespace ${namespace}`);
        }
        this.namespaceOptions.set(namespace, options);
        let logger = this.loggers.get(options);
        if (!logger) {
            logger = registerLogger !== null && registerLogger !== void 0 ? registerLogger : new SimpleLogger(options);
            this.loggers.set(options, logger);
        }
        return logger;
    }
}
exports.Loggers = Loggers;
Loggers.DEFAULT_KEY = '__DEFAULT__';
Loggers.DEFAULT = new Loggers({
    defaultLogLevel: LogLevel.INFO,
    methods: [LogMethod.DEBUG_PKG, LogMethod.EVENT],
});
class SimpleLogger {
    constructor(opts) {
        this._eventEmitter = new events_1.EventEmitter({ captureRejections: true });
        this._options = logOptions(opts);
    }
    get eventEmitter() {
        return this._eventEmitter;
    }
    get options() {
        return this._options;
    }
    trace(value, ...args) {
        this.logImpl(LogLevel.TRACE, value, ...args);
    }
    debug(value, ...args) {
        this.logImpl(LogLevel.DEBUG, value, ...args);
    }
    info(value, ...args) {
        this.logImpl(LogLevel.INFO, value, ...args);
    }
    warning(value, ...args) {
        this.logImpl(LogLevel.WARNING, value, ...args);
    }
    error(value, ...args) {
        this.logImpl(LogLevel.ERROR, value, ...args);
    }
    logl(level, value, ...args) {
        this.logImpl(level, value, ...args);
    }
    logImpl(level, value, ...args) {
        var _a;
        const date = new Date().toISOString();
        const filteredArgs = (_a = args === null || args === void 0 ? void 0 : args.filter((v) => v)) !== null && _a !== void 0 ? _a : [];
        const arg = filteredArgs.length === 0 || filteredArgs[0] == undefined ? undefined : filteredArgs;
        function toLogValue(options) {
            if (typeof value === 'string') {
                return `${date}-(${options.namespace}) ${value}`;
            }
            else if (typeof value === 'object') {
                value['namespace'] = options.namespace;
                value['time'] = date;
            }
            return value;
        }
        const logValue = toLogValue(this.options);
        const logArgs = [logValue];
        if (arg) {
            logArgs.push(args);
        }
        let debugPkgEnabled = this.options.methods.includes(LogMethod.DEBUG_PKG);
        if (debugPkgEnabled) {
            const debugPkgDebugger = (0, debug_1.debug)(this._options.namespace);
            // It was enabled at the options level in code, but could be disabled at runtime using env vars
            debugPkgEnabled = debugPkgDebugger.enabled;
            if (debugPkgEnabled) {
                if (arg) {
                    debugPkgDebugger(`${date}- ${value},`, ...arg);
                }
                else {
                    debugPkgDebugger(`${date}- ${value}`);
                }
            }
        }
        // We do not perform console.logs in case the debug package is enabled in code and used at runtime
        if (this.options.methods.includes(LogMethod.CONSOLE) && !debugPkgEnabled) {
            const [value, args] = logArgs;
            let logMethod = console.info;
            switch (level) {
                case LogLevel.TRACE:
                    logMethod = console.trace;
                    break;
                case LogLevel.DEBUG:
                    logMethod = console.debug;
                    break;
                case LogLevel.INFO:
                    logMethod = console.info;
                    break;
                case LogLevel.WARNING:
                    logMethod = console.warn;
                    break;
                case LogLevel.ERROR:
                    logMethod = console.error;
                    break;
            }
            if (args) {
                logMethod(value + ',', ...args);
            }
            else {
                logMethod(value);
            }
        }
        if (this.options.methods.includes(LogMethod.EVENT)) {
            this._eventEmitter.emit(this.options.eventName, {
                data: value.toString(),
                timestamp: new Date(date),
                level,
                type: LoggingEventType.GENERAL,
                diagnosticData: logArgs,
            });
        }
    }
    log(value, ...args) {
        this.logImpl(this.options.defaultLogLevel, value, ...args);
    }
}
exports.SimpleLogger = SimpleLogger;
class SimpleRecordLogger extends SimpleLogger {
    constructor(opts) {
        super(opts);
    }
}
exports.SimpleRecordLogger = SimpleRecordLogger;
//# sourceMappingURL=index.js.map