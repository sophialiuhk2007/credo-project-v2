"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubjectAlternativeNames = exports.validateCertificateChainMatchesClientIdScheme = exports.assertCertificateMatchesClientIdScheme = exports.SubjectAlternativeGeneralName = exports.getCertificateSubjectPublicKeyJWK = exports.getSubjectDN = exports.getIssuerDN = exports.validateX509CertificateChain = exports.getCertificateInfo = void 0;
const js_x509_utils_1 = __importDefault(require("js-x509-utils"));
const pkijs_1 = require("pkijs");
const u8a = __importStar(require("uint8arrays"));
const x509_utils_1 = require("./x509-utils");
const defaultCryptoEngine = () => {
    if (typeof self !== 'undefined') {
        if ('crypto' in self) {
            let engineName = 'webcrypto';
            if ('webkitSubtle' in self.crypto) {
                engineName = 'safari';
            }
            (0, pkijs_1.setEngine)(engineName, new pkijs_1.CryptoEngine({ name: engineName, crypto: crypto }));
        }
    }
    else if (typeof crypto !== 'undefined' && 'webcrypto' in crypto) {
        const name = 'NodeJS ^15';
        const nodeCrypto = crypto.webcrypto;
        // @ts-ignore
        (0, pkijs_1.setEngine)(name, new pkijs_1.CryptoEngine({ name, crypto: nodeCrypto }));
    }
    else if (typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined') {
        const name = 'crypto';
        (0, pkijs_1.setEngine)(name, new pkijs_1.CryptoEngine({ name, crypto: crypto }));
    }
};
const getCertificateInfo = (certificate, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const publicKeyJWK = yield (0, exports.getCertificateSubjectPublicKeyJWK)(certificate);
    return {
        issuer: { dn: (0, exports.getIssuerDN)(certificate) },
        subject: {
            dn: (0, exports.getSubjectDN)(certificate),
            subjectAlternativeNames: (0, exports.getSubjectAlternativeNames)(certificate, { typeFilter: opts === null || opts === void 0 ? void 0 : opts.sanTypeFilter }),
        },
        publicKeyJWK: publicKeyJWK,
        notBefore: certificate.notBefore.value,
        notAfter: certificate.notAfter.value,
        // certificate
    };
});
exports.getCertificateInfo = getCertificateInfo;
/**
 *
 * @param pemOrDerChain The order must be that the Certs signing another cert must come one after another. So first the signing cert, then any cert signing that cert and so on
 * @param trustedPEMs
 * @param verificationTime
 * @param opts
 */
const validateX509CertificateChain = (_a) => __awaiter(void 0, [_a], void 0, function* ({ chain: pemOrDerChain, trustAnchors, verificationTime = new Date(), opts = {
    trustRootWhenNoAnchors: false,
    allowSingleNoCAChainElement: true,
    blindlyTrustedAnchors: [],
}, }) {
    var _b;
    const { trustRootWhenNoAnchors = false, allowSingleNoCAChainElement = true, blindlyTrustedAnchors = [], client } = opts;
    const trustedPEMs = trustRootWhenNoAnchors && !trustAnchors ? [pemOrDerChain[pemOrDerChain.length - 1]] : trustAnchors;
    if (pemOrDerChain.length === 0) {
        return {
            error: true,
            critical: true,
            message: 'Certificate chain in DER or PEM format must not be empty',
            verificationTime,
        };
    }
    const certs = pemOrDerChain.map(x509_utils_1.pemOrDerToX509Certificate);
    const trustedCerts = trustedPEMs ? trustedPEMs.map(x509_utils_1.pemOrDerToX509Certificate) : undefined;
    defaultCryptoEngine();
    if (pemOrDerChain.length === 1) {
        const singleCert = typeof pemOrDerChain[0] === 'string' ? pemOrDerChain[0] : u8a.toString(pemOrDerChain[0], 'base64pad');
        const cert = (0, x509_utils_1.pemOrDerToX509Certificate)(singleCert);
        if (client) {
            const validation = yield (0, exports.validateCertificateChainMatchesClientIdScheme)(cert, client.clientId, client.clientIdScheme);
            if (validation.error) {
                return validation;
            }
        }
        if (blindlyTrustedAnchors.includes(singleCert)) {
            console.log(`Certificate chain validation success as single cert if blindly trusted. WARNING: ONLY USE FOR TESTING PURPOSES.`);
            return Object.assign({ error: false, critical: true, message: `Certificate chain validation success as single cert if blindly trusted. WARNING: ONLY USE FOR TESTING PURPOSES.`, verificationTime, certificateChain: [yield (0, exports.getCertificateInfo)(cert)] }, (client && { client }));
        }
        if (allowSingleNoCAChainElement) {
            const subjectDN = (0, exports.getSubjectDN)(cert).DN;
            if (!(0, exports.getIssuerDN)(cert).DN || (0, exports.getIssuerDN)(cert).DN === subjectDN) {
                const passed = yield cert.verify();
                return Object.assign({ error: !passed, critical: true, message: `Certificate chain validation for ${subjectDN}: ${passed ? 'successful' : 'failed'}.`, verificationTime, certificateChain: [yield (0, exports.getCertificateInfo)(cert)] }, (client && { client }));
            }
        }
    }
    const validationEngine = new pkijs_1.CertificateChainValidationEngine({
        certs /*crls: [crl1],   ocsps: [ocsp1], */,
        checkDate: verificationTime,
        trustedCerts,
    });
    try {
        const verification = yield validationEngine.verify();
        if (!verification.result || !verification.certificatePath) {
            return Object.assign({ error: true, critical: true, message: verification.resultMessage !== '' ? verification.resultMessage : `Certificate chain validation failed.`, verificationTime }, (client && { client }));
        }
        const certPath = verification.certificatePath;
        if (client) {
            const clientIdValidation = yield (0, exports.validateCertificateChainMatchesClientIdScheme)(certs[0], client.clientId, client.clientIdScheme);
            if (clientIdValidation.error) {
                return clientIdValidation;
            }
        }
        const certInfos = yield Promise.all(certPath.map((certificate) => __awaiter(void 0, void 0, void 0, function* () {
            return (0, exports.getCertificateInfo)(certificate);
        })));
        return Object.assign({ error: false, critical: false, message: `Certificate chain was valid`, verificationTime, certificateChain: certInfos }, (client && { client }));
    }
    catch (error) {
        return Object.assign({ error: true, critical: true, message: `Certificate chain was invalid, ${(_b = error.message) !== null && _b !== void 0 ? _b : '<unknown error>'}`, verificationTime }, (client && { client }));
    }
});
exports.validateX509CertificateChain = validateX509CertificateChain;
const rdnmap = {
    '2.5.4.6': 'C',
    '2.5.4.10': 'O',
    '2.5.4.11': 'OU',
    '2.5.4.3': 'CN',
    '2.5.4.7': 'L',
    '2.5.4.8': 'ST',
    '2.5.4.12': 'T',
    '2.5.4.42': 'GN',
    '2.5.4.43': 'I',
    '2.5.4.4': 'SN',
    '1.2.840.113549.1.9.1': 'E-mail',
};
const getIssuerDN = (cert) => {
    return {
        DN: getDNString(cert.issuer.typesAndValues),
        attributes: getDNObject(cert.issuer.typesAndValues),
    };
};
exports.getIssuerDN = getIssuerDN;
const getSubjectDN = (cert) => {
    return {
        DN: getDNString(cert.subject.typesAndValues),
        attributes: getDNObject(cert.subject.typesAndValues),
    };
};
exports.getSubjectDN = getSubjectDN;
const getDNObject = (typesAndValues) => {
    var _a;
    const DN = {};
    for (const typeAndValue of typesAndValues) {
        const type = (_a = rdnmap[typeAndValue.type]) !== null && _a !== void 0 ? _a : typeAndValue.type;
        DN[type] = typeAndValue.value.getValue();
    }
    return DN;
};
const getDNString = (typesAndValues) => {
    return Object.entries(getDNObject(typesAndValues))
        .map(([key, value]) => `${key}=${value}`)
        .join(',');
};
const getCertificateSubjectPublicKeyJWK = (pemOrDerCert) => __awaiter(void 0, void 0, void 0, function* () {
    const pemOrDerStr = typeof pemOrDerCert === 'string'
        ? pemOrDerCert
        : pemOrDerCert instanceof Uint8Array
            ? u8a.toString(pemOrDerCert, 'base64pad')
            : pemOrDerCert.toString('base64');
    const pem = (0, x509_utils_1.derToPEM)(pemOrDerStr);
    const certificate = (0, x509_utils_1.pemOrDerToX509Certificate)(pem);
    try {
        const subtle = (0, pkijs_1.getCrypto)(true).subtle;
        const pk = yield certificate.getPublicKey();
        return yield subtle.exportKey('jwk', pk);
    }
    catch (error) {
        console.log(`Error in primary get JWK from cert:`, error === null || error === void 0 ? void 0 : error.message);
    }
    return yield js_x509_utils_1.default.toJwk(pem, 'pem');
});
exports.getCertificateSubjectPublicKeyJWK = getCertificateSubjectPublicKeyJWK;
/**
 *  otherName                       [0]     OtherName,
 *         rfc822Name                      [1]     IA5String,
 *         dNSName                         [2]     IA5String,
 *         x400Address                     [3]     ORAddress,
 *         directoryName                   [4]     Name,
 *         ediPartyName                    [5]     EDIPartyName,
 *         uniformResourceIdentifier       [6]     IA5String,
 *         iPAddress                       [7]     OCTET STRING,
 *         registeredID                    [8]     OBJECT IDENTIFIER }
 */
var SubjectAlternativeGeneralName;
(function (SubjectAlternativeGeneralName) {
    SubjectAlternativeGeneralName[SubjectAlternativeGeneralName["rfc822Name"] = 1] = "rfc822Name";
    SubjectAlternativeGeneralName[SubjectAlternativeGeneralName["dnsName"] = 2] = "dnsName";
    SubjectAlternativeGeneralName[SubjectAlternativeGeneralName["uniformResourceIdentifier"] = 6] = "uniformResourceIdentifier";
    SubjectAlternativeGeneralName[SubjectAlternativeGeneralName["ipAddress"] = 7] = "ipAddress";
})(SubjectAlternativeGeneralName || (exports.SubjectAlternativeGeneralName = SubjectAlternativeGeneralName = {}));
const assertCertificateMatchesClientIdScheme = (certificate, clientId, clientIdScheme) => {
    const sans = (0, exports.getSubjectAlternativeNames)(certificate, { clientIdSchemeFilter: clientIdScheme });
    const clientIdMatches = sans.find((san) => san.value === clientId);
    if (!clientIdMatches) {
        throw Error(`Client id scheme ${clientIdScheme} used had no matching subject alternative names in certificate with DN ${(0, exports.getSubjectDN)(certificate).DN}. SANS: ${sans.map((san) => san.value).join(',')}`);
    }
};
exports.assertCertificateMatchesClientIdScheme = assertCertificateMatchesClientIdScheme;
const validateCertificateChainMatchesClientIdScheme = (certificate, clientId, clientIdScheme) => __awaiter(void 0, void 0, void 0, function* () {
    const result = {
        error: true,
        critical: true,
        message: `Client Id ${clientId} was not present in certificate using scheme ${clientIdScheme}`,
        client: {
            clientId,
            clientIdScheme,
        },
        certificateChain: [yield (0, exports.getCertificateInfo)(certificate)],
        verificationTime: new Date(),
    };
    try {
        (0, exports.assertCertificateMatchesClientIdScheme)(certificate, clientId, clientIdScheme);
    }
    catch (error) {
        return result;
    }
    result.error = false;
    result.message = `Client Id ${clientId} was present in certificate using scheme ${clientIdScheme}`;
    return result;
});
exports.validateCertificateChainMatchesClientIdScheme = validateCertificateChainMatchesClientIdScheme;
const getSubjectAlternativeNames = (certificate, opts) => {
    var _a, _b;
    let typeFilter;
    if (opts === null || opts === void 0 ? void 0 : opts.clientIdSchemeFilter) {
        typeFilter =
            opts.clientIdSchemeFilter === 'x509_san_dns'
                ? [SubjectAlternativeGeneralName.dnsName]
                : [SubjectAlternativeGeneralName.uniformResourceIdentifier];
    }
    else if (opts === null || opts === void 0 ? void 0 : opts.typeFilter) {
        typeFilter = Array.isArray(opts.typeFilter) ? opts.typeFilter : [opts.typeFilter];
    }
    else {
        typeFilter = [SubjectAlternativeGeneralName.dnsName, SubjectAlternativeGeneralName.uniformResourceIdentifier];
    }
    const parsedValue = (_b = (_a = certificate.extensions) === null || _a === void 0 ? void 0 : _a.find((ext) => ext.extnID === pkijs_1.id_SubjectAltName)) === null || _b === void 0 ? void 0 : _b.parsedValue;
    if (!parsedValue) {
        return [];
    }
    const altNames = parsedValue.toJSON().altNames;
    return altNames
        .filter((altName) => typeFilter.includes(altName.type))
        .map((altName) => {
        return { type: altName.type, value: altName.value };
    });
};
exports.getSubjectAlternativeNames = getSubjectAlternativeNames;
//# sourceMappingURL=x509-validator.js.map