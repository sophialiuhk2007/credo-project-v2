import { Certificate } from 'pkijs';
import { KeyVisibility } from '../types';
export declare function pemCertChainTox5c(cert: string, maxDepth?: number): string[];
export declare function x5cToPemCertChain(x5c: string[], maxDepth?: number): string;
export declare const pemOrDerToX509Certificate: (cert: string | Uint8Array) => Certificate;
export declare const areCertificatesEqual: (cert1: Certificate, cert2: Certificate) => boolean;
export declare const toKeyObject: (PEM: string, visibility?: KeyVisibility) => {
    pem: string;
    jwk: JsonWebKey;
    keyHex: string;
    keyType: KeyVisibility;
};
export declare const jwkToPEM: (jwk: JsonWebKey, visibility?: KeyVisibility) => string;
export declare const PEMToJwk: (pem: string, visibility?: KeyVisibility) => JsonWebKey;
export declare const privateKeyHexFromPEM: (PEM: string) => string;
export declare const hexKeyFromPEMBasedJwk: (jwk: JsonWebKey, visibility?: KeyVisibility) => string;
export declare const publicKeyHexFromPEM: (PEM: string) => string;
export declare const PEMToHex: (PEM: string, headerKey?: string) => string;
export declare function PEMToBinary(pem: string): Uint8Array;
/**
 * Converts a base64 encoded string to hex string, removing any non-base64 characters, including newlines
 * @param input The input in base64, with optional newlines
 * @param inputEncoding
 */
export declare const base64ToHex: (input: string, inputEncoding?: 'base64' | 'base64pad' | 'base64url' | 'base64urlpad') => string;
export declare const hexToBase64: (input: number | object | string, targetEncoding?: 'base64' | 'base64pad' | 'base64url' | 'base64urlpad') => string;
export declare const hexToPEM: (hex: string, type: KeyVisibility) => string;
export declare function PEMToDer(pem: string): string;
export declare function derToPEM(cert: string, headerKey?: 'PUBLIC KEY' | 'RSA PRIVATE KEY' | 'PRIVATE KEY' | 'CERTIFICATE'): string;
//# sourceMappingURL=x509-utils.d.ts.map