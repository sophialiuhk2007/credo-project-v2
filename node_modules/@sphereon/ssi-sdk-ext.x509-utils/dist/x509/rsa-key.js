"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRSAKeyAsPEM = exports.cryptoSubtleImportRSAKey = exports.signAlgorithmToSchemeAndHashAlg = void 0;
const u8a = __importStar(require("uint8arrays"));
const x509_utils_1 = require("./x509-utils");
const usage = (jwk) => {
    var _a, _b, _c, _d;
    if (jwk.key_ops && jwk.key_ops.length > 0) {
        return jwk.key_ops;
    }
    if (jwk.use) {
        const usages = [];
        if (jwk.use.includes('sig')) {
            usages.push('sign', 'verify');
        }
        else if (jwk.use.includes('enc')) {
            usages.push('encrypt', 'decrypt');
        }
        if (usages.length > 0) {
            return usages;
        }
    }
    if (jwk.kty === 'RSA') {
        if (jwk.d) {
            return ((_b = (_a = jwk.alg) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === null || _b === void 0 ? void 0 : _b.includes('QAEP')) ? ['encrypt'] : ['sign'];
        }
        return ((_d = (_c = jwk.alg) === null || _c === void 0 ? void 0 : _c.toUpperCase()) === null || _d === void 0 ? void 0 : _d.includes('QAEP')) ? ['decrypt'] : ['verify'];
    }
    // "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey";
    return jwk.d && jwk.kty !== 'RSA' ? ['sign', 'decrypt', 'verify', 'encrypt'] : ['verify'];
};
const signAlgorithmToSchemeAndHashAlg = (signingAlg) => {
    const alg = signingAlg.toUpperCase();
    let scheme;
    if (alg.startsWith('RS')) {
        scheme = 'RSASSA-PKCS1-V1_5';
    }
    else if (alg.startsWith('PS')) {
        scheme = 'RSA-PSS';
    }
    else {
        throw Error(`Invalid signing algorithm supplied ${signingAlg}`);
    }
    const hashAlgorithm = `SHA-${alg.substring(2)}`;
    return { scheme, hashAlgorithm };
};
exports.signAlgorithmToSchemeAndHashAlg = signAlgorithmToSchemeAndHashAlg;
const cryptoSubtleImportRSAKey = (jwk, scheme, hashAlgorithm) => __awaiter(void 0, void 0, void 0, function* () {
    const hashName = hashAlgorithm ? hashAlgorithm : jwk.alg ? `SHA-${jwk.alg.substring(2)}` : 'SHA-256';
    const importParams = { name: scheme, hash: hashName };
    return yield crypto.subtle.importKey('jwk', jwk, importParams, false, usage(jwk));
});
exports.cryptoSubtleImportRSAKey = cryptoSubtleImportRSAKey;
const generateRSAKeyAsPEM = (scheme, hashAlgorithm, modulusLength) => __awaiter(void 0, void 0, void 0, function* () {
    const hashName = hashAlgorithm ? hashAlgorithm : 'SHA-256';
    const params = {
        name: scheme,
        hash: hashName,
        modulusLength: modulusLength ? modulusLength : 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
    };
    const keyUsage = scheme === 'RSA-PSS' || scheme === 'RSASSA-PKCS1-V1_5' ? ['sign', 'verify'] : ['encrypt', 'decrypt'];
    const keypair = yield crypto.subtle.generateKey(params, true, keyUsage);
    const pkcs8 = yield crypto.subtle.exportKey('pkcs8', keypair.privateKey);
    const uint8Array = new Uint8Array(pkcs8);
    return (0, x509_utils_1.derToPEM)(u8a.toString(uint8Array, 'base64pad'), 'RSA PRIVATE KEY');
});
exports.generateRSAKeyAsPEM = generateRSAKeyAsPEM;
//# sourceMappingURL=rsa-key.js.map