"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveExternalDidIdentifier = exports.resolveExternalCoseKeyIdentifier = exports.resolveExternalJwkIdentifier = exports.resolveExternalX5cIdentifier = exports.resolveExternalIdentifier = void 0;
const ssi_sdk_ext_did_utils_1 = require("@sphereon/ssi-sdk-ext.did-utils");
const ssi_sdk_ext_key_utils_1 = require("@sphereon/ssi-sdk-ext.key-utils");
const ssi_sdk_ext_x509_utils_1 = require("@sphereon/ssi-sdk-ext.x509-utils");
const ssi_sdk_agent_config_1 = require("@sphereon/ssi-sdk.agent-config");
const ssi_types_1 = require("@sphereon/ssi-types");
const utils_1 = require("@veramo/utils");
const pkijs_1 = require("pkijs");
const types_1 = require("../types");
function resolveExternalIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        let method;
        if ((0, types_1.isExternalIdentifierDidOpts)(opts)) {
            return resolveExternalDidIdentifier(opts, context);
        }
        else if ((0, types_1.isExternalIdentifierX5cOpts)(opts)) {
            return resolveExternalX5cIdentifier(opts, context);
        }
        else if ((0, types_1.isExternalIdentifierJwkOpts)(opts)) {
            return resolveExternalJwkIdentifier(opts, context);
        }
        else if ((0, types_1.isExternalIdentifierCoseKeyOpts)(opts)) {
            return resolveExternalCoseKeyIdentifier(opts, context);
        }
        else if ((0, types_1.isExternalIdentifierKidOpts)(opts)) {
            method = 'kid';
        }
        else if ((0, types_1.isExternalIdentifierJwksUrlOpts)(opts)) {
            method = 'jwks-url';
        }
        else if ((0, types_1.isExternalIdentifierOidcDiscoveryOpts)(opts)) {
            method = 'oidc-discovery';
        }
        throw Error(`External resolution method ${method} is not yet implemented`);
    });
}
exports.resolveExternalIdentifier = resolveExternalIdentifier;
function resolveExternalX5cIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        if (!(0, types_1.isExternalIdentifierX5cOpts)(opts)) {
            return Promise.reject('External x5c Identifier args need to be provided');
        }
        const verify = (_a = opts.verify) !== null && _a !== void 0 ? _a : true;
        const x5c = opts.identifier.map((derOrPem) => (derOrPem.includes('CERTIFICATE') ? (0, ssi_sdk_ext_x509_utils_1.PEMToDer)(derOrPem) : derOrPem));
        if (x5c.length === 0) {
            return Promise.reject('Empty certification chain is not allowed');
        }
        const certificates = x5c.map(ssi_sdk_ext_x509_utils_1.pemOrDerToX509Certificate);
        let verificationResult;
        let issuerJWK;
        let jwks = [];
        if (verify) {
            // We use the agent plugin if it is available as that is more powerful, but revert to the function otherwise
            if ((0, ssi_sdk_agent_config_1.contextHasPlugin)(context, 'verifyCertificateChain')) {
                verificationResult = (yield context.agent.verifyCertificateChain({
                    chain: opts.identifier,
                    trustAnchors: (_b = opts.trustAnchors) !== null && _b !== void 0 ? _b : [],
                    verificationTime: opts.verificationTime,
                })); // We need to cast, as we know this is the value and we do not want to rely on the x509 plugin perse
            }
            else {
                verificationResult = yield (0, ssi_sdk_ext_x509_utils_1.validateX509CertificateChain)({
                    chain: opts.identifier,
                    trustAnchors: (_c = opts.trustAnchors) !== null && _c !== void 0 ? _c : [],
                    verificationTime: opts.verificationTime,
                    opts,
                });
            }
            if (verificationResult.certificateChain) {
                jwks = verificationResult.certificateChain.map((cert) => {
                    return {
                        jwk: cert.publicKeyJWK,
                        kid: cert.subject.dn.DN,
                        jwkThumbprint: (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk: cert.publicKeyJWK }),
                        publicKeyHex: (0, ssi_sdk_ext_did_utils_1.jwkTtoPublicKeyHex)(cert.publicKeyJWK),
                    };
                });
            }
        }
        if (!jwks || jwks.length === 0) {
            const cryptoEngine = new pkijs_1.CryptoEngine({
                name: 'identifier_resolver_external',
                crypto: (_d = opts.crypto) !== null && _d !== void 0 ? _d : global.crypto,
            });
            (0, pkijs_1.setEngine)(cryptoEngine.name, cryptoEngine);
            jwks = yield Promise.all(certificates.map((cert) => __awaiter(this, void 0, void 0, function* () {
                const pk = yield cert.getPublicKey(undefined, cryptoEngine);
                const jwk = (yield cryptoEngine.exportKey('jwk', pk));
                return {
                    jwk,
                    kid: (0, ssi_sdk_ext_x509_utils_1.getSubjectDN)(cert).DN,
                    jwkThumbprint: (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk }),
                    publicKeyHex: (0, ssi_sdk_ext_did_utils_1.jwkTtoPublicKeyHex)(jwk),
                };
            })));
        }
        if (jwks.length === 0) {
            return Promise.reject('Empty certification chain is now allowed');
        }
        if (!issuerJWK) {
            issuerJWK = jwks[0].jwk;
        }
        return {
            method: 'x5c',
            verificationResult,
            issuerJWK,
            jwks,
            certificates,
            x5c,
        };
    });
}
exports.resolveExternalX5cIdentifier = resolveExternalX5cIdentifier;
/**
 * Resolves a JWK. Normally this is just returning the JWK, but in case the JWK contains a x5c the chain is validated
 * @param opts
 * @param context
 */
function resolveExternalJwkIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, types_1.isExternalIdentifierJwkOpts)(opts)) {
            return Promise.reject('External JWK Identifier args need to be provided');
        }
        const jwk = opts.identifier;
        let x5c = undefined;
        if (jwk.x5c) {
            x5c = yield resolveExternalX5cIdentifier(Object.assign(Object.assign({}, opts.x5c), { identifier: jwk.x5c }), context);
        }
        const jwkThumbprint = (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        return {
            method: 'jwk',
            jwk,
            jwks: [
                {
                    jwk,
                    jwkThumbprint,
                    kid: jwk.kid,
                    publicKeyHex: (0, ssi_sdk_ext_did_utils_1.jwkTtoPublicKeyHex)(jwk),
                },
            ],
            x5c,
        };
    });
}
exports.resolveExternalJwkIdentifier = resolveExternalJwkIdentifier;
/**
 * Resolves a JWK. Normally this is just returning the JWK, but in case the JWK contains a x5c the chain is validated
 * @param opts
 * @param context
 */
function resolveExternalCoseKeyIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, types_1.isExternalIdentifierCoseKeyOpts)(opts)) {
            return Promise.reject('External Cose Key args need to be provided');
        }
        // TODO: We need to do cbor conversion here as well.
        const coseKey = opts.identifier;
        let x5c = undefined;
        if (coseKey.x5chain) {
            x5c = yield resolveExternalX5cIdentifier(Object.assign(Object.assign({}, opts.x5c), { identifier: coseKey.x5chain }), context);
        }
        const jwk = (0, ssi_sdk_ext_key_utils_1.coseKeyToJwk)(coseKey);
        const jwkThumbprint = (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        return {
            method: 'cose_key',
            coseKey,
            jwks: [
                {
                    jwk,
                    jwkThumbprint,
                    kid: coseKey.kid,
                    publicKeyHex: (0, ssi_sdk_ext_did_utils_1.jwkTtoPublicKeyHex)(jwk),
                },
            ],
            x5c,
        };
    });
}
exports.resolveExternalCoseKeyIdentifier = resolveExternalCoseKeyIdentifier;
function resolveExternalDidIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!(0, types_1.isExternalIdentifierDidOpts)(opts)) {
            return Promise.reject('External DID Identifier args need to be provided');
        }
        else if (!(0, ssi_sdk_agent_config_1.contextHasPlugin)(context, 'resolveDid')) {
            return Promise.reject(Error(`Cannot get external DID identifier if DID resolver plugin is not enabled!`));
        }
        const { uniresolverResolution = false, localResolution = true, resolverResolution = true } = opts;
        const did = opts.identifier;
        let parsed;
        try {
            parsed = (0, ssi_types_1.parseDid)(did);
        }
        catch (error) {
            // Error from did resolution spec
            return Promise.reject(error);
        }
        const didParsed = parsed;
        const didResolutionResult = yield (0, ssi_sdk_ext_did_utils_1.getAgentResolver)(context, {
            uniresolverResolution,
            localResolution,
            resolverResolution,
        }).resolve(did);
        const didDocument = (_a = didResolutionResult.didDocument) !== null && _a !== void 0 ? _a : undefined;
        const didJwks = didDocument ? (0, ssi_sdk_ext_did_utils_1.didDocumentToJwks)(didDocument) : undefined;
        const jwks = didJwks
            ? Array.from(new Set(Object.values(didJwks)
                .filter((jwks) => (0, utils_1.isDefined)(jwks) && jwks.length > 0)
                .flatMap((jwks) => jwks))).map((jwk) => {
                return {
                    jwk,
                    jwkThumbprint: (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk }),
                    kid: jwk.kid,
                    publicKeyHex: (0, ssi_sdk_ext_did_utils_1.jwkTtoPublicKeyHex)(jwk),
                };
            })
            : [];
        if (didResolutionResult === null || didResolutionResult === void 0 ? void 0 : didResolutionResult.didDocument) {
            // @ts-ignore // Mandatory on the original object, but we already provide it directly
            delete didResolutionResult['didDocument'];
        }
        return {
            method: 'did',
            did,
            jwks,
            didJwks,
            didDocument,
            didResolutionResult,
            didParsed,
        };
    });
}
exports.resolveExternalDidIdentifier = resolveExternalDidIdentifier;
//# sourceMappingURL=externalIdentifierFunctions.js.map