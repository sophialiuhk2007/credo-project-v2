"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.managedIdentifierToJwk = exports.managedIdentifierToKeyResult = exports.getManagedIdentifier = exports.getManagedOID4VCIssuerIdentifier = exports.getManagedX5cIdentifier = exports.getManagedJwkIdentifier = exports.getManagedDidIdentifier = exports.getManagedCoseKeyIdentifier = exports.getManagedKeyIdentifier = exports.ensureManagedIdentifierResult = exports.isManagedIdentifierResult = exports.getManagedKidIdentifier = void 0;
const ssi_sdk_ext_did_utils_1 = require("@sphereon/ssi-sdk-ext.did-utils");
const ssi_sdk_ext_key_utils_1 = require("@sphereon/ssi-sdk-ext.key-utils");
const ssi_sdk_ext_x509_utils_1 = require("@sphereon/ssi-sdk-ext.x509-utils");
const ssi_sdk_agent_config_1 = require("@sphereon/ssi-sdk.agent-config");
const pkijs_1 = require("pkijs");
const types_1 = require("../types");
function getManagedKidIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const method = 'kid';
        if (!(0, ssi_sdk_agent_config_1.contextHasKeyManager)(context)) {
            return Promise.reject(Error(`Cannot get Key/JWK identifier if KeyManager plugin is not enabled!`));
        }
        else if (opts.identifier.startsWith('did:')) {
            return Promise.reject(Error(`managed kid resolution called but a did url was passed in. Please call the did resolution method`));
        }
        const key = yield context.agent.keyManagerGet({ kid: (_a = opts.kmsKeyRef) !== null && _a !== void 0 ? _a : opts.identifier });
        const jwk = (0, ssi_sdk_ext_key_utils_1.toJwk)(key.publicKeyHex, key.type, { key });
        const jwkThumbprint = (_c = (_b = key.meta) === null || _b === void 0 ? void 0 : _b.jwkThumbprint) !== null && _c !== void 0 ? _c : (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        const kid = (_g = (_d = opts.kid) !== null && _d !== void 0 ? _d : (_f = (_e = key.meta) === null || _e === void 0 ? void 0 : _e.verificationMethod) === null || _f === void 0 ? void 0 : _f.id) !== null && _g !== void 0 ? _g : jwkThumbprint;
        const issuer = (_h = opts.issuer) !== null && _h !== void 0 ? _h : kid; // The different identifiers should set the value. Defaults to the kid
        return {
            method,
            key,
            identifier: opts.identifier,
            jwk,
            jwkThumbprint,
            kid,
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            issuer,
            kmsKeyRef: key.kid,
            opts,
        };
    });
}
exports.getManagedKidIdentifier = getManagedKidIdentifier;
function isManagedIdentifierResult(identifier) {
    return 'key' in identifier && 'kmsKeyRef' in identifier && 'method' in identifier && 'opts' in identifier && 'jwkThumbprint' in identifier;
}
exports.isManagedIdentifierResult = isManagedIdentifierResult;
/**
 * Allows to get a managed identifier result in case identifier options are passed in, but returns the identifier directly in case results are passed in. This means resolution can have happened before, or happens in this method
 * @param identifier
 * @param context
 */
function ensureManagedIdentifierResult(identifier, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const { lazyDisabled = false } = identifier;
        return !lazyDisabled && isManagedIdentifierResult(identifier) ? identifier : yield getManagedIdentifier(identifier, context);
    });
}
exports.ensureManagedIdentifierResult = ensureManagedIdentifierResult;
/**
 * This function is just a convenience function to get a common result. The user already apparently had a key, so could have called the kid version as well
 * @param opts
 * @param _context
 */
function getManagedKeyIdentifier(opts, _context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g;
        const method = 'key';
        const key = opts.identifier;
        if (opts.kmsKeyRef && opts.kmsKeyRef !== key.kid) {
            return Promise.reject(Error(`Cannot get a managed key object by providing a key and a kmsKeyRef that are different.}`));
        }
        const jwk = (0, ssi_sdk_ext_key_utils_1.toJwk)(key.publicKeyHex, key.type, { key });
        const jwkThumbprint = (_b = (_a = key.meta) === null || _a === void 0 ? void 0 : _a.jwkThumbprint) !== null && _b !== void 0 ? _b : (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        const kid = (_f = (_c = opts.kid) !== null && _c !== void 0 ? _c : (_e = (_d = key.meta) === null || _d === void 0 ? void 0 : _d.verificationMethod) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : jwkThumbprint;
        const issuer = (_g = opts.issuer) !== null && _g !== void 0 ? _g : kid; // The different identifiers should set the value. Defaults to the kid
        return {
            method,
            key,
            identifier: key,
            jwk,
            jwkThumbprint,
            kid,
            issuer,
            kmsKeyRef: key.kid,
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            opts,
        };
    });
}
exports.getManagedKeyIdentifier = getManagedKeyIdentifier;
/**
 * This function is just a convenience function to get a common result. The user already apparently had a key, so could have called the kid version as well
 * @param opts
 * @param context
 */
function getManagedCoseKeyIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        const method = 'cose_key';
        const coseKey = opts.identifier;
        if (!(0, ssi_sdk_agent_config_1.contextHasKeyManager)(context)) {
            return Promise.reject(Error(`Cannot get Cose Key identifier if KeyManager plugin is not enabled!`));
        }
        const jwk = (0, ssi_sdk_ext_key_utils_1.coseKeyToJwk)(coseKey);
        const jwkThumbprint = (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        const key = yield context.agent.keyManagerGet({ kid: (_a = opts.kmsKeyRef) !== null && _a !== void 0 ? _a : jwkThumbprint });
        const kid = (_c = (_b = opts.kid) !== null && _b !== void 0 ? _b : coseKey.kid) !== null && _c !== void 0 ? _c : jwkThumbprint;
        const issuer = opts.issuer;
        return {
            method,
            key,
            identifier: opts.identifier,
            jwk,
            jwkThumbprint,
            kid,
            issuer,
            kmsKeyRef: key.kid,
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            opts,
        };
    });
}
exports.getManagedCoseKeyIdentifier = getManagedCoseKeyIdentifier;
function getManagedDidIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g;
        const method = 'did';
        if (!(0, ssi_sdk_agent_config_1.contextHasDidManager)(context)) {
            return Promise.reject(Error(`Cannot get DID identifier if DID Manager plugin is not enabled!`));
        }
        let identifier;
        if (typeof opts.identifier === 'string') {
            identifier = yield context.agent.didManagerGet({ did: opts.identifier.split('#')[0] });
        }
        else {
            identifier = opts.identifier;
        }
        const did = identifier.did;
        const keys = identifier === null || identifier === void 0 ? void 0 : identifier.keys; // fixme: We really want to return the vmRelationship keys here actually
        const extendedKey = yield (0, ssi_sdk_ext_did_utils_1.getFirstKeyWithRelation)(Object.assign(Object.assign({}, opts), { identifier, vmRelationship: (_a = opts.vmRelationship) !== null && _a !== void 0 ? _a : 'verificationMethod' }), context);
        const key = extendedKey;
        const controllerKeyId = identifier.controllerKeyId;
        const jwk = (0, ssi_sdk_ext_key_utils_1.toJwk)(key.publicKeyHex, key.type, { key });
        const jwkThumbprint = (_c = (_b = key.meta) === null || _b === void 0 ? void 0 : _b.jwkThumbprint) !== null && _c !== void 0 ? _c : (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        let kid = (_d = opts.kid) !== null && _d !== void 0 ? _d : (_f = (_e = extendedKey.meta) === null || _e === void 0 ? void 0 : _e.verificationMethod) === null || _f === void 0 ? void 0 : _f.id;
        if (!kid.startsWith(did)) {
            // Make sure we create a fully qualified kid
            const hash = kid.startsWith('#') ? '' : '#';
            kid = `${did}${hash}${kid}`;
        }
        const issuer = (_g = opts.issuer) !== null && _g !== void 0 ? _g : did;
        return {
            method,
            key,
            did,
            kmsKeyRef: key.kid,
            jwk,
            jwkThumbprint,
            controllerKeyId,
            kid,
            keys,
            issuer,
            identifier,
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            opts,
        };
    });
}
exports.getManagedDidIdentifier = getManagedDidIdentifier;
function getManagedJwkIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const method = 'jwk';
        const { kid, issuer } = opts;
        if (!(0, ssi_sdk_agent_config_1.contextHasKeyManager)(context)) {
            return Promise.reject(Error(`Cannot get Key/JWK identifier if KeyManager plugin is not enabled!`));
        }
        const key = yield context.agent.keyManagerGet({ kid: (_a = opts.kmsKeyRef) !== null && _a !== void 0 ? _a : (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk: opts.identifier }) });
        const jwk = (_b = opts.identifier) !== null && _b !== void 0 ? _b : (0, ssi_sdk_ext_key_utils_1.toJwk)(key.publicKeyHex, key.type, { key });
        const jwkThumbprint = (_d = (_c = key.meta) === null || _c === void 0 ? void 0 : _c.jwkThumbprint) !== null && _d !== void 0 ? _d : (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        // we explicitly do not set the kid and issuer, meaning it can remain null. Normally you do not provide a kid and issuer with Jwks.
        return {
            method,
            key,
            kmsKeyRef: key.kid,
            identifier: jwk,
            jwk,
            jwkThumbprint,
            kid,
            issuer,
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            opts,
        };
    });
}
exports.getManagedJwkIdentifier = getManagedJwkIdentifier;
function getManagedX5cIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const { kid, issuer } = opts;
        const method = 'x5c';
        const x5c = opts.identifier;
        if (x5c.length === 0) {
            return Promise.reject(`Cannot resolve x5c when an empty x5c is passed in`);
        }
        else if (!(0, ssi_sdk_agent_config_1.contextHasKeyManager)(context)) {
            return Promise.reject(Error(`Cannot get X5c identifier if KeyManager plugin is not enabled!`));
        }
        const cryptoImpl = (_a = opts.crypto) !== null && _a !== void 0 ? _a : crypto;
        const certificate = (0, ssi_sdk_ext_x509_utils_1.pemOrDerToX509Certificate)(x5c[0]);
        const cryptoEngine = new pkijs_1.CryptoEngine({ name: 'identifier_resolver_managed', crypto: cryptoImpl });
        (0, pkijs_1.setEngine)(cryptoEngine.name, cryptoEngine);
        const pk = yield certificate.getPublicKey(undefined, cryptoEngine);
        const jwk = (yield cryptoEngine.subtle.exportKey('jwk', pk));
        const jwkThumbprint = (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        const key = yield context.agent.keyManagerGet({ kid: (_b = opts.kmsKeyRef) !== null && _b !== void 0 ? _b : jwkThumbprint });
        // we explicitly do not set the kid and issuer, meaning it can remain null. Normally you do not provide a kid and issuer with x5c.
        return {
            method,
            x5c,
            identifier: x5c,
            certificate,
            jwk,
            jwkThumbprint,
            key,
            kmsKeyRef: key.kid,
            kid,
            issuer,
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            opts,
        };
    });
}
exports.getManagedX5cIdentifier = getManagedX5cIdentifier;
function getManagedOID4VCIssuerIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const { identifier } = opts;
        const method = 'oid4vci-issuer';
        // FIXME: We need to eventually determine the JWK based on the issuer. Using a dummy JWK for now
        const jwk = {
            "kty": "RSA",
            "kid": "dummy-jwk-for-vci-issuer-signing",
            "use": "sig",
            "n": "pjdss8ZaDfEH6K6U7GeW2nxDqR4IP049fk1fK0lndimbMMVBdPv_hSpm8T8EtBDxrUdi1OHZfMhUixGaut-3nQ4GG9nM249oxhCtxqqNvEXrmQRGqczyLxuh-fKn9Fg--hS9UpazHpfVAFnB5aCfXoNhPuI8oByyFKMKaOVgHNqP5NBEqabiLftZD3W_lsFCPGuzr4Vp0YS7zS2hDYScC2oOMu4rGU1LcMZf39p3153Cq7bS2Xh6Y-vw5pwzFYZdjQxDn8x8BG3fJ6j8TGLXQsbKH1218_HcUJRvMwdpbUQG5nvA2GXVqLqdwp054Lzk9_B_f1lVrmOKuHjTNHq48w",
            "e": "AQAB",
            "d": "ksDmucdMJXkFGZxiomNHnroOZxe8AmDLDGO1vhs-POa5PZM7mtUPonxwjVmthmpbZzla-kg55OFfO7YcXhg-Hm2OWTKwm73_rLh3JavaHjvBqsVKuorX3V3RYkSro6HyYIzFJ1Ek7sLxbjDRcDOj4ievSX0oN9l-JZhaDYlPlci5uJsoqro_YrE0PRRWVhtGynd-_aWgQv1YzkfZuMD-hJtDi1Im2humOWxA4eZrFs9eG-whXcOvaSwO4sSGbS99ecQZHM2TcdXeAs1PvjVgQ_dKnZlGN3lTWoWfQP55Z7Tgt8Nf1q4ZAKd-NlMe-7iqCFfsnFwXjSiaOa2CRGZn-Q",
            "p": "4A5nU4ahEww7B65yuzmGeCUUi8ikWzv1C81pSyUKvKzu8CX41hp9J6oRaLGesKImYiuVQK47FhZ--wwfpRwHvSxtNU9qXb8ewo-BvadyO1eVrIk4tNV543QlSe7pQAoJGkxCia5rfznAE3InKF4JvIlchyqs0RQ8wx7lULqwnn0",
            "q": "ven83GM6SfrmO-TBHbjTk6JhP_3CMsIvmSdo4KrbQNvp4vHO3w1_0zJ3URkmkYGhz2tgPlfd7v1l2I6QkIh4Bumdj6FyFZEBpxjE4MpfdNVcNINvVj87cLyTRmIcaGxmfylY7QErP8GFA-k4UoH_eQmGKGK44TRzYj5hZYGWIC8",
            "dp": "lmmU_AG5SGxBhJqb8wxfNXDPJjf__i92BgJT2Vp4pskBbr5PGoyV0HbfUQVMnw977RONEurkR6O6gxZUeCclGt4kQlGZ-m0_XSWx13v9t9DIbheAtgVJ2mQyVDvK4m7aRYlEceFh0PsX8vYDS5o1txgPwb3oXkPTtrmbAGMUBpE",
            "dq": "mxRTU3QDyR2EnCv0Nl0TCF90oliJGAHR9HJmBe__EjuCBbwHfcT8OG3hWOv8vpzokQPRl5cQt3NckzX3fs6xlJN4Ai2Hh2zduKFVQ2p-AF2p6Yfahscjtq-GY9cB85NxLy2IXCC0PF--Sq9LOrTE9QV988SJy_yUrAjcZ5MmECk",
            "qi": "ldHXIrEmMZVaNwGzDF9WG8sHj2mOZmQpw9yrjLK9hAsmsNr5LTyqWAqJIYZSwPTYWhY4nu2O0EY9G9uYiqewXfCKw_UngrJt8Xwfq1Zruz0YY869zPN4GiE9-9rzdZB33RBw8kIOquY3MK74FMwCihYx_LiU2YTHkaoJ3ncvtvg"
        };
        const jwkThumbprint = (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprint)({ jwk });
        const key = {
            kid: 'dummy-key-for-vci-issuer-signing',
            kms: 'local',
            type: "RSA",
            publicKeyHex: '9a3f75b2e4d8b91128fc6e9a8f6782e5a4f1cba3718e58b5d0a789d6e5f52b3a'
        };
        return {
            method,
            identifier,
            jwk,
            jwkThumbprint,
            key, // FIXME: We need construct a key as soon as we have the external VCI Issuer resolution
            kmsKeyRef: identifier, // FIXME: We need use kmsKeyRef as soon as we have the external VCI Issuer resolution
            issuer: identifier.replace('/.well-known/openid-credential-issuer', ''),
            clientId: opts.clientId,
            clientIdScheme: opts.clientIdScheme,
            opts,
        };
    });
}
exports.getManagedOID4VCIssuerIdentifier = getManagedOID4VCIssuerIdentifier;
function getManagedIdentifier(opts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        let resolutionResult;
        if (isManagedIdentifierResult(opts)) {
            opts;
        }
        if ((0, types_1.isManagedIdentifierKidOpts)(opts)) {
            resolutionResult = yield getManagedKidIdentifier(opts, context);
        }
        else if ((0, types_1.isManagedIdentifierDidOpts)(opts)) {
            resolutionResult = yield getManagedDidIdentifier(opts, context);
        }
        else if ((0, types_1.isManagedIdentifierJwkOpts)(opts)) {
            resolutionResult = yield getManagedJwkIdentifier(opts, context);
        }
        else if ((0, types_1.isManagedIdentifierX5cOpts)(opts)) {
            resolutionResult = yield getManagedX5cIdentifier(opts, context);
        }
        else if ((0, types_1.isManagedIdentifierKeyOpts)(opts)) {
            resolutionResult = yield getManagedKeyIdentifier(opts, context);
        }
        else if ((0, types_1.isManagedIdentifierCoseKeyOpts)(opts)) {
            resolutionResult = yield getManagedCoseKeyIdentifier(opts, context);
        }
        else if ((0, types_1.isManagedIdentifierOID4VCIssuerOpts)(opts)) {
            resolutionResult = yield getManagedOID4VCIssuerIdentifier(opts, context);
        }
        else {
            return Promise.reject(Error(`Could not determine identifier method. Please provide explicitly`));
        }
        const { key } = resolutionResult;
        if ((!key && !(0, types_1.isManagedIdentifierOID4VCIssuerOpts)(opts)) || ((0, types_1.isManagedIdentifierDidOpts)(opts) && (0, types_1.isManagedIdentifierDidResult)(resolutionResult) && !resolutionResult.identifier)) {
            console.log(`Cannot find identifier`, opts.identifier);
            return Promise.reject(`Cannot find identifier ${opts.identifier}`);
        }
        return resolutionResult;
    });
}
exports.getManagedIdentifier = getManagedIdentifier;
function managedIdentifierToKeyResult(identifier, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolved = yield ensureManagedIdentifierResult(identifier, context);
        if ((0, types_1.isManagedIdentifierKeyResult)(resolved)) {
            return resolved;
        }
        return Object.assign(Object.assign({}, resolved), { method: 'key', identifier: resolved.key });
    });
}
exports.managedIdentifierToKeyResult = managedIdentifierToKeyResult;
function managedIdentifierToJwk(identifier, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolved = yield ensureManagedIdentifierResult(identifier, context);
        if ((0, types_1.isManagedIdentifierJwkResult)(resolved)) {
            return resolved;
        }
        return Object.assign(Object.assign({}, resolved), { method: 'jwk', identifier: resolved.jwk });
    });
}
exports.managedIdentifierToJwk = managedIdentifierToJwk;
//# sourceMappingURL=managedIdentifierFunctions.js.map