"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDidSigner = exports.signDidJWT = exports.asDidWeb = exports.toDidResolutionResult = exports.toDidDocument = exports.AgentDIDResolver = exports.getAgentResolver = exports.getSupportedDIDMethods = exports.determineKid = exports.getKey = exports.toDIDs = exports.toDID = exports.getDID = exports.getAgentDIDMethods = exports.mapIdentifierKeysToDocWithJwkSupport = exports.didDocumentToJwks = exports.verificationMethodToJwk = exports.extractPublicKeyHex = exports.isEvenHexString = exports.extractPublicKeyHexWithJwkSupport = exports.jwkTtoPublicKeyHex = exports.dereferenceDidKeysWithJwkSupport = exports.getKeys = exports.getControllerKey = exports.getEthereumAddressFromKey = exports.getFirstKeyWithRelationFromDIDDoc = exports.createIdentifier = exports.getPrimaryIdentifier = exports.getOrCreatePrimaryIdentifier = exports.getFirstKeyWithRelation = exports.getAuthenticationKey = void 0;
const transactions_1 = require("@ethersproject/transactions");
const did_uni_client_1 = require("@sphereon/did-uni-client");
const ssi_sdk_ext_key_utils_1 = require("@sphereon/ssi-sdk-ext.key-utils");
const ssi_sdk_ext_x509_utils_1 = require("@sphereon/ssi-sdk-ext.x509-utils");
const ssi_sdk_core_1 = require("@sphereon/ssi-sdk.core");
const ed25519_1 = require("@stablelib/ed25519");
const utils_1 = require("@veramo/utils");
const did_jwt_1 = require("did-jwt");
// @ts-ignore
const elliptic_1 = __importDefault(require("elliptic"));
const u8a = __importStar(require("uint8arrays"));
const types_1 = require("./types");
const getAuthenticationKey = (_a, context_1) => __awaiter(void 0, [_a, context_1], void 0, function* ({ identifier, offlineWhenNoDIDRegistered, noVerificationMethodFallback, keyType, controllerKey, }, context) {
    return yield (0, exports.getFirstKeyWithRelation)({
        identifier,
        offlineWhenNoDIDRegistered,
        noVerificationMethodFallback,
        keyType,
        controllerKey,
        vmRelationship: 'authentication',
    }, context);
});
exports.getAuthenticationKey = getAuthenticationKey;
const getFirstKeyWithRelation = (_b, context_2) => __awaiter(void 0, [_b, context_2], void 0, function* ({ identifier, offlineWhenNoDIDRegistered, noVerificationMethodFallback, keyType, controllerKey, vmRelationship, }, context) {
    var _c, _d;
    let key = undefined;
    try {
        key =
            (_c = (yield (0, exports.getFirstKeyWithRelationFromDIDDoc)({
                identifier,
                vmRelationship,
                errorOnNotFound: false,
                keyType,
                controllerKey,
            }, context))) !== null && _c !== void 0 ? _c : (noVerificationMethodFallback || vmRelationship === 'verificationMethod' // let's not fallback to the same value again
                ? undefined
                : yield (0, exports.getFirstKeyWithRelationFromDIDDoc)({
                    identifier,
                    vmRelationship: 'verificationMethod',
                    errorOnNotFound: false,
                    keyType,
                    controllerKey,
                }, context));
    }
    catch (e) {
        if (e instanceof Error) {
            if (!e.message.includes('404') || !offlineWhenNoDIDRegistered) {
                throw e;
            }
        }
        else {
            throw e;
        }
    }
    if (!key && offlineWhenNoDIDRegistered) {
        const offlineDID = toDidDocument(identifier);
        key =
            (_d = (yield (0, exports.getFirstKeyWithRelationFromDIDDoc)({
                identifier,
                vmRelationship,
                errorOnNotFound: false,
                didDocument: offlineDID,
                keyType,
                controllerKey,
            }, context))) !== null && _d !== void 0 ? _d : (noVerificationMethodFallback || vmRelationship === 'verificationMethod' // let's not fallback to the same value again
                ? undefined
                : yield (0, exports.getFirstKeyWithRelationFromDIDDoc)({
                    identifier,
                    vmRelationship: 'verificationMethod',
                    errorOnNotFound: false,
                    didDocument: offlineDID,
                    keyType,
                    controllerKey,
                }, context));
        if (!key) {
            key = identifier.keys
                .map((key) => key)
                .filter((key) => keyType === undefined || key.type === keyType || (controllerKey && key.kid === identifier.controllerKeyId))
                .find((key) => { var _a, _b; return ((_a = key.meta.verificationMethod) === null || _a === void 0 ? void 0 : _a.type.includes('authentication')) || ((_b = key.meta.purposes) === null || _b === void 0 ? void 0 : _b.includes('authentication')); });
        }
    }
    if (!key) {
        throw Error(`Could not find authentication key for DID ${identifier.did}`);
    }
    return key;
});
exports.getFirstKeyWithRelation = getFirstKeyWithRelation;
const getOrCreatePrimaryIdentifier = (context, opts) => __awaiter(void 0, void 0, void 0, function* () {
    var _e, _f;
    const primaryIdentifier = yield (0, exports.getPrimaryIdentifier)(context, Object.assign(Object.assign({}, (_e = opts === null || opts === void 0 ? void 0 : opts.createOpts) === null || _e === void 0 ? void 0 : _e.options), ((opts === null || opts === void 0 ? void 0 : opts.method) && { method: opts.method })));
    if (primaryIdentifier !== undefined) {
        return {
            created: false,
            result: primaryIdentifier,
        };
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.method) === types_1.SupportedDidMethodEnum.DID_KEY) {
        const createOpts = (_f = opts === null || opts === void 0 ? void 0 : opts.createOpts) !== null && _f !== void 0 ? _f : {};
        createOpts.options = Object.assign({ codecName: 'EBSI', type: 'Secp256r1' }, createOpts);
        opts.createOpts = createOpts;
    }
    const createdIdentifier = yield (0, exports.createIdentifier)(context, opts);
    return {
        created: true,
        result: createdIdentifier,
    };
});
exports.getOrCreatePrimaryIdentifier = getOrCreatePrimaryIdentifier;
const getPrimaryIdentifier = (context, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const identifiers = (yield context.agent.didManagerFind((opts === null || opts === void 0 ? void 0 : opts.method) ? { provider: `${types_1.DID_PREFIX}${opts === null || opts === void 0 ? void 0 : opts.method}` } : {})).filter((identifier) => (opts === null || opts === void 0 ? void 0 : opts.type) === undefined || identifier.keys.some((key) => key.type === (opts === null || opts === void 0 ? void 0 : opts.type)));
    return identifiers && identifiers.length > 0 ? identifiers[0] : undefined;
});
exports.getPrimaryIdentifier = getPrimaryIdentifier;
const createIdentifier = (context, opts) => __awaiter(void 0, void 0, void 0, function* () {
    var _g, _h, _j, _k, _l, _m;
    return yield context.agent.didManagerCreate(Object.assign(Object.assign({ kms: yield (0, ssi_sdk_ext_key_utils_1.getKms)(context, (_g = opts === null || opts === void 0 ? void 0 : opts.createOpts) === null || _g === void 0 ? void 0 : _g.kms) }, ((opts === null || opts === void 0 ? void 0 : opts.method) && { provider: `${types_1.DID_PREFIX}${opts === null || opts === void 0 ? void 0 : opts.method}` })), { alias: (_j = (_h = opts === null || opts === void 0 ? void 0 : opts.createOpts) === null || _h === void 0 ? void 0 : _h.alias) !== null && _j !== void 0 ? _j : `${types_1.IdentifierAliasEnum.PRIMARY}-${opts === null || opts === void 0 ? void 0 : opts.method}-${(_l = (_k = opts === null || opts === void 0 ? void 0 : opts.createOpts) === null || _k === void 0 ? void 0 : _k.options) === null || _l === void 0 ? void 0 : _l.type}-${new Date().toUTCString()}`, options: (_m = opts === null || opts === void 0 ? void 0 : opts.createOpts) === null || _m === void 0 ? void 0 : _m.options }));
});
exports.createIdentifier = createIdentifier;
const getFirstKeyWithRelationFromDIDDoc = (_o, context_3) => __awaiter(void 0, [_o, context_3], void 0, function* ({ identifier, vmRelationship = 'verificationMethod', keyType, errorOnNotFound = false, didDocument, controllerKey, }, context) {
    const matchedKeys = yield mapIdentifierKeysToDocWithJwkSupport({ identifier, vmRelationship, didDocument }, context);
    if (Array.isArray(matchedKeys) && matchedKeys.length > 0) {
        const result = matchedKeys.find((key) => keyType === undefined || key.type === keyType || (controllerKey && key.kid === identifier.controllerKeyId));
        if (result) {
            return result;
        }
    }
    if (errorOnNotFound) {
        throw new Error(`Could not find key with relationship ${vmRelationship} in DID document for ${identifier.did}${keyType ? ' and key type: ' + keyType : ''}`);
    }
    return undefined;
});
exports.getFirstKeyWithRelationFromDIDDoc = getFirstKeyWithRelationFromDIDDoc;
const getEthereumAddressFromKey = ({ key }) => {
    var _a, _b, _c, _d, _e;
    if (key.type !== 'Secp256k1') {
        throw Error(`Can only get ethereum address from a Secp256k1 key. Type is ${key.type} for keyRef: ${key.kid}`);
    }
    const ethereumAddress = (_e = (_b = (_a = key.meta) === null || _a === void 0 ? void 0 : _a.ethereumAddress) !== null && _b !== void 0 ? _b : (_d = (_c = key.meta) === null || _c === void 0 ? void 0 : _c.account) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== null && _e !== void 0 ? _e : (0, transactions_1.computeAddress)(`0x${key.publicKeyHex}`).toLowerCase();
    if (!ethereumAddress) {
        throw Error(`Could not get or generate ethereum address from key with keyRef ${key.kid}`);
    }
    return ethereumAddress;
};
exports.getEthereumAddressFromKey = getEthereumAddressFromKey;
const getControllerKey = ({ identifier }) => {
    const key = identifier.keys.find((key) => key.kid === identifier.controllerKeyId);
    if (!key) {
        throw Error(`Could not get controller key for identifier ${identifier}`);
    }
    return key;
};
exports.getControllerKey = getControllerKey;
const getKeys = ({ jwkThumbprint, kms, identifier, kmsKeyRef, keyType, controllerKey, }) => {
    return identifier.keys
        .filter((key) => !keyType || key.type === keyType)
        .filter((key) => !kms || key.kms === kms)
        .filter((key) => !kmsKeyRef || key.kid === kmsKeyRef)
        .filter((key) => { var _a; return !jwkThumbprint || ((_a = key.meta) === null || _a === void 0 ? void 0 : _a.jwkThumbprint) === jwkThumbprint; })
        .filter((key) => !controllerKey || identifier.controllerKeyId === key.kid);
};
exports.getKeys = getKeys;
//TODO: Move to ssi-sdk/core and create PR upstream
/**
 * Dereferences keys from DID document and normalizes them for easy comparison.
 *
 * When dereferencing keyAgreement keys, only Ed25519 and X25519 curves are supported.
 * Other key types are omitted from the result and Ed25519 keys are converted to X25519
 *
 * @returns a Promise that resolves to the list of dereferenced keys.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function dereferenceDidKeysWithJwkSupport(didDocument_1) {
    return __awaiter(this, arguments, void 0, function* (didDocument, section = 'keyAgreement', context) {
        const convert = section === 'keyAgreement';
        if (section === 'service') {
            return [];
        }
        return (yield Promise.all((didDocument[section] || []).map((key) => __awaiter(this, void 0, void 0, function* () {
            if (typeof key === 'string') {
                try {
                    return (yield context.agent.getDIDComponentById({
                        didDocument,
                        didUrl: key,
                        section,
                    }));
                }
                catch (e) {
                    return null;
                }
            }
            else {
                return key;
            }
        }))))
            .filter(utils_1.isDefined)
            .map((key) => {
            const hexKey = extractPublicKeyHexWithJwkSupport(key, convert);
            const { publicKeyHex, publicKeyBase58, publicKeyBase64, publicKeyJwk } = key, keyProps = __rest(key, ["publicKeyHex", "publicKeyBase58", "publicKeyBase64", "publicKeyJwk"]);
            const newKey = Object.assign(Object.assign({}, keyProps), { publicKeyHex: hexKey });
            if (convert && 'Ed25519VerificationKey2018' === newKey.type) {
                newKey.type = 'X25519KeyAgreementKey2019';
            }
            return newKey;
        });
    });
}
exports.dereferenceDidKeysWithJwkSupport = dereferenceDidKeysWithJwkSupport;
function jwkTtoPublicKeyHex(jwk) {
    // todo: Hacky way to convert this to a VM. Should extract the logic from the below methods
    // @ts-ignore
    const vm = {
        publicKeyJwk: jwk,
    };
    return extractPublicKeyHexWithJwkSupport(vm);
}
exports.jwkTtoPublicKeyHex = jwkTtoPublicKeyHex;
/**
 * Converts the publicKey of a VerificationMethod to hex encoding (publicKeyHex)
 *
 * @param pk - the VerificationMethod to be converted
 * @param convert - when this flag is set to true, Ed25519 keys are converted to their X25519 pairs
 * @returns the hex encoding of the public key
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function extractPublicKeyHexWithJwkSupport(pk, convert = false) {
    if (pk.publicKeyJwk) {
        if (pk.publicKeyJwk.kty === 'EC') {
            const secp256 = new elliptic_1.default.ec(pk.publicKeyJwk.crv === 'secp256k1' ? 'secp256k1' : 'p256');
            const xHex = (0, ssi_sdk_ext_x509_utils_1.base64ToHex)(pk.publicKeyJwk.x, 'base64url');
            const yHex = (0, ssi_sdk_ext_x509_utils_1.base64ToHex)(pk.publicKeyJwk.y, 'base64url');
            const prefix = '04'; // isEven(yHex) ? '02' : '03'
            // Uncompressed Hex format: 04<x><y>
            // Compressed Hex format: 02<x> (for even y) or 03<x> (for uneven y)
            const hex = `${prefix}${xHex}${yHex}`;
            // We return directly as we don't want to convert the result back into Uint8Array and then convert again to hex as the elliptic lib already returns hex strings
            const publicKeyHex = secp256.keyFromPublic(hex, 'hex').getPublic(true, 'hex');
            // This returns a short form (x) with 02 or 03 prefix
            return publicKeyHex;
        }
        else if (pk.publicKeyJwk.crv === 'Ed25519') {
            return u8a.toString(u8a.fromString(pk.publicKeyJwk.x, 'base64url'), 'base16');
        }
        else if (pk.publicKeyJwk.kty === 'RSA') {
            return (0, ssi_sdk_ext_x509_utils_1.hexKeyFromPEMBasedJwk)(pk.publicKeyJwk, 'public');
        }
    }
    // delegate the other types to the original Veramo function
    return extractPublicKeyHex(pk, convert);
}
exports.extractPublicKeyHexWithJwkSupport = extractPublicKeyHexWithJwkSupport;
function isEvenHexString(hex) {
    const lastChar = hex[hex.length - 1].toLowerCase();
    return ['0', '2', '4', '6', '8', 'a', 'c', 'e'].includes(lastChar);
}
exports.isEvenHexString = isEvenHexString;
/**
 * Converts the publicKey of a VerificationMethod to hex encoding (publicKeyHex)
 *
 * @param pk - the VerificationMethod to be converted
 * @param convert - when this flag is set to true, Ed25519 keys are converted to their X25519 pairs
 * @returns the hex encoding of the public key
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function extractPublicKeyHex(pk, convert = false) {
    var _a, _b;
    let keyBytes = extractPublicKeyBytes(pk);
    if (convert) {
        if (['Ed25519', 'Ed25519VerificationKey2018', 'Ed25519VerificationKey2020'].includes(pk.type) ||
            (pk.type === 'JsonWebKey2020' && ((_a = pk.publicKeyJwk) === null || _a === void 0 ? void 0 : _a.crv) === 'Ed25519')) {
            keyBytes = (0, ed25519_1.convertPublicKeyToX25519)(keyBytes);
        }
        else if (!['X25519', 'X25519KeyAgreementKey2019', 'X25519KeyAgreementKey2020'].includes(pk.type) &&
            !(pk.type === 'JsonWebKey2020' && ((_b = pk.publicKeyJwk) === null || _b === void 0 ? void 0 : _b.crv) === 'X25519')) {
            return '';
        }
    }
    return (0, ssi_sdk_core_1.bytesToHex)(keyBytes);
}
exports.extractPublicKeyHex = extractPublicKeyHex;
function extractPublicKeyBytes(pk) {
    if (pk.publicKeyBase58) {
        return (0, ssi_sdk_core_1.base58ToBytes)(pk.publicKeyBase58);
    }
    else if (pk.publicKeyMultibase) {
        return (0, ssi_sdk_core_1.multibaseKeyToBytes)(pk.publicKeyMultibase);
    }
    else if (pk.publicKeyBase64) {
        return (0, ssi_sdk_core_1.base64ToBytes)(pk.publicKeyBase64);
    }
    else if (pk.publicKeyHex) {
        return (0, ssi_sdk_core_1.hexToBytes)(pk.publicKeyHex);
    }
    else if (pk.publicKeyJwk && (pk.publicKeyJwk.crv === 'secp256k1' || pk.publicKeyJwk.crv === 'P-256') && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
        const secp = new elliptic_1.default.ec(pk.publicKeyJwk.crv);
        return (0, ssi_sdk_core_1.hexToBytes)(secp
            .keyFromPublic({
            x: (0, ssi_sdk_ext_x509_utils_1.base64ToHex)(pk.publicKeyJwk.x, 'base64url'),
            y: (0, ssi_sdk_ext_x509_utils_1.base64ToHex)(pk.publicKeyJwk.y, 'base64url'),
        })
            .getPublic('hex'));
    }
    else if (pk.publicKeyJwk && (pk.publicKeyJwk.crv === 'Ed25519' || pk.publicKeyJwk.crv === 'X25519') && pk.publicKeyJwk.x) {
        return (0, ssi_sdk_core_1.base64ToBytes)(pk.publicKeyJwk.x);
    }
    return new Uint8Array();
}
function verificationMethodToJwk(vm) {
    var _a;
    let jwk = vm.publicKeyJwk;
    if (!jwk) {
        let publicKeyHex = (_a = vm.publicKeyHex) !== null && _a !== void 0 ? _a : u8a.toString(extractPublicKeyBytes(vm), 'hex');
        jwk = (0, ssi_sdk_ext_key_utils_1.toJwk)(publicKeyHex, (0, ssi_sdk_ext_key_utils_1.keyTypeFromCryptographicSuite)({ suite: vm.type }));
    }
    if (!jwk) {
        throw Error(`Could not convert verification method to jwk`);
    }
    jwk.kid = vm.id;
    return jwk;
}
exports.verificationMethodToJwk = verificationMethodToJwk;
function didDocumentSectionToJwks(didDocumentSection, searchForVerificationMethods, verificationMethods) {
    const jwks = (searchForVerificationMethods !== null && searchForVerificationMethods !== void 0 ? searchForVerificationMethods : [])
        .map((vmOrId) => (typeof vmOrId === 'object' ? vmOrId : verificationMethods === null || verificationMethods === void 0 ? void 0 : verificationMethods.find((vm) => vm.id === vmOrId)))
        .filter(utils_1.isDefined)
        .map((vm) => verificationMethodToJwk(vm));
    return { didDocumentSection, jwks: jwks };
}
function didDocumentToJwks(didDocument) {
    return {
        verificationMethod: [
            ...didDocumentSectionToJwks('publicKey', didDocument.publicKey, didDocument.verificationMethod).jwks, // legacy support
            ...didDocumentSectionToJwks('verificationMethod', didDocument.verificationMethod, didDocument.verificationMethod).jwks,
        ],
        assertionMethod: didDocumentSectionToJwks('assertionMethod', didDocument.assertionMethod, didDocument.verificationMethod).jwks,
        authentication: didDocumentSectionToJwks('authentication', didDocument.authentication, didDocument.verificationMethod).jwks,
        keyAgreement: didDocumentSectionToJwks('keyAgreement', didDocument.keyAgreement, didDocument.verificationMethod).jwks,
        capabilityInvocation: didDocumentSectionToJwks('capabilityInvocation', didDocument.capabilityInvocation, didDocument.verificationMethod).jwks,
        capabilityDelegation: didDocumentSectionToJwks('capabilityDelegation', didDocument.capabilityDelegation, didDocument.verificationMethod).jwks,
    };
}
exports.didDocumentToJwks = didDocumentToJwks;
/**
 * Maps the keys of a locally managed {@link @veramo/core#IIdentifier | IIdentifier} to the corresponding
 * {@link did-resolver#VerificationMethod | VerificationMethod} entries from the DID document.
 *
 * @param identifier - the identifier to be mapped
 * @param section - the section of the DID document to be mapped (see
 *   {@link https://www.w3.org/TR/did-core/#verification-relationships | verification relationships}), but can also be
 *   `verificationMethod` to map all the keys.
 * @param didDocument
 * @param context - the veramo agent context, which must contain a {@link @veramo/core#IResolver | IResolver}
 *   implementation that can resolve the DID document of the identifier.
 *
 * @returns an array of mapped keys. The corresponding verification method is added to the `meta.verificationMethod`
 *   property of the key.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function mapIdentifierKeysToDocWithJwkSupport(_a, context_4) {
    return __awaiter(this, arguments, void 0, function* ({ identifier, vmRelationship = 'verificationMethod', didDocument, }, context) {
        const didDoc = didDocument !== null && didDocument !== void 0 ? didDocument : (yield getAgentResolver(context)
            .resolve(identifier.did)
            .then((result) => result.didDocument));
        if (!didDoc) {
            throw Error(`Could not resolve DID ${identifier.did}`);
        }
        // const rsaDidWeb = identifier.keys && identifier.keys.length > 0 && identifier.keys.find((key) => key.type === 'RSA') && didDocument
        // We skip mapping in case the identifier is RSA and a did document is supplied.
        const keys = didDoc ? [] : yield (0, utils_1.mapIdentifierKeysToDoc)(identifier, vmRelationship, context);
        // dereference all key agreement keys from DID document and normalize
        const documentKeys = yield dereferenceDidKeysWithJwkSupport(didDoc, vmRelationship, context);
        const localKeys = vmRelationship === 'keyAgreement' ? (0, utils_1.convertIdentifierEncryptionKeys)(identifier) : (0, utils_1.compressIdentifierSecp256k1Keys)(identifier);
        // finally map the didDocument keys to the identifier keys by comparing `publicKeyHex`
        const extendedKeys = documentKeys
            .map((verificationMethod) => {
            /*if (verificationMethod.type !== 'JsonWebKey2020') {
                                                                                                        return null
                                                                                                      }*/
            const localKey = localKeys.find((localKey) => {
                var _a;
                return localKey.publicKeyHex === verificationMethod.publicKeyHex ||
                    ((_a = verificationMethod.publicKeyHex) === null || _a === void 0 ? void 0 : _a.startsWith(localKey.publicKeyHex)) ||
                    compareBlockchainAccountId(localKey, verificationMethod);
            });
            if (localKey) {
                const { meta } = localKey, localProps = __rest(localKey, ["meta"]);
                return Object.assign(Object.assign({}, localProps), { meta: Object.assign(Object.assign({}, meta), { verificationMethod }) });
            }
            else {
                return null;
            }
        })
            .filter(utils_1.isDefined);
        return keys.concat(extendedKeys);
    });
}
exports.mapIdentifierKeysToDocWithJwkSupport = mapIdentifierKeysToDocWithJwkSupport;
/**
 * Compares the `blockchainAccountId` of a `EcdsaSecp256k1RecoveryMethod2020` verification method with the address
 * computed from a locally managed key.
 *
 * @returns true if the local key address corresponds to the `blockchainAccountId`
 *
 * @param localKey - The locally managed key
 * @param verificationMethod - a {@link did-resolver#VerificationMethod | VerificationMethod} with a
 *   `blockchainAccountId`
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function compareBlockchainAccountId(localKey, verificationMethod) {
    var _a, _b;
    if ((verificationMethod.type !== 'EcdsaSecp256k1RecoveryMethod2020' && verificationMethod.type !== 'EcdsaSecp256k1VerificationKey2019') ||
        localKey.type !== 'Secp256k1') {
        return false;
    }
    let vmEthAddr = (0, utils_1.getEthereumAddress)(verificationMethod);
    if ((_a = localKey.meta) === null || _a === void 0 ? void 0 : _a.account) {
        return vmEthAddr === ((_b = localKey.meta) === null || _b === void 0 ? void 0 : _b.account.toLowerCase());
    }
    const computedAddr = (0, transactions_1.computeAddress)('0x' + localKey.publicKeyHex).toLowerCase();
    return computedAddr === vmEthAddr;
}
function getAgentDIDMethods(context) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield context.agent.didManagerGetProviders()).map((provider) => provider.toLowerCase().replace('did:', ''));
    });
}
exports.getAgentDIDMethods = getAgentDIDMethods;
function getDID(idOpts) {
    if (typeof idOpts.identifier === 'string') {
        return idOpts.identifier;
    }
    else if (typeof idOpts.identifier === 'object') {
        return idOpts.identifier.did;
    }
    throw Error(`Cannot get DID from identifier value`);
}
exports.getDID = getDID;
function toDID(identifier) {
    if (typeof identifier === 'string') {
        return identifier;
    }
    if (identifier.did) {
        return identifier.did;
    }
    throw Error(`No DID value present in identifier`);
}
exports.toDID = toDID;
function toDIDs(identifiers) {
    if (!identifiers) {
        return [];
    }
    return identifiers.map(toDID);
}
exports.toDIDs = toDIDs;
function getKey(_a, context_4) {
    return __awaiter(this, arguments, void 0, function* ({ identifier, vmRelationship = 'authentication', kmsKeyRef, }, context) {
        if (!identifier) {
            return Promise.reject(new Error(`No identifier provided to getKey method!`));
        }
        // normalize to kid, in case keyId was passed in as did#vm or #vm
        const kmsKeyRefParts = kmsKeyRef === null || kmsKeyRef === void 0 ? void 0 : kmsKeyRef.split(`#`);
        const kid = kmsKeyRefParts ? ((kmsKeyRefParts === null || kmsKeyRefParts === void 0 ? void 0 : kmsKeyRefParts.length) === 2 ? kmsKeyRefParts[1] : kmsKeyRefParts[0]) : undefined;
        // todo: We really should do a keyRef and external kid here
        let identifierKey = kmsKeyRef ? identifier.keys.find((key) => { var _a; return key.kid === kid || ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.jwkThumbprint) === kid; }) : undefined;
        if (!identifierKey) {
            const keys = yield mapIdentifierKeysToDocWithJwkSupport({ identifier, vmRelationship: vmRelationship }, context);
            if (!keys || keys.length === 0) {
                throw new Error(`No keys found for verificationMethodSection: ${vmRelationship} and did ${identifier.did}`);
            }
            if (kmsKeyRef) {
                identifierKey = keys.find((key) => { var _a, _b, _c; return ((_a = key.meta.verificationMethod) === null || _a === void 0 ? void 0 : _a.id) === kmsKeyRef || (kid && ((_c = (_b = key.meta.verificationMethod) === null || _b === void 0 ? void 0 : _b.id) === null || _c === void 0 ? void 0 : _c.includes(kid))); });
            }
            if (!identifierKey) {
                identifierKey = keys.find((key) => { var _a, _b; return ((_a = key.meta.verificationMethod) === null || _a === void 0 ? void 0 : _a.type) === vmRelationship || ((_b = key.meta.purposes) === null || _b === void 0 ? void 0 : _b.includes(vmRelationship)); });
            }
            if (!identifierKey) {
                identifierKey = keys[0];
            }
        }
        if (!identifierKey) {
            throw new Error(`No matching verificationMethodSection key found for keyId: ${kmsKeyRef} and vmSection: ${vmRelationship} for id ${identifier.did}`);
        }
        return identifierKey;
    });
}
exports.getKey = getKey;
/**
 *
 * @param identifier
 * @param context
 *
 * @deprecated Replaced by the identfier resolution plugin
 */
function legacyGetIdentifier(_a, context_4) {
    return __awaiter(this, arguments, void 0, function* ({ identifier, }, context) {
        if (typeof identifier === 'string') {
            return yield context.agent.didManagerGet({ did: identifier });
        }
        return identifier;
    });
}
/**
 * Get the real kid as used in JWTs. This is the kid in the VM or in the JWT, not the kid in the Veramo/Sphereon keystore. That was just a poorly chosen name
 * @param key
 * @param idOpts
 * @param context
 */
function determineKid(_a, context_4) {
    return __awaiter(this, arguments, void 0, function* ({ key, idOpts, }, context) {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if ((_c = (_b = key.meta) === null || _b === void 0 ? void 0 : _b.verificationMethod) === null || _c === void 0 ? void 0 : _c.id) {
            return (_e = (_d = key.meta) === null || _d === void 0 ? void 0 : _d.verificationMethod) === null || _e === void 0 ? void 0 : _e.id;
        }
        const identifier = yield legacyGetIdentifier(idOpts, context);
        const mappedKeys = yield mapIdentifierKeysToDocWithJwkSupport({
            identifier,
            vmRelationship: 'verificationMethod',
        }, context);
        const vmKey = mappedKeys.find((extendedKey) => extendedKey.kid === key.kid);
        if (vmKey) {
            return (_l = (_k = (_h = (_g = (_f = vmKey.meta) === null || _f === void 0 ? void 0 : _f.verificationMethod) === null || _g === void 0 ? void 0 : _g.id) !== null && _h !== void 0 ? _h : (_j = vmKey.meta) === null || _j === void 0 ? void 0 : _j.jwkThumbprint) !== null && _k !== void 0 ? _k : idOpts.kmsKeyRef) !== null && _l !== void 0 ? _l : vmKey.kid;
        }
        return (_p = (_o = (_m = key.meta) === null || _m === void 0 ? void 0 : _m.jwkThumbprint) !== null && _o !== void 0 ? _o : idOpts.kmsKeyRef) !== null && _p !== void 0 ? _p : key.kid;
    });
}
exports.determineKid = determineKid;
function getSupportedDIDMethods(didOpts, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = didOpts.supportedDIDMethods) !== null && _a !== void 0 ? _a : (yield getAgentDIDMethods(context));
    });
}
exports.getSupportedDIDMethods = getSupportedDIDMethods;
function getAgentResolver(context, opts) {
    return new AgentDIDResolver(context, opts);
}
exports.getAgentResolver = getAgentResolver;
class AgentDIDResolver {
    constructor(context, opts) {
        this.context = context;
        this.resolverResolution = (opts === null || opts === void 0 ? void 0 : opts.resolverResolution) !== false;
        this.uniresolverResolution = (opts === null || opts === void 0 ? void 0 : opts.uniresolverResolution) !== false;
        this.localResolution = (opts === null || opts === void 0 ? void 0 : opts.localResolution) !== false;
    }
    resolve(didUrl, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let resolutionResult;
            let origResolutionResult;
            let err;
            if (!this.resolverResolution && !this.localResolution && !this.uniresolverResolution) {
                throw Error(`No agent hosted DID resolution, regular agent resolution nor universal resolver resolution is enabled. Cannot resolve DIDs.`);
            }
            if (this.resolverResolution) {
                try {
                    resolutionResult = yield this.context.agent.resolveDid({ didUrl, options });
                }
                catch (error) {
                    err = error;
                }
            }
            if (resolutionResult) {
                origResolutionResult = resolutionResult;
                if (resolutionResult.didDocument === null) {
                    resolutionResult = undefined;
                }
            }
            else {
                console.log(`Agent resolver resolution is disabled. This typically isn't desirable!`);
            }
            if (!resolutionResult && this.localResolution) {
                console.log(`Using local DID resolution, looking at DIDs hosted by the agent.`);
                try {
                    const did = didUrl.split('#')[0];
                    const iIdentifier = yield this.context.agent.didManagerGet({ did });
                    resolutionResult = toDidResolutionResult(iIdentifier, { did });
                    if (resolutionResult.didDocument) {
                        err = undefined;
                    }
                    else {
                        console.log(`Local resolution resulted in a DID Document for ${did}`);
                    }
                }
                catch (error) {
                    if (!err) {
                        err = error;
                    }
                }
            }
            if (resolutionResult) {
                if (!origResolutionResult) {
                    origResolutionResult = resolutionResult;
                }
                if (!resolutionResult.didDocument) {
                    resolutionResult = undefined;
                }
            }
            if (!resolutionResult && this.uniresolverResolution) {
                console.log(`Using universal resolver resolution for did ${didUrl} `);
                resolutionResult = yield new did_uni_client_1.UniResolver().resolve(didUrl, options);
                if (!origResolutionResult) {
                    origResolutionResult = resolutionResult;
                }
                if (resolutionResult.didDocument) {
                    err = undefined;
                }
            }
            if (err) {
                // throw original error
                throw err;
            }
            if (!resolutionResult && !origResolutionResult) {
                throw `Could not resolve ${didUrl}. Resolutions tried: online: ${this.resolverResolution}, local: ${this.localResolution}, uni resolver: ${this.uniresolverResolution}`;
            }
            return resolutionResult !== null && resolutionResult !== void 0 ? resolutionResult : origResolutionResult;
        });
    }
}
exports.AgentDIDResolver = AgentDIDResolver;
/**
 * Please note that this is not an exact representation of the actual DID Document.
 *
 * We try to do our best, to map keys onto relevant verification methods and relationships, but we simply lack the context
 * of the actual DID method here. Do not relly on this method for DID resolution. It is only handy for offline use cases
 * when no DID Document is cached. For DID:WEB it does provide an accurate representation!
 *
 * @param identifier
 * @param opts
 */
function toDidDocument(identifier, opts) {
    var _a, _b, _c, _d, _e, _f;
    let didDocument = undefined;
    // TODO: Introduce jwk thumbprints here
    if (identifier) {
        const did = (_a = identifier.did) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.did;
        didDocument = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ '@context': 'https://www.w3.org/ns/did/v1', id: did, verificationMethod: identifier.keys.map((key) => {
                const vm = {
                    controller: did,
                    id: key.kid.startsWith(did) && key.kid.includes('#') ? key.kid : `${did}#${key.kid}`,
                    publicKeyJwk: (0, ssi_sdk_ext_key_utils_1.toJwk)(key.publicKeyHex, key.type, {
                        use: ssi_sdk_ext_key_utils_1.ENC_KEY_ALGS.includes(key.type) ? ssi_sdk_ext_key_utils_1.JwkKeyUse.Encryption : ssi_sdk_ext_key_utils_1.JwkKeyUse.Signature,
                        key,
                    }),
                    type: 'JsonWebKey2020',
                };
                return vm;
            }) }, (((opts === null || opts === void 0 ? void 0 : opts.use) === undefined || ((_b = opts === null || opts === void 0 ? void 0 : opts.use) === null || _b === void 0 ? void 0 : _b.includes(ssi_sdk_ext_key_utils_1.JwkKeyUse.Signature))) &&
            identifier.keys && {
            assertionMethod: identifier.keys
                .filter((key) => { var _a, _b, _c, _d; return ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.purpose) === undefined || ((_b = key === null || key === void 0 ? void 0 : key.meta) === null || _b === void 0 ? void 0 : _b.purpose) === 'assertionMethod' || ((_d = (_c = key === null || key === void 0 ? void 0 : key.meta) === null || _c === void 0 ? void 0 : _c.purposes) === null || _d === void 0 ? void 0 : _d.includes('assertionMethod')); })
                .map((key) => {
                if (key.kid.startsWith(did) && key.kid.includes('#')) {
                    return key.kid;
                }
                return `${did}#${key.kid}`;
            }),
        })), (((opts === null || opts === void 0 ? void 0 : opts.use) === undefined || ((_c = opts === null || opts === void 0 ? void 0 : opts.use) === null || _c === void 0 ? void 0 : _c.includes(ssi_sdk_ext_key_utils_1.JwkKeyUse.Signature))) &&
            identifier.keys && {
            authentication: identifier.keys
                .filter((key) => { var _a, _b, _c, _d; return ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.purpose) === undefined || ((_b = key === null || key === void 0 ? void 0 : key.meta) === null || _b === void 0 ? void 0 : _b.purpose) === 'authentication' || ((_d = (_c = key === null || key === void 0 ? void 0 : key.meta) === null || _c === void 0 ? void 0 : _c.purposes) === null || _d === void 0 ? void 0 : _d.includes('authentication')); })
                .map((key) => {
                if (key.kid.startsWith(did) && key.kid.includes('#')) {
                    return key.kid;
                }
                return `${did}#${key.kid}`;
            }),
        })), (((opts === null || opts === void 0 ? void 0 : opts.use) === undefined || ((_d = opts === null || opts === void 0 ? void 0 : opts.use) === null || _d === void 0 ? void 0 : _d.includes(ssi_sdk_ext_key_utils_1.JwkKeyUse.Encryption))) &&
            identifier.keys && {
            keyAgreement: identifier.keys
                .filter((key) => { var _a, _b, _c; return key.type === 'X25519' || ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.purpose) === 'keyAgreement' || ((_c = (_b = key === null || key === void 0 ? void 0 : key.meta) === null || _b === void 0 ? void 0 : _b.purposes) === null || _c === void 0 ? void 0 : _c.includes('keyAgreement')); })
                .map((key) => {
                if (key.kid.startsWith(did) && key.kid.includes('#')) {
                    return key.kid;
                }
                return `${did}#${key.kid}`;
            }),
        })), (((opts === null || opts === void 0 ? void 0 : opts.use) === undefined || ((_e = opts === null || opts === void 0 ? void 0 : opts.use) === null || _e === void 0 ? void 0 : _e.includes(ssi_sdk_ext_key_utils_1.JwkKeyUse.Encryption))) &&
            identifier.keys && {
            capabilityInvocation: identifier.keys
                .filter((key) => { var _a, _b, _c; return key.type === 'X25519' || ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.purpose) === 'capabilityInvocation' || ((_c = (_b = key === null || key === void 0 ? void 0 : key.meta) === null || _b === void 0 ? void 0 : _b.purposes) === null || _c === void 0 ? void 0 : _c.includes('capabilityInvocation')); })
                .map((key) => {
                if (key.kid.startsWith(did) && key.kid.includes('#')) {
                    return key.kid;
                }
                return `${did}#${key.kid}`;
            }),
        })), (((opts === null || opts === void 0 ? void 0 : opts.use) === undefined || ((_f = opts === null || opts === void 0 ? void 0 : opts.use) === null || _f === void 0 ? void 0 : _f.includes(ssi_sdk_ext_key_utils_1.JwkKeyUse.Encryption))) &&
            identifier.keys && {
            capabilityDelegation: identifier.keys
                .filter((key) => { var _a, _b, _c; return key.type === 'X25519' || ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.purpose) === 'capabilityDelegation' || ((_c = (_b = key === null || key === void 0 ? void 0 : key.meta) === null || _b === void 0 ? void 0 : _b.purposes) === null || _c === void 0 ? void 0 : _c.includes('capabilityDelegation')); })
                .map((key) => {
                if (key.kid.startsWith(did) && key.kid.includes('#')) {
                    return key.kid;
                }
                return `${did}#${key.kid}`;
            }),
        })), (identifier.services && identifier.services.length > 0 && { service: identifier.services }));
    }
    return didDocument;
}
exports.toDidDocument = toDidDocument;
function toDidResolutionResult(identifier, opts) {
    var _a;
    const didDocument = (_a = toDidDocument(identifier, opts)) !== null && _a !== void 0 ? _a : null; // null is used in case of errors and required by the did resolution spec
    const resolutionResult = {
        '@context': 'https://w3id.org/did-resolution/v1',
        didDocument,
        didResolutionMetadata: Object.assign(Object.assign({}, (!didDocument && { error: 'notFound' })), (Array.isArray(opts === null || opts === void 0 ? void 0 : opts.supportedMethods) &&
            identifier &&
            !(opts === null || opts === void 0 ? void 0 : opts.supportedMethods.includes(identifier.provider.replace('did:', ''))) && { error: 'unsupportedDidMethod' })),
        didDocumentMetadata: Object.assign({}, ((identifier === null || identifier === void 0 ? void 0 : identifier.alias) && { equivalentId: identifier === null || identifier === void 0 ? void 0 : identifier.alias })),
    };
    return resolutionResult;
}
exports.toDidResolutionResult = toDidResolutionResult;
function asDidWeb(hostnameOrDID) {
    return __awaiter(this, void 0, void 0, function* () {
        let did = hostnameOrDID;
        if (!did) {
            throw Error('Domain or DID expected, but received nothing.');
        }
        if (did.startsWith('did:web:')) {
            return did;
        }
        return `did:web:${did.replace(/https?:\/\/([^/?#]+).*/i, '$1').toLowerCase()}`;
    });
}
exports.asDidWeb = asDidWeb;
/**
 * @deprecated Replaced by the new signer service
 */
const signDidJWT = (args) => __awaiter(void 0, void 0, void 0, function* () {
    const { idOpts, header, payload, context, options } = args;
    const jwtOptions = Object.assign(Object.assign({}, options), { signer: yield (0, exports.getDidSigner)({ idOpts, context }) });
    return (0, did_jwt_1.createJWT)(payload, jwtOptions, header);
});
exports.signDidJWT = signDidJWT;
/**
 * @deprecated Replaced by the new signer service
 */
const getDidSigner = (args) => __awaiter(void 0, void 0, void 0, function* () {
    const { idOpts, context } = args;
    const identifier = yield legacyGetIdentifier(idOpts, context);
    const key = yield getKey({
        identifier,
        vmRelationship: idOpts.verificationMethodSection,
        kmsKeyRef: idOpts.kmsKeyRef,
    }, context);
    const algorithm = yield (0, ssi_sdk_ext_key_utils_1.signatureAlgorithmFromKey)({ key });
    return (data) => __awaiter(void 0, void 0, void 0, function* () {
        const input = data instanceof Object.getPrototypeOf(Uint8Array) ? new TextDecoder().decode(data) : data;
        return yield context.agent.keyManagerSign({
            keyRef: key.kid,
            algorithm,
            data: input,
        });
    });
});
exports.getDidSigner = getDidSigner;
//# sourceMappingURL=did-functions.js.map