import { JwkKeyUse, TKeyType } from '@sphereon/ssi-sdk-ext.key-utils';
import { JWK } from '@sphereon/ssi-types';
import { DIDDocument, DIDDocumentSection, DIDResolutionResult, IAgentContext, IDIDManager, IIdentifier, IKey, IResolver } from '@veramo/core';
import { _ExtendedIKey, _ExtendedVerificationMethod, _NormalizedVerificationMethod } from '@veramo/utils';
import { Signer } from 'did-jwt';
import { DIDResolutionOptions, Resolvable, VerificationMethod } from 'did-resolver';
import { CreateIdentifierOpts, CreateOrGetIdentifierOpts, GetOrCreateResult, GetSignerArgs, IdentifierProviderOpts, IDIDOptions, SignJwtArgs } from './types';
export declare const getAuthenticationKey: ({ identifier, offlineWhenNoDIDRegistered, noVerificationMethodFallback, keyType, controllerKey, }: {
    identifier: IIdentifier;
    keyType?: TKeyType;
    offlineWhenNoDIDRegistered?: boolean;
    noVerificationMethodFallback?: boolean;
    controllerKey?: boolean;
}, context: IAgentContext<IResolver & IDIDManager>) => Promise<_ExtendedIKey>;
export declare const getFirstKeyWithRelation: ({ identifier, offlineWhenNoDIDRegistered, noVerificationMethodFallback, keyType, controllerKey, vmRelationship, }: {
    identifier: IIdentifier;
    keyType?: TKeyType;
    offlineWhenNoDIDRegistered?: boolean;
    noVerificationMethodFallback?: boolean;
    controllerKey?: boolean;
    vmRelationship: DIDDocumentSection;
}, context: IAgentContext<IResolver & IDIDManager>) => Promise<_ExtendedIKey>;
export declare const getOrCreatePrimaryIdentifier: (context: IAgentContext<IDIDManager>, opts?: CreateOrGetIdentifierOpts) => Promise<GetOrCreateResult<IIdentifier>>;
export declare const getPrimaryIdentifier: (context: IAgentContext<IDIDManager>, opts?: IdentifierProviderOpts) => Promise<IIdentifier | undefined>;
export declare const createIdentifier: (context: IAgentContext<IDIDManager>, opts?: CreateIdentifierOpts) => Promise<IIdentifier>;
export declare const getFirstKeyWithRelationFromDIDDoc: ({ identifier, vmRelationship, keyType, errorOnNotFound, didDocument, controllerKey, }: {
    identifier: IIdentifier;
    controllerKey?: boolean;
    vmRelationship?: DIDDocumentSection;
    keyType?: TKeyType;
    errorOnNotFound?: boolean;
    didDocument?: DIDDocument;
}, context: IAgentContext<IResolver & IDIDManager>) => Promise<_ExtendedIKey | undefined>;
export declare const getEthereumAddressFromKey: ({ key }: {
    key: IKey;
}) => any;
export declare const getControllerKey: ({ identifier }: {
    identifier: IIdentifier;
}) => IKey;
export declare const getKeys: ({ jwkThumbprint, kms, identifier, kmsKeyRef, keyType, controllerKey, }: {
    identifier: IIdentifier;
    kmsKeyRef?: string;
    keyType?: TKeyType;
    kms?: string;
    jwkThumbprint?: string;
    controllerKey?: boolean;
}) => IKey[];
/**
 * Dereferences keys from DID document and normalizes them for easy comparison.
 *
 * When dereferencing keyAgreement keys, only Ed25519 and X25519 curves are supported.
 * Other key types are omitted from the result and Ed25519 keys are converted to X25519
 *
 * @returns a Promise that resolves to the list of dereferenced keys.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
export declare function dereferenceDidKeysWithJwkSupport(didDocument: DIDDocument, section: DIDDocumentSection | undefined, context: IAgentContext<IResolver>): Promise<_NormalizedVerificationMethod[]>;
export declare function jwkTtoPublicKeyHex(jwk: JWK): string;
/**
 * Converts the publicKey of a VerificationMethod to hex encoding (publicKeyHex)
 *
 * @param pk - the VerificationMethod to be converted
 * @param convert - when this flag is set to true, Ed25519 keys are converted to their X25519 pairs
 * @returns the hex encoding of the public key
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
export declare function extractPublicKeyHexWithJwkSupport(pk: _ExtendedVerificationMethod, convert?: boolean): string;
export declare function isEvenHexString(hex: string): boolean;
/**
 * Converts the publicKey of a VerificationMethod to hex encoding (publicKeyHex)
 *
 * @param pk - the VerificationMethod to be converted
 * @param convert - when this flag is set to true, Ed25519 keys are converted to their X25519 pairs
 * @returns the hex encoding of the public key
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
export declare function extractPublicKeyHex(pk: _ExtendedVerificationMethod, convert?: boolean): string;
export declare function verificationMethodToJwk(vm: VerificationMethod): JWK;
export type DidDocumentJwks = Record<Exclude<DIDDocumentSection, 'publicKey' | 'service'>, Array<JWK>>;
export declare function didDocumentToJwks(didDocument: DIDDocument): DidDocumentJwks;
/**
 * Maps the keys of a locally managed {@link @veramo/core#IIdentifier | IIdentifier} to the corresponding
 * {@link did-resolver#VerificationMethod | VerificationMethod} entries from the DID document.
 *
 * @param identifier - the identifier to be mapped
 * @param section - the section of the DID document to be mapped (see
 *   {@link https://www.w3.org/TR/did-core/#verification-relationships | verification relationships}), but can also be
 *   `verificationMethod` to map all the keys.
 * @param didDocument
 * @param context - the veramo agent context, which must contain a {@link @veramo/core#IResolver | IResolver}
 *   implementation that can resolve the DID document of the identifier.
 *
 * @returns an array of mapped keys. The corresponding verification method is added to the `meta.verificationMethod`
 *   property of the key.
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
export declare function mapIdentifierKeysToDocWithJwkSupport({ identifier, vmRelationship, didDocument, }: {
    identifier: IIdentifier;
    vmRelationship?: DIDDocumentSection;
    didDocument?: DIDDocument;
}, context: IAgentContext<IResolver & IDIDManager>): Promise<_ExtendedIKey[]>;
export declare function getAgentDIDMethods(context: IAgentContext<IDIDManager>): Promise<string[]>;
export declare function getDID(idOpts: {
    identifier: IIdentifier | string;
}): string;
export declare function toDID(identifier: string | IIdentifier | Partial<IIdentifier>): string;
export declare function toDIDs(identifiers?: (string | IIdentifier | Partial<IIdentifier>)[]): string[];
export declare function getKey({ identifier, vmRelationship, kmsKeyRef, }: {
    identifier: IIdentifier;
    vmRelationship?: DIDDocumentSection;
    kmsKeyRef?: string;
}, context: IAgentContext<IResolver & IDIDManager>): Promise<IKey>;
/**
 * Get the real kid as used in JWTs. This is the kid in the VM or in the JWT, not the kid in the Veramo/Sphereon keystore. That was just a poorly chosen name
 * @param key
 * @param idOpts
 * @param context
 */
export declare function determineKid({ key, idOpts, }: {
    key: IKey;
    idOpts: {
        identifier: IIdentifier | string;
        kmsKeyRef?: string;
    };
}, context: IAgentContext<IResolver & IDIDManager>): Promise<string>;
export declare function getSupportedDIDMethods(didOpts: IDIDOptions, context: IAgentContext<IDIDManager>): Promise<string[]>;
export declare function getAgentResolver(context: IAgentContext<IResolver & IDIDManager>, opts?: {
    localResolution?: boolean;
    uniresolverResolution?: boolean;
    resolverResolution?: boolean;
}): Resolvable;
export declare class AgentDIDResolver implements Resolvable {
    private readonly context;
    private readonly resolverResolution;
    private readonly uniresolverResolution;
    private readonly localResolution;
    constructor(context: IAgentContext<IResolver & IDIDManager>, opts?: {
        uniresolverResolution?: boolean;
        localResolution?: boolean;
        resolverResolution?: boolean;
    });
    resolve(didUrl: string, options?: DIDResolutionOptions): Promise<DIDResolutionResult>;
}
/**
 * Please note that this is not an exact representation of the actual DID Document.
 *
 * We try to do our best, to map keys onto relevant verification methods and relationships, but we simply lack the context
 * of the actual DID method here. Do not relly on this method for DID resolution. It is only handy for offline use cases
 * when no DID Document is cached. For DID:WEB it does provide an accurate representation!
 *
 * @param identifier
 * @param opts
 */
export declare function toDidDocument(identifier?: IIdentifier, opts?: {
    did?: string;
    use?: JwkKeyUse[];
}): DIDDocument | undefined;
export declare function toDidResolutionResult(identifier?: IIdentifier, opts?: {
    did?: string;
    supportedMethods?: string[];
}): DIDResolutionResult;
export declare function asDidWeb(hostnameOrDID: string): Promise<string>;
/**
 * @deprecated Replaced by the new signer service
 */
export declare const signDidJWT: (args: SignJwtArgs) => Promise<string>;
/**
 * @deprecated Replaced by the new signer service
 */
export declare const getDidSigner: (args: GetSignerArgs & {
    idOpts: {
        /**
         * @deprecated
         */
        identifier: IIdentifier | string;
        /**
         * @deprecated
         */
        verificationMethodSection?: DIDDocumentSection;
        /**
         * @deprecated
         */
        kmsKeyRef?: string;
    };
}) => Promise<Signer>;
//# sourceMappingURL=did-functions.d.ts.map