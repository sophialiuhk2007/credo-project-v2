import { JoseSignatureAlgorithm, JWK } from '@sphereon/ssi-types';
import { IAgentContext, IKey, IKeyManager, ManagedKeyInfo, MinimalImportableKey } from '@veramo/core';
import { JsonWebKey } from 'did-resolver';
import { IImportProvidedOrGeneratedKeyArgs, JwkKeyUse, KeyTypeFromCryptographicSuiteArgs, SignatureAlgorithmFromKeyArgs, SignatureAlgorithmFromKeyTypeArgs, TKeyType } from './types';
export declare const logger: import("@sphereon/ssi-types").ISimpleLogger<unknown>;
/**
 * Function that returns the provided KMS name or the default KMS name if none is provided.
 * The default KMS is either explicitly defined during agent construction, or the first KMS available in the system
 * @param context
 * @param kms. Optional KMS to use. If provided will be the returned name. Otherwise the default KMS will be returned
 */
export declare const getKms: (context: IAgentContext<any>, kms?: string) => Promise<string>;
/**
 * Generates a random Private Hex Key for the specified key type
 * @param type The key type
 * @return The private key in Hex form
 */
export declare const generatePrivateKeyHex: (type: TKeyType) => Promise<string>;
/**
 * We optionally generate and then import our own keys.
 *
 * @param args The key arguments
 * @param context The Veramo agent context
 * @private
 */
export declare function importProvidedOrGeneratedKey(args: IImportProvidedOrGeneratedKeyArgs & {
    kms: string;
}, context: IAgentContext<IKeyManager>): Promise<IKey>;
export declare const calculateJwkThumbprintForKey: (args: {
    key: IKey | MinimalImportableKey | ManagedKeyInfo;
    digestAlgorithm?: 'sha256' | 'sha512';
}) => string;
export declare const toBase64url: (input: string) => string;
/**
 * Calculate the JWK thumbprint
 * @param args
 */
export declare const calculateJwkThumbprint: (args: {
    jwk: JWK;
    digestAlgorithm?: 'sha256' | 'sha512';
}) => string;
export declare const toJwkFromKey: (key: IKey | MinimalImportableKey | ManagedKeyInfo, opts?: {
    use?: JwkKeyUse;
    noKidThumbprint?: boolean;
}) => JWK;
/**
 * Converts a public key in hex format to a JWK
 * @param publicKeyHex public key in hex
 * @param type The type of the key (Ed25519, Secp256k1/r1)
 * @param opts. Options, like the optional use for the key (sig/enc)
 * @return The JWK
 */
export declare const toJwk: (publicKeyHex: string, type: TKeyType, opts?: {
    use?: JwkKeyUse;
    key?: IKey | MinimalImportableKey;
    isPrivateKey?: boolean;
    noKidThumbprint?: boolean;
}) => JWK;
/**
 * Determines the use param based upon the key/signature type or supplied use value.
 *
 * @param type The key type
 * @param suppliedUse A supplied use. Will be used in case it is present
 */
export declare const jwkDetermineUse: (type: TKeyType, suppliedUse?: JwkKeyUse) => JwkKeyUse | undefined;
export declare const padLeft: (args: {
    data: string;
    size?: number;
    padString?: string;
}) => string;
export declare const isAsn1Der: (key: Uint8Array) => boolean;
export declare const asn1DerToRawPublicKey: (derKey: Uint8Array, keyType: TKeyType) => Uint8Array;
export declare const isRawCompressedPublicKey: (key: Uint8Array) => boolean;
export declare const toRawCompressedHexPublicKey: (rawPublicKey: Uint8Array, keyType: TKeyType) => string;
export declare const hexStringFromUint8Array: (value: Uint8Array) => string;
export declare const signatureAlgorithmFromKey: (args: SignatureAlgorithmFromKeyArgs) => Promise<JoseSignatureAlgorithm>;
export declare const signatureAlgorithmFromKeyType: (args: SignatureAlgorithmFromKeyTypeArgs) => JoseSignatureAlgorithm;
export declare const keyTypeFromCryptographicSuite: (args: KeyTypeFromCryptographicSuiteArgs) => TKeyType;
export declare function verifySignatureWithSubtle({ data, signature, key, crypto: cryptoArg, }: {
    data: Uint8Array;
    signature: Uint8Array;
    key: JsonWebKey;
    crypto?: Crypto;
}): Promise<boolean>;
//# sourceMappingURL=functions.d.ts.map