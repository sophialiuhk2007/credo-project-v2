import type { ByteView } from 'multiformats/codecs/interface';
/**
 * Extracts the required members of the JWK and canonicalizes it.
 *
 * @param jwk - The JWK to canonicalize.
 * @returns The JWK with only the required members, ordered lexicographically.
 */
export declare function minimalJwk(jwk: any): {
    crv: any;
    kty: any;
    x: any;
    y: any;
    e?: undefined;
    n?: undefined;
} | {
    crv: any;
    kty: any;
    x: any;
    y?: undefined;
    e?: undefined;
    n?: undefined;
} | {
    e: any;
    kty: any;
    n: any;
    crv?: undefined;
    x?: undefined;
    y?: undefined;
};
/**
 * Encodes a JWK into a Uint8Array. Only the required JWK members are encoded.
 *
 * @see https://www.rfc-editor.org/rfc/rfc7518#section-6
 * @see https://www.rfc-editor.org/rfc/rfc8037#section-2
 * @see https://github.com/panva/jose/blob/3b8aa47b92d07a711bf5c3125276cc9a011794a4/src/jwk/thumbprint.ts#L37
 *
 * @param jwk - JSON Web Key.
 * @returns Uint8Array-encoded JWK.
 */
export declare function jwkJcsEncode(jwk: unknown): Uint8Array;
/**
 * Decodes an array of bytes into a JWK. Throws an error if the JWK is not valid.
 *
 * @param bytes - The array of bytes to decode.
 * @returns The corresponding JSON Web Key.
 */
export declare function jwkJcsDecode(bytes: ByteView<JsonWebKey>): JsonWebKey;
export declare function jcsCanonicalize(object: any): string;
//# sourceMappingURL=jwk-jcs.d.ts.map