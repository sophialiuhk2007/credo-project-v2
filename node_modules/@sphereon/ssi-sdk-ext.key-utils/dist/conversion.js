"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.coseToJoseCurve = exports.joseToCoseCurve = exports.coseToJoseKeyOperation = exports.joseToCoseKeyOperation = exports.joseToCoseSignatureAlg = exports.coseToJoseSignatureAlg = exports.joseToCoseKty = exports.coseToJoseKty = exports.jwkToCoseKey = exports.coseKeyToJwk = void 0;
const ssi_types_1 = require("@sphereon/ssi-types");
function coseKeyToJwk(coseKey) {
    const { x5chain, key_ops, crv, alg, baseIV, kty } = coseKey, rest = __rest(coseKey, ["x5chain", "key_ops", "crv", "alg", "baseIV", "kty"]);
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), { kty: coseToJoseKty(kty) }), (crv && { crv: coseToJoseCurve(crv) })), (key_ops && { key_ops: key_ops.map(coseToJoseKeyOperation) })), (alg && { alg: coseToJoseSignatureAlg(alg) })), (baseIV && { iv: baseIV })), (x5chain && { x5c: x5chain }));
}
exports.coseKeyToJwk = coseKeyToJwk;
function jwkToCoseKey(jwk) {
    const { x5c, key_ops, crv, alg, iv, kty } = jwk, rest = __rest(jwk, ["x5c", "key_ops", "crv", "alg", "iv", "kty"]);
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), { kty: joseToCoseKty(kty) }), (crv && { crv: joseToCoseCurve(crv) })), (key_ops && { key_ops: key_ops.map(joseToCoseKeyOperation) })), (alg && { alg: joseToCoseSignatureAlg(alg) })), (iv && { baseIV: iv })), (x5c && { x5chain: x5c }));
}
exports.jwkToCoseKey = jwkToCoseKey;
function coseToJoseKty(kty) {
    switch (kty) {
        case ssi_types_1.ICoseKeyType.EC2:
            return ssi_types_1.JwkKeyType.EC;
        case ssi_types_1.ICoseKeyType.RSA:
            return ssi_types_1.JwkKeyType.RSA;
        case ssi_types_1.ICoseKeyType.Symmetric:
            return ssi_types_1.JwkKeyType.oct;
        case ssi_types_1.ICoseKeyType.OKP:
            return ssi_types_1.JwkKeyType.OKP;
        default:
            throw Error(`Key type ${kty} not supported in JWA`);
    }
}
exports.coseToJoseKty = coseToJoseKty;
function joseToCoseKty(kty) {
    switch (kty) {
        case 'EC':
            return ssi_types_1.ICoseKeyType.EC2;
        case 'RSA':
            return ssi_types_1.ICoseKeyType.RSA;
        case 'oct':
            return ssi_types_1.ICoseKeyType.Symmetric;
        case 'OKP':
            return ssi_types_1.ICoseKeyType.OKP;
        default:
            throw Error(`Key type ${kty} not supported in Cose`);
    }
}
exports.joseToCoseKty = joseToCoseKty;
function coseToJoseSignatureAlg(coseAlg) {
    switch (coseAlg) {
        case ssi_types_1.ICoseSignatureAlgorithm.ES256K:
            return ssi_types_1.JoseSignatureAlgorithm.ES256K;
        case ssi_types_1.ICoseSignatureAlgorithm.ES256:
            return ssi_types_1.JoseSignatureAlgorithm.ES256;
        case ssi_types_1.ICoseSignatureAlgorithm.ES384:
            return ssi_types_1.JoseSignatureAlgorithm.ES384;
        case ssi_types_1.ICoseSignatureAlgorithm.ES512:
            return ssi_types_1.JoseSignatureAlgorithm.ES512;
        case ssi_types_1.ICoseSignatureAlgorithm.PS256:
            return ssi_types_1.JoseSignatureAlgorithm.PS256;
        case ssi_types_1.ICoseSignatureAlgorithm.PS384:
            return ssi_types_1.JoseSignatureAlgorithm.PS384;
        case ssi_types_1.ICoseSignatureAlgorithm.PS512:
            return ssi_types_1.JoseSignatureAlgorithm.PS512;
        case ssi_types_1.ICoseSignatureAlgorithm.HS256:
            return ssi_types_1.JoseSignatureAlgorithm.HS256;
        case ssi_types_1.ICoseSignatureAlgorithm.HS384:
            return ssi_types_1.JoseSignatureAlgorithm.HS384;
        case ssi_types_1.ICoseSignatureAlgorithm.HS512:
            return ssi_types_1.JoseSignatureAlgorithm.HS512;
        case ssi_types_1.ICoseSignatureAlgorithm.EdDSA:
            return ssi_types_1.JoseSignatureAlgorithm.EdDSA;
        default:
            throw Error(`Signature algorithm ${coseAlg} not supported in Jose`);
    }
}
exports.coseToJoseSignatureAlg = coseToJoseSignatureAlg;
function joseToCoseSignatureAlg(joseAlg) {
    switch (joseAlg) {
        case (ssi_types_1.JoseSignatureAlgorithm.ES256K, 'ES256K'):
            return ssi_types_1.ICoseSignatureAlgorithm.ES256K;
        case (ssi_types_1.JoseSignatureAlgorithm.ES256, 'ES256'):
            return ssi_types_1.ICoseSignatureAlgorithm.ES256;
        case (ssi_types_1.JoseSignatureAlgorithm.ES384, 'ES384'):
            return ssi_types_1.ICoseSignatureAlgorithm.ES384;
        case (ssi_types_1.JoseSignatureAlgorithm.ES512, 'ES512'):
            return ssi_types_1.ICoseSignatureAlgorithm.ES512;
        case (ssi_types_1.JoseSignatureAlgorithm.PS256, 'PS256'):
            return ssi_types_1.ICoseSignatureAlgorithm.PS256;
        case (ssi_types_1.JoseSignatureAlgorithm.PS384, 'PS384'):
            return ssi_types_1.ICoseSignatureAlgorithm.PS384;
        case (ssi_types_1.JoseSignatureAlgorithm.PS512, 'PS512'):
            return ssi_types_1.ICoseSignatureAlgorithm.PS512;
        case (ssi_types_1.JoseSignatureAlgorithm.HS256, 'HS256'):
            return ssi_types_1.ICoseSignatureAlgorithm.HS256;
        case (ssi_types_1.JoseSignatureAlgorithm.HS384, 'HS384'):
            return ssi_types_1.ICoseSignatureAlgorithm.HS384;
        case (ssi_types_1.JoseSignatureAlgorithm.HS512, 'HS512'):
            return ssi_types_1.ICoseSignatureAlgorithm.HS512;
        case (ssi_types_1.JoseSignatureAlgorithm.EdDSA, 'EdDSA'):
            return ssi_types_1.ICoseSignatureAlgorithm.EdDSA;
        default:
            throw Error(`Signature algorithm ${joseAlg} not supported in Cose`);
    }
}
exports.joseToCoseSignatureAlg = joseToCoseSignatureAlg;
function joseToCoseKeyOperation(keyOp) {
    switch (keyOp) {
        case (ssi_types_1.JoseKeyOperation.SIGN, 'sign'):
            return ssi_types_1.ICoseKeyOperation.SIGN;
        case (ssi_types_1.JoseKeyOperation.VERIFY, 'verify'):
            return ssi_types_1.ICoseKeyOperation.VERIFY;
        case (ssi_types_1.JoseKeyOperation.ENCRYPT, 'encrypt'):
            return ssi_types_1.ICoseKeyOperation.ENCRYPT;
        case (ssi_types_1.JoseKeyOperation.DECRYPT, 'decrypt'):
            return ssi_types_1.ICoseKeyOperation.DECRYPT;
        case (ssi_types_1.JoseKeyOperation.WRAP_KEY, 'wrapKey'):
            return ssi_types_1.ICoseKeyOperation.WRAP_KEY;
        case (ssi_types_1.JoseKeyOperation.UNWRAP_KEY, 'unwrapKey'):
            return ssi_types_1.ICoseKeyOperation.UNWRAP_KEY;
        case (ssi_types_1.JoseKeyOperation.DERIVE_KEY, 'deriveKey'):
            return ssi_types_1.ICoseKeyOperation.DERIVE_KEY;
        case (ssi_types_1.JoseKeyOperation.DERIVE_BITS, 'deriveBits'):
            return ssi_types_1.ICoseKeyOperation.DERIVE_BITS;
        default:
            throw Error(`Key operation ${keyOp} not supported in Cose`);
    }
}
exports.joseToCoseKeyOperation = joseToCoseKeyOperation;
function coseToJoseKeyOperation(keyOp) {
    switch (keyOp) {
        case ssi_types_1.ICoseKeyOperation.SIGN:
            return ssi_types_1.JoseKeyOperation.SIGN;
        case ssi_types_1.ICoseKeyOperation.VERIFY:
            return ssi_types_1.JoseKeyOperation.VERIFY;
        case ssi_types_1.ICoseKeyOperation.ENCRYPT:
            return ssi_types_1.JoseKeyOperation.ENCRYPT;
        case ssi_types_1.ICoseKeyOperation.DECRYPT:
            return ssi_types_1.JoseKeyOperation.DECRYPT;
        case ssi_types_1.ICoseKeyOperation.WRAP_KEY:
            return ssi_types_1.JoseKeyOperation.WRAP_KEY;
        case ssi_types_1.ICoseKeyOperation.UNWRAP_KEY:
            return ssi_types_1.JoseKeyOperation.UNWRAP_KEY;
        case ssi_types_1.ICoseKeyOperation.DERIVE_KEY:
            return ssi_types_1.JoseKeyOperation.DERIVE_KEY;
        case ssi_types_1.ICoseKeyOperation.DERIVE_BITS:
            return ssi_types_1.JoseKeyOperation.DERIVE_BITS;
        default:
            throw Error(`Key operation ${keyOp} not supported in Jose`);
    }
}
exports.coseToJoseKeyOperation = coseToJoseKeyOperation;
function joseToCoseCurve(curve) {
    switch (curve) {
        case (ssi_types_1.JoseCurve.P_256, 'P-256'):
            return ssi_types_1.ICoseCurve.P_256;
        case (ssi_types_1.JoseCurve.P_384, 'P-384'):
            return ssi_types_1.ICoseCurve.P_384;
        case (ssi_types_1.JoseCurve.P_521, 'P-521'):
            return ssi_types_1.ICoseCurve.P_521;
        case (ssi_types_1.JoseCurve.X25519, 'X25519'):
            return ssi_types_1.ICoseCurve.X25519;
        case (ssi_types_1.JoseCurve.X448, 'X448'):
            return ssi_types_1.ICoseCurve.X448;
        case (ssi_types_1.JoseCurve.Ed25519, 'Ed25519'):
            return ssi_types_1.ICoseCurve.Ed25519;
        case (ssi_types_1.JoseCurve.Ed448, 'Ed448'):
            return ssi_types_1.ICoseCurve.Ed448;
        case (ssi_types_1.JoseCurve.secp256k1, 'secp256k1'):
            return ssi_types_1.ICoseCurve.secp256k1;
        default:
            throw Error(`Curve ${curve} not supported in Cose`);
    }
}
exports.joseToCoseCurve = joseToCoseCurve;
function coseToJoseCurve(curve) {
    switch (curve) {
        case ssi_types_1.ICoseCurve.P_256:
            return ssi_types_1.JoseCurve.P_256;
        case ssi_types_1.ICoseCurve.P_384:
            return ssi_types_1.JoseCurve.P_384;
        case ssi_types_1.ICoseCurve.P_521:
            return ssi_types_1.JoseCurve.P_521;
        case ssi_types_1.ICoseCurve.X25519:
            return ssi_types_1.JoseCurve.X25519;
        case ssi_types_1.ICoseCurve.X448:
            return ssi_types_1.JoseCurve.X448;
        case ssi_types_1.ICoseCurve.Ed25519:
            return ssi_types_1.JoseCurve.Ed25519;
        case ssi_types_1.ICoseCurve.Ed448:
            return ssi_types_1.JoseCurve.Ed448;
        case ssi_types_1.ICoseCurve.secp256k1:
            return ssi_types_1.JoseCurve.secp256k1;
        default:
            throw Error(`Curve ${curve} not supported in Jose`);
    }
}
exports.coseToJoseCurve = coseToJoseCurve;
//# sourceMappingURL=conversion.js.map