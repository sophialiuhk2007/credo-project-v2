"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignatureWithSubtle = exports.keyTypeFromCryptographicSuite = exports.signatureAlgorithmFromKeyType = exports.signatureAlgorithmFromKey = exports.hexStringFromUint8Array = exports.toRawCompressedHexPublicKey = exports.isRawCompressedPublicKey = exports.asn1DerToRawPublicKey = exports.isAsn1Der = exports.padLeft = exports.jwkDetermineUse = exports.toJwk = exports.toJwkFromKey = exports.calculateJwkThumbprint = exports.toBase64url = exports.calculateJwkThumbprintForKey = exports.importProvidedOrGeneratedKey = exports.generatePrivateKeyHex = exports.getKms = exports.logger = void 0;
const random_1 = require("@ethersproject/random");
const ssi_sdk_ext_x509_utils_1 = require("@sphereon/ssi-sdk-ext.x509-utils");
const ssi_types_1 = require("@sphereon/ssi-types");
const ed25519_1 = require("@stablelib/ed25519");
const elliptic_1 = __importDefault(require("elliptic"));
const u8a = __importStar(require("uint8arrays"));
const digest_methods_1 = require("./digest-methods");
const types_1 = require("./types");
exports.logger = ssi_types_1.Loggers.DEFAULT.get('sphereon:key-utils');
/**
 * Function that returns the provided KMS name or the default KMS name if none is provided.
 * The default KMS is either explicitly defined during agent construction, or the first KMS available in the system
 * @param context
 * @param kms. Optional KMS to use. If provided will be the returned name. Otherwise the default KMS will be returned
 */
const getKms = (context, kms) => __awaiter(void 0, void 0, void 0, function* () {
    if (kms) {
        return kms;
    }
    if (!context.agent.availableMethods().includes('keyManagerGetDefaultKeyManagementSystem')) {
        throw Error('Cannot determine default KMS if not provided and a non Sphereon Key Manager is being used');
    }
    return context.agent.keyManagerGetDefaultKeyManagementSystem();
});
exports.getKms = getKms;
/**
 * Generates a random Private Hex Key for the specified key type
 * @param type The key type
 * @return The private key in Hex form
 */
const generatePrivateKeyHex = (type) => __awaiter(void 0, void 0, void 0, function* () {
    switch (type) {
        case 'Ed25519': {
            const keyPairEd25519 = (0, ed25519_1.generateKeyPair)();
            return u8a.toString(keyPairEd25519.secretKey, 'base16');
        }
        // The Secp256 types use the same method to generate the key
        case 'Secp256r1':
        case 'Secp256k1': {
            const privateBytes = (0, random_1.randomBytes)(32);
            return u8a.toString(privateBytes, 'base16');
        }
        case 'RSA': {
            const pem = yield (0, ssi_sdk_ext_x509_utils_1.generateRSAKeyAsPEM)('RSA-PSS', 'SHA-256', 2048);
            return (0, ssi_sdk_ext_x509_utils_1.privateKeyHexFromPEM)(pem);
        }
        default:
            throw Error(`not_supported: Key type ${type} not yet supported for this did:jwk implementation`);
    }
});
exports.generatePrivateKeyHex = generatePrivateKeyHex;
const keyMetaAlgorithmsFromKeyType = (type) => {
    switch (type) {
        case 'Ed25519':
            return ['Ed25519', 'EdDSA'];
        case 'ES256K':
        case 'Secp256k1':
            return ['ES256K', 'ES256K-R', 'eth_signTransaction', 'eth_signTypedData', 'eth_signMessage', 'eth_rawSign'];
        case 'Secp256r1':
            return ['ES256'];
        case 'X25519':
            return ['ECDH', 'ECDH-ES', 'ECDH-1PU'];
        case 'RSA':
            return ['RS256', 'RS512', 'PS256', 'PS512'];
    }
    return [type];
};
/**
 * We optionally generate and then import our own keys.
 *
 * @param args The key arguments
 * @param context The Veramo agent context
 * @private
 */
function importProvidedOrGeneratedKey(args, context) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        // @ts-ignore
        const type = (_g = (_e = (_b = (_a = args.options) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_d = (_c = args.options) === null || _c === void 0 ? void 0 : _c.key) === null || _d === void 0 ? void 0 : _d.type) !== null && _e !== void 0 ? _e : (_f = args.options) === null || _f === void 0 ? void 0 : _f.keyType) !== null && _g !== void 0 ? _g : 'Secp256r1';
        const key = (_h = args === null || args === void 0 ? void 0 : args.options) === null || _h === void 0 ? void 0 : _h.key;
        // Make sure x509 options are also set on the metadata as that is what the kms will look for
        if (((_j = args.options) === null || _j === void 0 ? void 0 : _j.x509) && key) {
            key.meta = Object.assign(Object.assign({}, key.meta), { x509: Object.assign(Object.assign({}, args.options.x509), (_k = key.meta) === null || _k === void 0 ? void 0 : _k.x509) });
        }
        if (args.options && ((_l = args.options) === null || _l === void 0 ? void 0 : _l.use) === types_1.JwkKeyUse.Encryption && !types_1.ENC_KEY_ALGS.includes(type)) {
            throw new Error(`${type} keys are not valid for encryption`);
        }
        let privateKeyHex = undefined;
        if (key) {
            privateKeyHex = (_m = key.privateKeyHex) !== null && _m !== void 0 ? _m : (_p = (_o = key.meta) === null || _o === void 0 ? void 0 : _o.x509) === null || _p === void 0 ? void 0 : _p.privateKeyHex;
            if ((!privateKeyHex || privateKeyHex.trim() === '') && ((_r = (_q = key === null || key === void 0 ? void 0 : key.meta) === null || _q === void 0 ? void 0 : _q.x509) === null || _r === void 0 ? void 0 : _r.privateKeyPEM)) {
                // If we do not have a privateKeyHex but do have a PEM
                privateKeyHex = (0, ssi_sdk_ext_x509_utils_1.privateKeyHexFromPEM)(key.meta.x509.privateKeyPEM);
            }
        }
        if (privateKeyHex) {
            return context.agent.keyManagerImport(Object.assign(Object.assign({}, key), { kms: args.kms, type, privateKeyHex: privateKeyHex }));
        }
        return context.agent.keyManagerCreate({
            type,
            kms: args.kms,
            meta: Object.assign(Object.assign({}, key === null || key === void 0 ? void 0 : key.meta), { algorithms: keyMetaAlgorithmsFromKeyType(type), keyAlias: args.alias }),
        });
    });
}
exports.importProvidedOrGeneratedKey = importProvidedOrGeneratedKey;
const calculateJwkThumbprintForKey = (args) => {
    const { key } = args;
    const jwk = key.publicKeyHex
        ? (0, exports.toJwk)(key.publicKeyHex, key.type, { key: key, isPrivateKey: false })
        : 'privateKeyHex' in key && key.privateKeyHex
            ? (0, exports.toJwk)(key.privateKeyHex, key.type, { isPrivateKey: true })
            : undefined;
    if (!jwk) {
        throw Error(`Could not determine jwk from key ${key.kid}`);
    }
    return (0, exports.calculateJwkThumbprint)({ jwk, digestAlgorithm: args.digestAlgorithm });
};
exports.calculateJwkThumbprintForKey = calculateJwkThumbprintForKey;
const assertJwkClaimPresent = (value, description) => {
    if (typeof value !== 'string' || !value) {
        throw new Error(`${description} missing or invalid`);
    }
};
const toBase64url = (input) => u8a.toString(u8a.fromString(input), 'base64url');
exports.toBase64url = toBase64url;
/**
 * Calculate the JWK thumbprint
 * @param args
 */
const calculateJwkThumbprint = (args) => {
    const { jwk, digestAlgorithm = 'sha256' } = args;
    let components;
    switch (jwk.kty) {
        case 'EC':
            assertJwkClaimPresent(jwk.crv, '"crv" (Curve) Parameter');
            assertJwkClaimPresent(jwk.x, '"x" (X Coordinate) Parameter');
            assertJwkClaimPresent(jwk.y, '"y" (Y Coordinate) Parameter');
            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
            break;
        case 'OKP':
            assertJwkClaimPresent(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
            assertJwkClaimPresent(jwk.x, '"x" (Public Key) Parameter');
            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
            break;
        case 'RSA':
            assertJwkClaimPresent(jwk.e, '"e" (Exponent) Parameter');
            assertJwkClaimPresent(jwk.n, '"n" (Modulus) Parameter');
            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
            break;
        case 'oct':
            assertJwkClaimPresent(jwk.k, '"k" (Key Value) Parameter');
            components = { k: jwk.k, kty: jwk.kty };
            break;
        default:
            throw new Error('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = JSON.stringify(components);
    return digestAlgorithm === 'sha512'
        ? (0, digest_methods_1.digestMethodParams)('SHA-512').digestMethod(data, 'base64url')
        : (0, digest_methods_1.digestMethodParams)('SHA-256').digestMethod(data, 'base64url');
};
exports.calculateJwkThumbprint = calculateJwkThumbprint;
const toJwkFromKey = (key, opts) => {
    const isPrivateKey = 'privateKeyHex' in key;
    return (0, exports.toJwk)(key.publicKeyHex, key.type, Object.assign(Object.assign({}, opts), { key, isPrivateKey }));
};
exports.toJwkFromKey = toJwkFromKey;
/**
 * Converts a public key in hex format to a JWK
 * @param publicKeyHex public key in hex
 * @param type The type of the key (Ed25519, Secp256k1/r1)
 * @param opts. Options, like the optional use for the key (sig/enc)
 * @return The JWK
 */
const toJwk = (publicKeyHex, type, opts) => {
    const { key, noKidThumbprint = false } = opts !== null && opts !== void 0 ? opts : {};
    if (key && key.publicKeyHex !== publicKeyHex && (opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) !== true) {
        throw Error(`Provided key with id ${key.kid}, has a different public key hex ${key.publicKeyHex} than supplied public key ${publicKeyHex}`);
    }
    let jwk;
    switch (type) {
        case 'Ed25519':
            jwk = toEd25519OrX25519Jwk(publicKeyHex, Object.assign(Object.assign({}, opts), { crv: ssi_types_1.JoseCurve.Ed25519 }));
            break;
        case 'X25519':
            jwk = toEd25519OrX25519Jwk(publicKeyHex, Object.assign(Object.assign({}, opts), { crv: ssi_types_1.JoseCurve.X25519 }));
            break;
        case 'Secp256k1':
            jwk = toSecp256k1Jwk(publicKeyHex, opts);
            break;
        case 'Secp256r1':
            jwk = toSecp256r1Jwk(publicKeyHex, opts);
            break;
        case 'RSA':
            jwk = toRSAJwk(publicKeyHex, opts);
            break;
        default:
            throw new Error(`not_supported: Key type ${type} not yet supported for this did:jwk implementation`);
    }
    if (!jwk.kid && !noKidThumbprint) {
        jwk['kid'] = (0, exports.calculateJwkThumbprint)({ jwk });
    }
    return jwk;
};
exports.toJwk = toJwk;
/**
 * Determines the use param based upon the key/signature type or supplied use value.
 *
 * @param type The key type
 * @param suppliedUse A supplied use. Will be used in case it is present
 */
const jwkDetermineUse = (type, suppliedUse) => {
    return suppliedUse
        ? suppliedUse
        : types_1.SIG_KEY_ALGS.includes(type)
            ? types_1.JwkKeyUse.Signature
            : types_1.ENC_KEY_ALGS.includes(type)
                ? types_1.JwkKeyUse.Encryption
                : undefined;
};
exports.jwkDetermineUse = jwkDetermineUse;
/**
 * Assert the key has a proper length
 *
 * @param keyHex Input key
 * @param expectedKeyLength Expected key length(s)
 */
const assertProperKeyLength = (keyHex, expectedKeyLength) => {
    if (Array.isArray(expectedKeyLength)) {
        if (!expectedKeyLength.includes(keyHex.length)) {
            throw Error(`Invalid key length. Needs to be a hex string with length from ${JSON.stringify(expectedKeyLength)} instead of ${keyHex.length}. Input: ${keyHex}`);
        }
    }
    else if (keyHex.length !== expectedKeyLength) {
        throw Error(`Invalid key length. Needs to be a hex string with length ${expectedKeyLength} instead of ${keyHex.length}. Input: ${keyHex}`);
    }
};
/**
 * Generates a JWK from a Secp256k1 public key
 * @param keyHex Secp256k1 public or private key in hex
 * @param use The use for the key
 * @return The JWK
 */
const toSecp256k1Jwk = (keyHex, opts) => {
    const { use } = opts !== null && opts !== void 0 ? opts : {};
    exports.logger.debug(`toSecp256k1Jwk keyHex: ${keyHex}, length: ${keyHex.length}`);
    if (opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) {
        assertProperKeyLength(keyHex, [64]);
    }
    else {
        assertProperKeyLength(keyHex, [66, 130]);
    }
    const secp256k1 = new elliptic_1.default.ec('secp256k1');
    const keyBytes = u8a.fromString(keyHex, 'base16');
    const keyPair = (opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) ? secp256k1.keyFromPrivate(keyBytes) : secp256k1.keyFromPublic(keyBytes);
    const pubPoint = keyPair.getPublic();
    return Object.assign(Object.assign(Object.assign({ alg: ssi_types_1.JoseSignatureAlgorithm.ES256K }, (use !== undefined && { use })), { kty: ssi_types_1.JwkKeyType.EC, crv: ssi_types_1.JoseCurve.secp256k1, x: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(pubPoint.getX().toString('hex'), 'base64url'), y: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(pubPoint.getY().toString('hex'), 'base64url') }), ((opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) && { d: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(keyPair.getPrivate('hex'), 'base64url') }));
};
/**
 * Generates a JWK from a Secp256r1 public key
 * @param keyHex Secp256r1 public key in hex
 * @param use The use for the key
 * @return The JWK
 */
const toSecp256r1Jwk = (keyHex, opts) => {
    const { use } = opts !== null && opts !== void 0 ? opts : {};
    exports.logger.debug(`toSecp256r1Jwk keyHex: ${keyHex}, length: ${keyHex.length}`);
    if (opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) {
        assertProperKeyLength(keyHex, [64]);
    }
    else {
        assertProperKeyLength(keyHex, [66, 130]);
    }
    const secp256r1 = new elliptic_1.default.ec('p256');
    const keyBytes = u8a.fromString(keyHex, 'base16');
    exports.logger.debug(`keyBytes length: ${keyBytes}`);
    const keyPair = (opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) ? secp256r1.keyFromPrivate(keyBytes) : secp256r1.keyFromPublic(keyBytes);
    const pubPoint = keyPair.getPublic();
    return Object.assign(Object.assign(Object.assign({ alg: ssi_types_1.JoseSignatureAlgorithm.ES256 }, (use !== undefined && { use })), { kty: ssi_types_1.JwkKeyType.EC, crv: ssi_types_1.JoseCurve.P_256, x: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(pubPoint.getX().toString('hex'), 'base64url'), y: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(pubPoint.getY().toString('hex'), 'base64url') }), ((opts === null || opts === void 0 ? void 0 : opts.isPrivateKey) && { d: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(keyPair.getPrivate('hex'), 'base64url') }));
};
/**
 * Generates a JWK from an Ed25519/X25519 public key
 * @param publicKeyHex Ed25519/X25519 public key in hex
 * @param opts
 * @return The JWK
 */
const toEd25519OrX25519Jwk = (publicKeyHex, opts) => {
    var _a;
    assertProperKeyLength(publicKeyHex, 64);
    const { use } = opts !== null && opts !== void 0 ? opts : {};
    return Object.assign(Object.assign({ alg: ssi_types_1.JoseSignatureAlgorithm.EdDSA }, (use !== undefined && { use })), { kty: ssi_types_1.JwkKeyType.OKP, crv: (_a = opts === null || opts === void 0 ? void 0 : opts.crv) !== null && _a !== void 0 ? _a : ssi_types_1.JoseCurve.Ed25519, x: (0, ssi_sdk_ext_x509_utils_1.hexToBase64)(publicKeyHex, 'base64url') });
};
const toRSAJwk = (publicKeyHex, opts) => {
    var _a, _b, _c;
    const { key } = opts !== null && opts !== void 0 ? opts : {};
    // const publicKey = publicKeyHex
    // assertProperKeyLength(publicKey, [2048, 3072, 4096])
    if ((_a = key === null || key === void 0 ? void 0 : key.meta) === null || _a === void 0 ? void 0 : _a.publicKeyJwk) {
        return key.meta.publicKeyJwk;
    }
    const publicKeyPEM = (_c = (_b = key === null || key === void 0 ? void 0 : key.meta) === null || _b === void 0 ? void 0 : _b.publicKeyPEM) !== null && _c !== void 0 ? _c : (0, ssi_sdk_ext_x509_utils_1.hexToPEM)(publicKeyHex, 'public');
    return (0, ssi_sdk_ext_x509_utils_1.PEMToJwk)(publicKeyPEM, 'public');
};
const padLeft = (args) => {
    var _a, _b;
    const { data } = args;
    const size = (_a = args.size) !== null && _a !== void 0 ? _a : 32;
    const padString = (_b = args.padString) !== null && _b !== void 0 ? _b : '0';
    if (data.length >= size) {
        return data;
    }
    if (padString && padString.length === 0) {
        throw Error(`Pad string needs to have at least a length of 1`);
    }
    const length = padString.length;
    return padString.repeat((size - data.length) / length) + data;
};
exports.padLeft = padLeft;
var OIDType;
(function (OIDType) {
    OIDType[OIDType["Secp256k1"] = 0] = "Secp256k1";
    OIDType[OIDType["Secp256r1"] = 1] = "Secp256r1";
    OIDType[OIDType["Ed25519"] = 2] = "Ed25519";
})(OIDType || (OIDType = {}));
const OID = {
    [OIDType.Secp256k1]: new Uint8Array([0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01]),
    [OIDType.Secp256r1]: new Uint8Array([0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]),
    [OIDType.Ed25519]: new Uint8Array([0x06, 0x03, 0x2b, 0x65, 0x70]),
};
const compareUint8Arrays = (a, b) => {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
};
const findSubarray = (haystack, needle) => {
    for (let i = 0; i <= haystack.length - needle.length; i++) {
        if (compareUint8Arrays(haystack.subarray(i, i + needle.length), needle)) {
            return i;
        }
    }
    return -1;
};
const getTargetOID = (keyType) => {
    switch (keyType) {
        case 'Secp256k1':
            return OID[OIDType.Secp256k1];
        case 'Secp256r1':
            return OID[OIDType.Secp256r1];
        case 'Ed25519':
            return OID[OIDType.Ed25519];
        default:
            throw new Error(`Unsupported key type: ${keyType}`);
    }
};
const isAsn1Der = (key) => key[0] === 0x30;
exports.isAsn1Der = isAsn1Der;
const asn1DerToRawPublicKey = (derKey, keyType) => {
    if (!(0, exports.isAsn1Der)(derKey)) {
        throw new Error('Invalid DER encoding: Expected to start with sequence tag');
    }
    let index = 2;
    if (derKey[1] & 0x80) {
        const lengthBytesCount = derKey[1] & 0x7f;
        index += lengthBytesCount;
    }
    const targetOid = getTargetOID(keyType);
    const oidIndex = findSubarray(derKey, targetOid);
    if (oidIndex === -1) {
        throw new Error(`OID for ${keyType} not found in DER encoding`);
    }
    index = oidIndex + targetOid.length;
    while (index < derKey.length && derKey[index] !== 0x03) {
        index++;
    }
    if (index >= derKey.length) {
        throw new Error('Invalid DER encoding: Bit string not found');
    }
    // Skip the bit string tag (0x03) and length byte
    index += 2;
    // Skip the unused bits count byte
    index++;
    return derKey.slice(index);
};
exports.asn1DerToRawPublicKey = asn1DerToRawPublicKey;
const isRawCompressedPublicKey = (key) => key.length === 33 && (key[0] === 0x02 || key[0] === 0x03);
exports.isRawCompressedPublicKey = isRawCompressedPublicKey;
const toRawCompressedHexPublicKey = (rawPublicKey, keyType) => {
    if ((0, exports.isRawCompressedPublicKey)(rawPublicKey)) {
        throw new Error('Invalid public key format, an uncompressed raw public key is required as input, not a raw');
    }
    if (keyType === 'Secp256k1' || keyType === 'Secp256r1') {
        if (rawPublicKey[0] === 0x04 && rawPublicKey.length === 65) {
            const xCoordinate = rawPublicKey.slice(1, 33);
            const yCoordinate = rawPublicKey.slice(33);
            const prefix = new Uint8Array([yCoordinate[31] % 2 === 0 ? 0x02 : 0x03]);
            const resultKey = (0, exports.hexStringFromUint8Array)(new Uint8Array([...prefix, ...xCoordinate]));
            exports.logger.debug(`converted public key ${(0, exports.hexStringFromUint8Array)(rawPublicKey)} to ${resultKey}`);
            return resultKey;
        }
        return u8a.toString(rawPublicKey, 'base16');
    }
    else if (keyType === 'Ed25519') {
        // Ed25519 keys are always in compressed form
        return u8a.toString(rawPublicKey, 'base16');
    }
    throw new Error(`Unsupported key type: ${keyType}`);
};
exports.toRawCompressedHexPublicKey = toRawCompressedHexPublicKey;
const hexStringFromUint8Array = (value) => u8a.toString(value, 'base16');
exports.hexStringFromUint8Array = hexStringFromUint8Array;
const signatureAlgorithmFromKey = (args) => __awaiter(void 0, void 0, void 0, function* () {
    const { key } = args;
    return (0, exports.signatureAlgorithmFromKeyType)({ type: key.type });
});
exports.signatureAlgorithmFromKey = signatureAlgorithmFromKey;
const signatureAlgorithmFromKeyType = (args) => {
    const { type } = args;
    switch (type) {
        case 'Ed25519':
        case 'X25519':
            return ssi_types_1.JoseSignatureAlgorithm.EdDSA;
        case 'Secp256r1':
            return ssi_types_1.JoseSignatureAlgorithm.ES256;
        case 'Secp256k1':
            return ssi_types_1.JoseSignatureAlgorithm.ES256K;
        default:
            throw new Error(`Key type '${type}' not supported`);
    }
};
exports.signatureAlgorithmFromKeyType = signatureAlgorithmFromKeyType;
// TODO improve this conversion for jwt and jsonld, not a fan of current structure
const keyTypeFromCryptographicSuite = (args) => {
    const { suite } = args;
    switch (suite) {
        case 'EdDSA':
        case 'Ed25519Signature2018':
        case 'Ed25519Signature2020':
        case 'JcsEd25519Signature2020':
            return 'Ed25519';
        case 'JsonWebSignature2020':
        case 'ES256':
        case 'ECDSA':
            return 'Secp256r1';
        case 'EcdsaSecp256k1Signature2019':
        case 'ES256K':
            return 'Secp256k1';
        default:
            throw new Error(`Cryptographic suite '${suite}' not supported`);
    }
};
exports.keyTypeFromCryptographicSuite = keyTypeFromCryptographicSuite;
function verifySignatureWithSubtle(_a) {
    return __awaiter(this, arguments, void 0, function* ({ data, signature, key, crypto: cryptoArg, }) {
        var _b;
        let { alg, crv } = key;
        if (alg === 'ES256' || !alg) {
            alg = 'ECDSA';
        }
        const subtle = (_b = cryptoArg === null || cryptoArg === void 0 ? void 0 : cryptoArg.subtle) !== null && _b !== void 0 ? _b : crypto.subtle;
        const publicKey = yield subtle.importKey('jwk', key, {
            name: alg,
            namedCurve: crv,
        }, true, ['verify']);
        return subtle.verify({
            name: alg,
            hash: 'SHA-256', // fixme; make arg
        }, publicKey, signature, data);
    });
}
exports.verifySignatureWithSubtle = verifySignatureWithSubtle;
//# sourceMappingURL=functions.js.map