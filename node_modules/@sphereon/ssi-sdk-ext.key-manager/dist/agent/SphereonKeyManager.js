"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SphereonKeyManager = exports.sphereonKeyManagerMethods = void 0;
const ssi_sdk_ext_key_utils_1 = require("@sphereon/ssi-sdk-ext.key-utils");
const key_manager_1 = require("@veramo/key-manager");
const u8a = __importStar(require("uint8arrays"));
const ISphereonKeyManager_1 = require("../types/ISphereonKeyManager");
exports.sphereonKeyManagerMethods = [
    'keyManagerCreate',
    'keyManagerGet',
    'keyManagerImport',
    'keyManagerSign',
    'keyManagerVerify',
    'keyManagerListKeys',
    'keyManagerGetDefaultKeyManagementSystem',
    'keyManagerHandleExpirations',
];
class SphereonKeyManager extends key_manager_1.KeyManager {
    constructor(options) {
        var _a;
        super({ store: options.store, kms: options.kms });
        this.kmsStore = options.store;
        this.availableKmses = options.kms;
        this.defaultKms = (_a = options.defaultKms) !== null && _a !== void 0 ? _a : Object.keys(this.availableKmses)[0];
        if (!Object.keys(this.availableKmses).includes(this.defaultKms)) {
            throw Error(`Default KMS needs to be listed in the kms object as well. Found kms-es: ${Object.keys(this.availableKmses).join(',')}`);
        }
        const methods = this.methods;
        methods.keyManagerVerify = this.keyManagerVerify.bind(this);
        methods.keyManagerListKeys = this.keyManagerListKeys.bind(this);
        methods.keyManagerGetDefaultKeyManagementSystem = this.keyManagerGetDefaultKeyManagementSystem.bind(this);
        this.kmsMethods = methods;
    }
    keyManagerGetDefaultKeyManagementSystem() {
        return Promise.resolve(this.defaultKms);
    }
    keyManagerCreate(args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const kms = this.getKmsByName(args.kms);
            const meta = Object.assign(Object.assign({}, args.meta), (args.opts && { opts: args.opts }));
            if ((0, ISphereonKeyManager_1.hasKeyOptions)(meta) && ((_a = meta.opts) === null || _a === void 0 ? void 0 : _a.ephemeral) && !((_b = meta.opts.expiration) === null || _b === void 0 ? void 0 : _b.removalDate)) {
                // Make sure we set a delete date on an ephemeral key
                meta.opts = Object.assign(Object.assign({}, meta.opts), { expiration: Object.assign(Object.assign({}, (_c = meta.opts) === null || _c === void 0 ? void 0 : _c.expiration), { removalDate: new Date(Date.now() + 5 * 60 * 1000) }) });
            }
            const partialKey = yield kms.createKey({ type: args.type, meta });
            const key = Object.assign(Object.assign({}, partialKey), { kms: args.kms });
            key.meta = Object.assign(Object.assign({}, meta), key.meta);
            key.meta.jwkThumbprint = (_d = key.meta.jwkThumbprint) !== null && _d !== void 0 ? _d : (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprintForKey)({ key });
            yield this.kmsStore.import(key);
            if (key.privateKeyHex) {
                // Make sure to not export the private key
                delete key.privateKeyHex;
            }
            return key;
        });
    }
    //FIXME extend the IKeyManagerSignArgs.data to be a string or array of strings
    keyManagerSign(args) {
        const _super = Object.create(null, {
            keyManagerSign: { get: () => super.keyManagerSign }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const keyInfo = (yield this.kmsStore.get({ kid: args.keyRef }));
            const kms = this.getKmsByName(keyInfo.kms);
            if (keyInfo.type === 'Bls12381G2') {
                return yield kms.sign({ keyRef: keyInfo, data: typeof args.data === 'string' ? u8a.fromString(args.data) : args.data });
            }
            // @ts-ignore // we can pass in uint8arrays as well, which the super also can handle but does not expose in its types
            return yield _super.keyManagerSign.call(this, args);
        });
    }
    keyManagerVerify(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.kms) {
                const kms = this.getKmsByName(args.kms);
                if (kms && 'verify' in kms && typeof kms.verify === 'function') {
                    // @ts-ignore
                    return yield kms.verify(args);
                }
            }
            return yield (0, ssi_sdk_ext_key_utils_1.verifySignatureWithSubtle)({
                key: (0, ssi_sdk_ext_key_utils_1.toJwk)(args.publicKeyHex, args.type),
                data: args.data,
                signature: u8a.fromString(args.signature, 'utf-8'),
            });
        });
    }
    keyManagerListKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.kmsStore.list({});
        });
    }
    keyManagerHandleExpirations(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.keyManagerListKeys();
            const expiredKeys = keys
                .filter((key) => (0, ISphereonKeyManager_1.hasKeyOptions)(key.meta))
                .filter((key) => {
                var _a, _b;
                if ((0, ISphereonKeyManager_1.hasKeyOptions)(key.meta) && ((_b = (_a = key.meta) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.expiration)) {
                    const expiration = key.meta.opts.expiration;
                    return !(expiration.expiryDate && expiration.expiryDate.getMilliseconds() > Date.now());
                }
                return false;
            });
            if (args.skipRemovals !== true) {
                yield Promise.all(expiredKeys.map((key) => this.keyManagerDelete({ kid: key.kid })));
            }
            return keys;
        });
    }
    getKmsByName(name) {
        const kms = this.availableKmses[name];
        if (!kms) {
            throw Error(`invalid_argument: This agent has no registered KeyManagementSystem with name='${name}'`);
        }
        return kms;
    }
    //todo https://sphereon.atlassian.net/browse/SDK-28 improve the logic for keyManagerGet in sphereon-key-manager
    keyManagerGet(_a) {
        return __awaiter(this, arguments, void 0, function* ({ kid }) {
            try {
                const key = yield this.kmsStore.get({ kid });
                return key;
            }
            catch (e) {
                const keys = yield this.keyManagerListKeys();
                const foundKey = keys.find((key) => {
                    var _a, _b;
                    return key.publicKeyHex === kid ||
                        ((_a = key.meta) === null || _a === void 0 ? void 0 : _a.jwkThumbprint) === kid ||
                        (((_b = key.meta) === null || _b === void 0 ? void 0 : _b.jwkThumbprint) == null && (0, ssi_sdk_ext_key_utils_1.calculateJwkThumbprintForKey)({ key }) === kid);
                });
                if (foundKey) {
                    return foundKey;
                }
                else {
                    throw new Error(`Key with kid ${kid} not found`);
                }
            }
        });
    }
}
exports.SphereonKeyManager = SphereonKeyManager;
//# sourceMappingURL=SphereonKeyManager.js.map