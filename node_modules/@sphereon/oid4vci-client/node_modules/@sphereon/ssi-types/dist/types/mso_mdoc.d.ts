/**
 * Create some interface below to do a the mapping of the KMP library.
 * For now we are using the library directly, and thus do not need them,
 * but it would be nice if we can remove the imports and just have some interfaces here we can then use, like done
 * for sd-jwts
 */
import { com } from '@sphereon/kmp-mdl-mdoc';
import { OriginalType, WrappedVerifiableCredential, WrappedVerifiablePresentation } from './vc';
import { IVerifiableCredential } from './w3c-vc';
/**
 * Represents a selective disclosure JWT vc in compact form.
 */
export type MdocOid4vpIssuerSigned = string;
export type MdocOid4vpMdocVpToken = string;
export type MdocIssuerSigned = com.sphereon.mdoc.data.device.IssuerSignedCbor;
export type MdocDocument = com.sphereon.mdoc.data.device.DocumentCbor;
export type MdocDocumentJson = com.sphereon.mdoc.data.device.DocumentJson;
export type MdocDeviceResponse = com.sphereon.mdoc.data.device.DeviceResponseCbor;
export interface WrappedMdocCredential {
    /**
     * Original IssuerSigned to Mdoc that we've received. Can be either the encoded or decoded variant.
     */
    original: MdocDocument | MdocOid4vpIssuerSigned;
    /**
     * Decoded version of the Mdoc payload. We add the record to make sure existing implementations remain happy
     */
    decoded: MdocDocument & {
        [key: string]: any;
    };
    /**
     * Type of this credential.
     */
    type: OriginalType.MSO_MDOC_DECODED | OriginalType.MSO_MDOC_ENCODED;
    /**
     * The claim format, typically used during exchange transport protocols
     */
    format: 'mso_mdoc';
    /**
     * Internal stable representation of a Credential
     */
    credential: IVerifiableCredential;
}
export interface WrappedMdocPresentation {
    /**
     * Original VP that we've received. Can be either the encoded or decoded variant.
     */
    original: MdocDeviceResponse | MdocOid4vpMdocVpToken;
    /**
     * Decoded version of the SD-JWT payload. This is the decoded payload, rather than the whole SD-JWT.
     */
    decoded: MdocDeviceResponse;
    /**
     * Type of this Presentation.
     */
    type: OriginalType.MSO_MDOC_ENCODED | OriginalType.MSO_MDOC_DECODED;
    /**
     * The claim format, typically used during exchange transport protocols
     */
    format: 'mso_mdoc';
    /**
     * Internal stable representation of a Presentation
     */
    presentation: MdocDeviceResponse;
    /**
     * Wrapped Mdocs belonging to the Presentation. .
     */
    vcs: [WrappedMdocCredential];
}
export declare function isWrappedMdocCredential(vc: WrappedVerifiableCredential): vc is WrappedMdocCredential;
export declare function isWrappedMdocPresentation(vp: WrappedVerifiablePresentation): vp is WrappedMdocPresentation;
/**
 * Decode an Mdoc from its issuerSigned OID4VP Base64URL (string) to an object containing the disclosures,
 * signed payload, decoded payload
 *
 */
export declare function decodeMdocIssuerSigned(oid4vpIssuerSigned: MdocOid4vpIssuerSigned): MdocDocument;
/**
 * Decode an Mdoc from its vp_token OID4VP Base64URL (string) to an object containing the disclosures,
 * signed payload, decoded payload
 *
 */
export declare function decodeMdocDeviceResponse(vpToken: MdocOid4vpMdocVpToken): MdocDeviceResponse;
export declare const mdocDecodedCredentialToUniformCredential: (decoded: MdocDocument, opts?: {
    maxTimeSkewInMS?: number;
}) => IVerifiableCredential;
//# sourceMappingURL=mso_mdoc.d.ts.map