"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.concat = exports.bytesToMultibase = exports.getMultibasePropsByCode = exports.getMultibasePropsByType = exports.SUPPORTED_KEY_CODECS = exports.multibaseKeyToProps = exports.multibaseKeyToBytes = exports.bytesToBase58 = exports.base58ToBytes = exports.bytesToHex = exports.hexToBytes = exports.decodeJoseBlob = exports.encodeJoseBlob = exports.stringToUtf8Bytes = exports.bytesToUtf8String = exports.decodeBase64url = exports.encodeBase64url = exports.bytesToBase64 = exports.base64ToBytes = exports.bytesToBase64url = exports.multibaseToHex = exports.hexToMultibase = exports.MultibaseFormat = void 0;
const uint8arrays_1 = require("uint8arrays");
const varint_1 = __importDefault(require("./varint/varint"));
var MultibaseFormat;
(function (MultibaseFormat) {
    MultibaseFormat["BASE58"] = "z";
})(MultibaseFormat || (exports.MultibaseFormat = MultibaseFormat = {}));
function hexToMultibase(hex, type) {
    return { value: bytesToMultibase(hexToBytes(hex), type), format: MultibaseFormat.BASE58, keyType: type };
}
exports.hexToMultibase = hexToMultibase;
function multibaseToHex(multibase) {
    if (!multibase.startsWith(MultibaseFormat.BASE58)) {
        throw new Error('Only base58 supported for now using multibase!');
    }
    const props = multibaseKeyToProps(multibase);
    return { value: bytesToHex(multibaseKeyToBytes(multibase)), keyType: props.keyType, format: MultibaseFormat.BASE58 };
}
exports.multibaseToHex = multibaseToHex;
const u8a = { toString: uint8arrays_1.toString, fromString: uint8arrays_1.fromString, concatArrays: uint8arrays_1.concat };
/**
 * Converts a Uint8Array to a base64url string
 * @param b - the array to be converted
 *
 * @public
 */
function bytesToBase64url(b) {
    return u8a.toString(b, 'base64url');
}
exports.bytesToBase64url = bytesToBase64url;
/**
 * Converts a base64url string to the Uint8Array it represents.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
function base64ToBytes(s) {
    const inputBase64Url = s.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    return u8a.fromString(inputBase64Url, 'base64url');
}
exports.base64ToBytes = base64ToBytes;
/**
 * Encodes a Uint8Array to a base64 string representation with padding.
 * @param b - the byte array to convert
 *
 * @public
 */
function bytesToBase64(b) {
    return u8a.toString(b, 'base64pad');
}
exports.bytesToBase64 = bytesToBase64;
/**
 * Encodes the bytes of an input string to base64url
 * @param s - the original string
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function encodeBase64url(s) {
    return bytesToBase64url(u8a.fromString(s));
}
exports.encodeBase64url = encodeBase64url;
/**
 * Decodes a base64url string to a utf8 string represented by the same bytes.
 * @param s - the base64url string to be decoded
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function decodeBase64url(s) {
    return u8a.toString(base64ToBytes(s));
}
exports.decodeBase64url = decodeBase64url;
/**
 * Builds a string from a Uint8Array using the utf-8 encoding.
 * @param b - the array to be converted
 *
 * @public
 */
function bytesToUtf8String(b) {
    return u8a.toString(b, 'utf-8');
}
exports.bytesToUtf8String = bytesToUtf8String;
/**
 * Encodes a string to a Uint8Array using the utf-8 encoding.
 * @param s - the string to be encoded
 *
 * @public
 */
function stringToUtf8Bytes(s) {
    return u8a.fromString(s, 'utf-8');
}
exports.stringToUtf8Bytes = stringToUtf8Bytes;
/**
 * Stringifies a JSON object and encodes the bytes of the resulting string to a base64url representation.
 * @param payload - the object to be encoded
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function encodeJoseBlob(payload) {
    return u8a.toString(u8a.fromString(JSON.stringify(payload), 'utf-8'), 'base64url');
}
exports.encodeJoseBlob = encodeJoseBlob;
/**
 * Decodes a base64url string representing stringified JSON to a JSON object.
 *
 * @param blob - The base64url encoded stringified JSON to be decoded
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function decodeJoseBlob(blob) {
    return JSON.parse(u8a.toString(u8a.fromString(blob, 'base64url'), 'utf-8'));
}
exports.decodeJoseBlob = decodeJoseBlob;
/**
 * Converts a hex string (with or without prefix) to a byte array (Uint8Array)
 *
 * @param hexString - The string representing the encoding
 * @returns the `Uint8Array` represented by the given string
 *
 * @throws `illegal_argument` error if the parameter is not a string
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function hexToBytes(hexString) {
    // @ts-ignore
    if (hexString instanceof Uint8Array) {
        return Uint8Array.from(hexString);
    }
    if (typeof hexString !== 'string') {
        throw new Error('illegal_argument: a string must be provided for a hex-string to byte array conversion');
    }
    const noPrefix = hexString.startsWith('0x') ? hexString.substring(2) : hexString;
    const padded = noPrefix.length % 2 !== 0 ? `0${noPrefix}` : noPrefix;
    return u8a.fromString(padded.toLowerCase(), 'base16');
}
exports.hexToBytes = hexToBytes;
/**
 * Converts a Uint8Array input to a hex string
 *
 * @param byteArray - The array to be converted
 * @param prefix - If this is set to true, the resulting hex string will be prefixed with 0x
 *
 * @returns the hex encoding of the input byte array
 *
 * @throws `illegal_argument` error if the input is not a Uint8Array
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function bytesToHex(byteArray, prefix = false) {
    if (!(byteArray instanceof Uint8Array)) {
        throw new Error('illegal_argument: only byte arrays can be converted to hex encoding');
    }
    const result = u8a.toString(byteArray, 'base16');
    return prefix ? `0x${result}` : result;
}
exports.bytesToHex = bytesToHex;
/**
 * Converts a base58 string to the Uint8Array it represents.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
function base58ToBytes(s) {
    return u8a.fromString(s, 'base58btc');
}
exports.base58ToBytes = base58ToBytes;
/**
 * Converts a base58 string to the Uint8Array it represents.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
function bytesToBase58(byteArray) {
    return u8a.toString(byteArray, 'base58btc');
}
exports.bytesToBase58 = bytesToBase58;
/**
 * Converts a multibase string to the Uint8Array it represents.
 *
 * @param s - the string to be converted
 *
 * @throws if the string is not formatted correctly.
 *
 * @public
 */
function multibaseKeyToBytes(s) {
    if (s.charAt(0) !== 'z') {
        throw new Error('invalid multibase string: string is not base58 encoded (does not start with "z")');
    }
    const bytes = u8a.fromString(s.substring(1), 'base58btc');
    const props = multibaseKeyToProps(s);
    const keyLength = props.code.length / 2;
    if (props.keyType === 'RSA') {
        if (bytes[2] !== 48) {
            throw Error('Invalid RSA octet sequence');
        }
        return bytes.slice(2);
    }
    else if (props.keyType === 'Secp256r1') {
        return bytes.slice(2);
    }
    if (bytes[keyLength] !== 0x01) {
        throw Error(`Invalid multicodec value at position ${keyLength}:   ${bytes[keyLength]}`);
    }
    return bytes.slice(keyLength + 1);
}
exports.multibaseKeyToBytes = multibaseKeyToBytes;
function multibaseKeyToProps(s) {
    if (s.charAt(0) !== 'z') {
        throw new Error('invalid multibase string: string is not base58 encoded (does not start with "z")');
    }
    const bytes = u8a.fromString(s.substring(1), 'base58btc');
    const code = varint_1.default.decode(bytes);
    return getMultibasePropsByCode(code);
}
exports.multibaseKeyToProps = multibaseKeyToProps;
exports.SUPPORTED_KEY_CODECS = [
    { code: 'e7', keyType: 'Secp256k1', minLegth: 33, maxLength: 33 },
    { code: 'ec', keyType: 'X25519', minLegth: 32, maxLength: 32 },
    { code: 'ed', keyType: 'Ed25519', minLegth: 32, maxLength: 32 },
    { code: '1200', keyType: 'Secp256r1', minLegth: 33, maxLength: 34 },
    // {code: "1201", keyType: 'Secp384r1', minLegth: 49, maxLength: 49}, //TODO: Implement keytype
    // {code: "1202", keyType: 'Secp521r1', minLegth: 65, maxLength: 65}, //TODO: Implement keytype
    { code: '1205', keyType: 'RSA', minLegth: 10, maxLength: 512 }, // TODO: Lookup what we should put here
];
function getMultibasePropsByType(keytype) {
    const props = exports.SUPPORTED_KEY_CODECS.find((row) => row.keyType === keytype);
    if (!props) {
        throw Error(`Multibase not supported (yet) for key type: ${keytype}`);
    }
    return props;
}
exports.getMultibasePropsByType = getMultibasePropsByType;
function getMultibasePropsByCode(code) {
    const props = exports.SUPPORTED_KEY_CODECS.find((row) => (typeof code === 'string' ? row.code === code : row.code === code.toString(16)));
    if (!props) {
        throw Error(`Multibase not supported (yet) for code: ${code}`);
    }
    return props;
}
exports.getMultibasePropsByCode = getMultibasePropsByCode;
/**
 * Converts a Uint8Array to a multibase string.
 *
 * @param b - the array to be converted
 * @param type - the type of the key to be represented
 *
 * @throws if the array is not formatted correctly.
 *
 * @public
 */
function bytesToMultibase(byteArray, type) {
    const props = getMultibasePropsByType(type);
    if (byteArray.length < props.minLegth || byteArray.length > props.maxLength) {
        throw Error(`Length of provided bytes (${byteArray.length}) falls outside of the bounds ${props.minLegth} and ${props.maxLength}`);
    }
    const multicodec = '01';
    const varCode = Number.parseInt(props.code, 16);
    const length = props.code.length / 2;
    const varType = new Uint8Array(length);
    varint_1.default.encode(varCode, varType);
    const bytes = u8a.concatArrays([
        varType,
        props.keyType === 'RSA' || props.keyType === 'Secp256r1' ? new Uint8Array(0) : u8a.fromString(multicodec, 'base16'),
        byteArray,
    ]);
    return 'z' + u8a.toString(bytes, 'base58btc');
}
exports.bytesToMultibase = bytesToMultibase;
/**
 * Concatenates a bunch of arrays into one Uint8Array
 * @param arrays - the arrays to be concatenated
 * @param length - the maximum length of the resulting array
 *
 * @beta This API may change without a BREAKING CHANGE notice.
 */
function concat(arrays, length) {
    return u8a.concatArrays(arrays, length);
}
exports.concat = concat;
//# sourceMappingURL=encoding.js.map