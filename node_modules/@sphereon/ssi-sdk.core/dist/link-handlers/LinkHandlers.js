"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLinkHandler = exports.LinkHandlerAdapter = exports.LinkHandlers = void 0;
const ssi_types_1 = require("@sphereon/ssi-types");
const types_1 = require("./types");
/**
 * Class registering multiple LinkHandlers, allowing the developer to use a single compound link handler.
 * @implements {LinkHandler}
 * @implements {LinkHandlerRegistry}
 */
class LinkHandlers {
    constructor() {
        this._id = '_LinkHandlers';
        this._priority = types_1.DefaultLinkPriorities.DEFAULT; // Allow someone to create a new implementation with higher priority
        this._handlers = new Map();
        this._protocols = new Set();
    }
    get id() {
        return this._id;
    }
    get priority() {
        return this._priority;
    }
    get protocols() {
        return Array.from(this._protocols);
    }
    get(id) {
        return this._handlers.get(id);
    }
    supports(urlArg) {
        const url = new URL(urlArg);
        // Optimization, does not take into account regexp registrations, but these are taken care of via the handlers
        if (!Array.from(this._protocols.values()).some((predicate) => typeof predicate === 'string' ? url.protocol === predicate.toLowerCase() : predicate.test(url.protocol))) {
            return false;
        }
        return this.all().some((handler) => handler.supports(url));
    }
    handle(url, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const _a = opts !== null && opts !== void 0 ? opts : {}, { singleHandlerOnly, noExceptionOnNoHandler } = _a, otherOpts = __rest(_a, ["singleHandlerOnly", "noExceptionOnNoHandler"]);
            const handlers = this.all().filter((handler) => handler.supports(url));
            if ((handlers.length === 0 || (handlers.length === 1 && handlers[0].id === LogLinkHandler.ID)) && noExceptionOnNoHandler !== true) {
                return Promise.reject(new Error(`No link handler was registered that supports URL: ${url}`));
            }
            try {
                if (singleHandlerOnly === true) {
                    return yield handlers[0].handle(url, otherOpts);
                }
                handlers.map((handler) => __awaiter(this, void 0, void 0, function* () { return yield handler.handle(url, otherOpts); }));
            }
            catch (e) {
                console.log(`Linkhandler error: ${e.message}`, e);
                return Promise.reject(e);
            }
        });
    }
    add(handler) {
        const handlers = Array.isArray(handler) ? handler : [handler];
        handlers.forEach((handler) => {
            this._handlers.set(handler.id, handler);
            handler.protocols.forEach((protocol) => this._protocols.add(typeof protocol === 'string' ? (protocol.endsWith(':') ? protocol : `${protocol}:`) : protocol));
        });
        return this;
    }
    remove(handler) {
        const result = this._handlers.delete(typeof handler === 'string' ? handler : handler.id);
        this.rePopulateProtocols();
        return result;
    }
    has(handler) {
        return this._handlers.has(typeof handler === 'string' ? handler : handler.id);
    }
    clear() {
        this._handlers.clear();
        this.rePopulateProtocols();
        return this;
    }
    all() {
        // Returns the handlers sorted in priority order, not insertion order
        return Array.from(this._handlers.values()).sort((handler1, handler2) => { var _a, _b; return ((_a = handler1.priority) !== null && _a !== void 0 ? _a : types_1.DefaultLinkPriorities.DEFAULT) - ((_b = handler2.priority) !== null && _b !== void 0 ? _b : types_1.DefaultLinkPriorities.DEFAULT); });
    }
    rePopulateProtocols() {
        this._protocols.clear();
        this.all().forEach((handler) => handler.protocols.forEach((protocol) => this._protocols.add(protocol)));
    }
}
exports.LinkHandlers = LinkHandlers;
/**
 * LinkHandlerAdapter is an abstract class that implements the LinkHandler interface. It provides basic functionality
 * for handling links and can be extended to create custom link handler.
 *
 * @abstract
 * @implements {LinkHandler}
 */
class LinkHandlerAdapter {
    constructor(args) {
        var _a, _b, _c;
        this._id = args.id;
        this._priority = (_a = args.priority) !== null && _a !== void 0 ? _a : types_1.DefaultLinkPriorities.DEFAULT;
        this._protocols =
            (_c = (_b = args.protocols) === null || _b === void 0 ? void 0 : _b.map((protocol) => typeof protocol !== 'string' ? protocol : protocol.endsWith(':') ? protocol.toLowerCase() : `${protocol.toLowerCase()}:`)) !== null && _c !== void 0 ? _c : [];
    }
    get id() {
        return this._id;
    }
    get protocols() {
        return this._protocols;
    }
    set protocols(value) {
        this._protocols = value;
    }
    get priority() {
        return this._priority;
    }
    set priority(value) {
        this._priority = value;
    }
    handle(url, opts) {
        return Promise.reject(new Error(`Adapter does not handle a URL. Please implement`));
    }
    supports(urlArg) {
        const url = LinkHandlerAdapter.toURL(urlArg);
        return this.protocols.some((predicate) => typeof predicate === 'string' ? url.protocol === predicate.toLowerCase() : predicate.test(url.toString()));
    }
    static toURL(url) {
        return new URL(url);
    }
}
exports.LinkHandlerAdapter = LinkHandlerAdapter;
/**
 * A class that logs links.
 */
class LogLinkHandler extends LinkHandlerAdapter {
    constructor(args) {
        var _a, _b;
        super({
            id: LogLinkHandler.ID,
            protocols: (_a = args === null || args === void 0 ? void 0 : args.protocols) !== null && _a !== void 0 ? _a : [/.*/],
            priority: (_b = args === null || args === void 0 ? void 0 : args.priority) !== null && _b !== void 0 ? _b : types_1.DefaultLinkPriorities.LOWEST,
        });
    }
    handle(url) {
        return Promise.resolve(ssi_types_1.Loggers.DEFAULT.get(`sphereon:link-handler:${LogLinkHandler.ID}`).log(url));
    }
}
exports.LogLinkHandler = LogLinkHandler;
LogLinkHandler.ID = '_log';
//# sourceMappingURL=LinkHandlers.js.map