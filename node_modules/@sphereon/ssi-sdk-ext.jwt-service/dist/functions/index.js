"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJwsJsonGeneralWithIdentifiers = exports.toJwsJsonGeneral = exports.verifyJws = exports.checkAndUpdateJwtHeader = exports.createJwsJsonGeneral = exports.createJwsJsonFlattened = exports.createJwsCompact = exports.prepareJwsObject = void 0;
const ssi_sdk_ext_did_utils_1 = require("@sphereon/ssi-sdk-ext.did-utils");
const ssi_sdk_ext_identifier_resolution_1 = require("@sphereon/ssi-sdk-ext.identifier-resolution");
const ssi_sdk_ext_key_utils_1 = require("@sphereon/ssi-sdk-ext.key-utils");
const ssi_sdk_agent_config_1 = require("@sphereon/ssi-sdk.agent-config");
const utils_1 = require("@veramo/utils");
const utils_2 = require("@veramo/utils");
const u8a = __importStar(require("uint8arrays"));
const IJwtService_1 = require("../types/IJwtService");
const payloadToBytes = (payload) => {
    const isBytes = payload instanceof Uint8Array;
    const isString = typeof payload === 'string';
    return isBytes ? payload : isString ? u8a.fromString(payload, 'base64url') : u8a.fromString(JSON.stringify(payload), 'utf-8');
};
const prepareJwsObject = (args, context) => __awaiter(void 0, void 0, void 0, function* () {
    const { existingSignatures, protectedHeader, unprotectedHeader, issuer, payload, mode = 'auto', clientId, clientIdScheme } = args;
    const { noIdentifierInHeader = false } = issuer;
    const identifier = yield (0, ssi_sdk_ext_identifier_resolution_1.ensureManagedIdentifierResult)(issuer, context);
    yield (0, exports.checkAndUpdateJwtHeader)({ mode, identifier, noIdentifierInHeader, header: protectedHeader }, context);
    const isBytes = payload instanceof Uint8Array;
    const isString = typeof payload === 'string';
    if (!isBytes && !isString) {
        if (issuer.noIssPayloadUpdate !== true && !payload.iss && identifier.issuer) {
            payload.iss = identifier.issuer;
        }
        if (clientIdScheme && !payload.client_id_scheme) {
            payload.client_id_scheme = clientIdScheme;
        }
        if (clientId && !payload.client_id) {
            payload.client_id = clientId;
        }
    }
    const payloadBytes = payloadToBytes(payload);
    const base64urlHeader = (0, utils_1.encodeJoseBlob)(protectedHeader);
    const base64urlPayload = (0, utils_1.bytesToBase64url)(payloadBytes);
    return {
        jws: {
            unprotectedHeader,
            protectedHeader,
            payload: payloadBytes,
            existingSignatures,
        },
        b64: {
            protectedHeader: base64urlHeader,
            payload: base64urlPayload,
        },
        identifier,
    };
});
exports.prepareJwsObject = prepareJwsObject;
const createJwsCompact = (args, context) => __awaiter(void 0, void 0, void 0, function* () {
    const { protected: protectedHeader, payload, signature } = yield (0, exports.createJwsJsonFlattened)(args, context);
    return `${protectedHeader}.${payload}.${signature}`;
});
exports.createJwsCompact = createJwsCompact;
const createJwsJsonFlattened = (args, context) => __awaiter(void 0, void 0, void 0, function* () {
    const jws = yield (0, exports.createJwsJsonGeneral)(args, context);
    if (jws.signatures.length !== 1) {
        return Promise.reject(Error(`JWS flattened signature can only contain 1 signature. Found ${jws.signatures.length}`));
    }
    return Object.assign(Object.assign({}, jws.signatures[0]), { payload: jws.payload });
});
exports.createJwsJsonFlattened = createJwsJsonFlattened;
const createJwsJsonGeneral = (args, context) => __awaiter(void 0, void 0, void 0, function* () {
    const { payload, protectedHeader, unprotectedHeader, existingSignatures, mode, issuer } = args;
    const { b64, identifier } = yield (0, exports.prepareJwsObject)({
        protectedHeader,
        unprotectedHeader,
        payload,
        existingSignatures,
        issuer,
        mode,
    }, context);
    // const algorithm = await signatureAlgorithmFromKey({ key: identifier.key })
    const signature = yield context.agent.keyManagerSign({
        keyRef: identifier.kmsKeyRef,
        data: `${b64.protectedHeader}.${b64.payload}`,
        encoding: undefined,
    });
    const jsonSignature = {
        protected: b64.protectedHeader,
        header: unprotectedHeader,
        signature,
    };
    return {
        payload: b64.payload,
        signatures: [...(existingSignatures !== null && existingSignatures !== void 0 ? existingSignatures : []), jsonSignature],
    };
});
exports.createJwsJsonGeneral = createJwsJsonGeneral;
/**
 * Updates the JWT header to include x5c, kid, jwk objects using the supplied issuer identifier that will be used to sign. If not present will automatically make the header objects available
 * @param mode The type of header to check or include
 * @param identifier The identifier of the signer. This identifier will be used later to sign
 * @param header The JWT header
 * @param noIdentifierInHeader
 * @param context
 */
const checkAndUpdateJwtHeader = (_a, context_1) => __awaiter(void 0, [_a, context_1], void 0, function* ({ mode = 'auto', identifier, header, noIdentifierInHeader = false, }, context) {
    if (isIdentifierMode(mode, identifier.method, 'did')) {
        // kid is VM of the DID
        // @see https://datatracker.ietf.org/doc/html/rfc7515#section-4.1.4
        yield checkAndUpdateDidHeader({ header, identifier, noIdentifierInHeader }, context);
    }
    else if (isIdentifierMode(mode, identifier.method, 'x5c')) {
        // Include the x5c in the header. No kid
        // @see https://datatracker.ietf.org/doc/html/rfc7515#section-4.1.6
        yield checkAndUpdateX5cHeader({ header, identifier, noIdentifierInHeader }, context);
    }
    else if (isIdentifierMode(mode, identifier.method, 'kid', false)) {
        yield checkAndUpdateKidHeader({ header, identifier, noIdentifierInHeader }, context);
    }
    else if (isIdentifierMode(mode, identifier.method, 'jwk', false)) {
        // Include the JWK in the header as well as its kid if present
        // @see https://datatracker.ietf.org/doc/html/rfc7515#section-4.1.3
        // @see https://datatracker.ietf.org/doc/html/rfc7515#section-4.1.4
        yield checkAndUpdateJwkHeader({ header, identifier, noIdentifierInHeader }, context);
    }
    else {
        // Better safe than sorry. We could let it pass, but we want to force implementers to make a conscious choice
        return Promise.reject(`Invalid combination of JWS creation mode ${mode} and identifier method ${identifier.method} chosen`);
    }
});
exports.checkAndUpdateJwtHeader = checkAndUpdateJwtHeader;
const checkAndUpdateX5cHeader = (_b, context_2) => __awaiter(void 0, [_b, context_2], void 0, function* ({ header, identifier, noIdentifierInHeader = false, }, context) {
    const { x5c } = header;
    if (x5c) {
        // let's resolve the provided x5c to be sure
        const x5cIdentifier = yield context.agent.identifierManagedGetByX5c({ identifier: x5c });
        if (x5cIdentifier.kmsKeyRef !== identifier.kmsKeyRef) {
            return Promise.reject(Error(`An x5c header was present, but its issuer public key did not match the provided signing public key!`));
        }
    }
    else if (!noIdentifierInHeader) {
        if (!(0, ssi_sdk_ext_identifier_resolution_1.isManagedIdentifierX5cResult)(identifier)) {
            return Promise.reject(Error('No x5c header in the JWT, but mode was x5c and also no x5x identifier was provided!'));
        }
        else if (header.jwk || header.kid) {
            return Promise.reject(Error('x5c mode was choosen, but jwk or kid headers were provided. These cannot be used together!'));
        }
        header.x5c = identifier.x5c;
    }
});
const checkAndUpdateDidHeader = (_c, context_3) => __awaiter(void 0, [_c, context_3], void 0, function* ({ header, identifier, noIdentifierInHeader = false, }, context) {
    const { kid } = header;
    if (kid) {
        // let's resolve the provided x5c to be sure
        const vmIdentifier = yield context.agent.identifierManagedGetByDid({ identifier: kid });
        if (vmIdentifier.kmsKeyRef !== identifier.kmsKeyRef) {
            return Promise.reject(Error(`A kid header was present, but its value did not match the provided signing kid!`));
        }
    }
    else if (!noIdentifierInHeader) {
        if (!(0, ssi_sdk_ext_identifier_resolution_1.isManagedIdentifierDidResult)(identifier)) {
            return Promise.reject(Error('No kid header in the JWT, but mode was did and also no DID identifier was provided!'));
        }
        else if (header.jwk || header.x5c) {
            return Promise.reject(Error('did mode was chosen, but jwk or x5c headers were provided. These cannot be used together!'));
        }
        header.kid = identifier.kid;
    }
});
const checkAndUpdateJwkHeader = (_d, context_4) => __awaiter(void 0, [_d, context_4], void 0, function* ({ header, identifier, noIdentifierInHeader = false, }, context) {
    const { jwk } = header;
    if (jwk) {
        // let's resolve the provided x5c to be sure
        const jwkIdentifier = yield context.agent.identifierManagedGetByJwk({ identifier: jwk });
        if (jwkIdentifier.kmsKeyRef !== identifier.kmsKeyRef) {
            return Promise.reject(Error(`A jwk header was present, but its value did not match the provided signing jwk or kid!`));
        }
    }
    else if (!noIdentifierInHeader) {
        // We basically accept everything for this mode, as we can always create JWKs from any key
        if (header.x5c) {
            return Promise.reject(Error('jwk mode was chosen, but x5c headers were provided. These cannot be used together!'));
        }
        header.jwk = identifier.jwk;
    }
});
const checkAndUpdateKidHeader = (_e, context_5) => __awaiter(void 0, [_e, context_5], void 0, function* ({ header, identifier, noIdentifierInHeader = false, }, context) {
    const { kid } = header;
    if (kid) {
        // let's resolve the provided x5c to be sure
        const kidIdentifier = yield context.agent.identifierManagedGetByKid({ identifier: kid });
        if (kidIdentifier.kmsKeyRef !== identifier.kmsKeyRef) {
            return Promise.reject(Error(`A kid header was present, but its value did not match the provided signing kid!`));
        }
    }
    else if (!noIdentifierInHeader) {
        // We basically accept everything for this mode, as we can always create JWKs from any key
        if (header.x5c) {
            return Promise.reject(Error('kid mode was chosen, but x5c headers were provided. These cannot be used together!'));
        }
        header.kid = identifier.kid;
    }
});
const isIdentifierMode = (mode, identifierMethod, checkMode, loose = true) => {
    if (loose && (checkMode === 'jwk' || checkMode === 'kid')) {
        // we always have the kid and jwk at hand no matter the identifier method, so we are okay with that
        // todo: check the impact on the above expressions, as this will now always return true for the both of them
        return true;
    }
    if (mode === checkMode) {
        if (checkMode !== 'auto' && mode !== identifierMethod) {
            throw Error(`Provided mode ${mode} conflicts with identifier method ${identifierMethod}`);
        }
        return true;
    }
    // we always have the kid and jwk at hand no matter the identifier method, so we are okay with that
    return mode === 'auto' && identifierMethod === checkMode;
};
const verifyJws = (args, context) => __awaiter(void 0, void 0, void 0, function* () {
    const jws = yield (0, exports.toJwsJsonGeneralWithIdentifiers)(args, context);
    let errorMessages = [];
    let index = 0;
    yield Promise.all(jws.signatures.map((sigWithId) => __awaiter(void 0, void 0, void 0, function* () {
        var _f, _g;
        // If we have a specific KMS agent plugin that can do the verification prefer that over the generic verification
        index++;
        let valid;
        const data = u8a.fromString(`${sigWithId.protected}.${jws.payload}`, 'utf-8');
        const jwkInfo = sigWithId.identifier.jwks[0];
        if (((_f = sigWithId.header) === null || _f === void 0 ? void 0 : _f.alg) === 'RSA' && (0, ssi_sdk_agent_config_1.contextHasPlugin)(context, 'keyManagerVerify')) {
            const publicKeyHex = (0, ssi_sdk_ext_did_utils_1.jwkTtoPublicKeyHex)(jwkInfo.jwk);
            valid = yield context.agent.keyManagerVerify({
                signature: sigWithId.signature,
                data,
                publicKeyHex,
                type: (0, ssi_sdk_ext_key_utils_1.keyTypeFromCryptographicSuite)({ suite: (_g = jwkInfo.jwk.crv) !== null && _g !== void 0 ? _g : 'ES256' }),
                // no kms arg, as the current key manager needs a bit more work
            });
        }
        else {
            const signature = (0, utils_2.base64ToBytes)(sigWithId.signature);
            valid = yield (0, ssi_sdk_ext_key_utils_1.verifySignatureWithSubtle)({ data, signature, key: jwkInfo.jwk });
        }
        if (!valid) {
            errorMessages.push(`Signature ${index} was not valid`);
        }
        return {
            sigWithId,
            valid,
        };
    })));
    const error = errorMessages.length !== 0;
    return {
        name: 'jws',
        jws,
        error,
        critical: error,
        message: error ? errorMessages.join(', ') : 'Signature validated',
        verificationTime: new Date(),
    };
});
exports.verifyJws = verifyJws;
const toJwsJsonGeneral = (_h, context_6) => __awaiter(void 0, [_h, context_6], void 0, function* ({ jws }, context) {
    let payload;
    let signatures = [];
    if ((0, IJwtService_1.isJwsCompact)(jws)) {
        const split = jws.split('.');
        payload = split[1];
        signatures[0] = {
            protected: split[0],
            signature: split[2],
        };
    }
    else if ((0, IJwtService_1.isJwsJsonGeneral)(jws)) {
        payload = jws.payload;
        signatures = jws.signatures;
    }
    else if ((0, IJwtService_1.isJwsJsonFlattened)(jws)) {
        const { payload: _payload } = jws, signature = __rest(jws, ["payload"]);
        payload = _payload;
        signatures = [signature];
    }
    else {
        return Promise.reject(Error(`Invalid JWS supplied`));
    }
    return {
        payload,
        signatures,
    };
});
exports.toJwsJsonGeneral = toJwsJsonGeneral;
function resolveExternalIdentifierFromJwsHeader(protectedHeader, context, args) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (protectedHeader.x5c) {
            const x5c = protectedHeader.x5c;
            return yield context.agent.identifierExternalResolveByX5c(Object.assign(Object.assign({}, (_a = args.opts) === null || _a === void 0 ? void 0 : _a.x5c), { identifier: x5c, verify: true }));
        }
        else if (protectedHeader.jwk) {
            const jwk = protectedHeader.jwk;
            const x5c = jwk.x5c; // todo resolve x5u
            return yield context.agent.identifierExternalResolveByJwk(Object.assign({ identifier: protectedHeader.jwk }, (x5c && {
                x5c: Object.assign(Object.assign({}, (_b = args === null || args === void 0 ? void 0 : args.opts) === null || _b === void 0 ? void 0 : _b.x5c), { identifier: x5c }),
            })));
        }
        else if (protectedHeader.kid && protectedHeader.kid.startsWith('did:')) {
            return yield context.agent.identifierExternalResolveByDid(Object.assign(Object.assign({}, (_c = args === null || args === void 0 ? void 0 : args.opts) === null || _c === void 0 ? void 0 : _c.did), { identifier: protectedHeader.kid }));
        }
        else if (protectedHeader.alg === 'none') {
            return undefined;
        }
        else {
            return Promise.reject(Error(`We can only process DIDs, X.509 certificate chains and JWKs for signature validation at present`));
        }
    });
}
const toJwsJsonGeneralWithIdentifiers = (args, context) => __awaiter(void 0, void 0, void 0, function* () {
    const jws = yield (0, exports.toJwsJsonGeneral)(args, context);
    const signatures = (yield Promise.all(jws.signatures.map((signature) => __awaiter(void 0, void 0, void 0, function* () {
        const protectedHeader = (0, utils_1.decodeJoseBlob)(signature.protected);
        const identifier = args.jwk
            ? yield (0, ssi_sdk_ext_identifier_resolution_1.resolveExternalJwkIdentifier)({ identifier: args.jwk }, context)
            : yield resolveExternalIdentifierFromJwsHeader(protectedHeader, context, args);
        if (identifier !== undefined) {
            return Object.assign(Object.assign({}, signature), { identifier });
        }
        return undefined;
    })))).filter(signature => signature !== undefined);
    return { payload: jws.payload, signatures };
});
exports.toJwsJsonGeneralWithIdentifiers = toJwsJsonGeneralWithIdentifiers;
//# sourceMappingURL=index.js.map