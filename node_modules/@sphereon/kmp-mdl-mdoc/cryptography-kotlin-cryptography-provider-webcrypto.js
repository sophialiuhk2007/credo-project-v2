(function (factory) {
  if (typeof define === 'function' && define.amd)
    define(['exports', './cryptography-kotlin-cryptography-core.js', './kotlin-kotlin-stdlib.js'], factory);
  else if (typeof exports === 'object')
    factory(module.exports, require('./cryptography-kotlin-cryptography-core.js'), require('./kotlin-kotlin-stdlib.js'));
  else {
    if (typeof globalThis['cryptography-kotlin-cryptography-core'] === 'undefined') {
      throw new Error("Error loading module 'cryptography-kotlin-cryptography-provider-webcrypto'. Its dependency 'cryptography-kotlin-cryptography-core' was not found. Please, check whether 'cryptography-kotlin-cryptography-core' is loaded prior to 'cryptography-kotlin-cryptography-provider-webcrypto'.");
    }
    if (typeof globalThis['kotlin-kotlin-stdlib'] === 'undefined') {
      throw new Error("Error loading module 'cryptography-kotlin-cryptography-provider-webcrypto'. Its dependency 'kotlin-kotlin-stdlib' was not found. Please, check whether 'kotlin-kotlin-stdlib' is loaded prior to 'cryptography-kotlin-cryptography-provider-webcrypto'.");
    }
    globalThis['cryptography-kotlin-cryptography-provider-webcrypto'] = factory(typeof globalThis['cryptography-kotlin-cryptography-provider-webcrypto'] === 'undefined' ? {} : globalThis['cryptography-kotlin-cryptography-provider-webcrypto'], globalThis['cryptography-kotlin-cryptography-core'], globalThis['kotlin-kotlin-stdlib']);
  }
}(function (_, kotlin_dev_whyoleg_cryptography_cryptography_core, kotlin_kotlin) {
  'use strict';
  //region block: imports
  var CryptographyProvider = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.b;
  var Companion_getInstance = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.d;
  var equals = kotlin_kotlin.$_$.b9;
  var Companion_getInstance_0 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.f;
  var Companion_getInstance_1 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.g;
  var Companion_getInstance_2 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.e;
  var Companion_getInstance_3 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.n;
  var Companion_getInstance_4 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.m;
  var Companion_getInstance_5 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.l;
  var Companion_getInstance_6 = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.o;
  var SHA512_getInstance = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.k;
  var SHA384_getInstance = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.j;
  var SHA256_getInstance = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.i;
  var SHA1_getInstance = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.h;
  var THROW_CCE = kotlin_kotlin.$_$.md;
  var CryptographyAlgorithm = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.a;
  var isInterface = kotlin_kotlin.$_$.w9;
  var protoOf = kotlin_kotlin.$_$.ia;
  var initMetadataForObject = kotlin_kotlin.$_$.n9;
  var VOID = kotlin_kotlin.$_$.e;
  var lazy = kotlin_kotlin.$_$.ie;
  var initMetadataForClass = kotlin_kotlin.$_$.i9;
  var initMetadataForCompanion = kotlin_kotlin.$_$.j9;
  var CryptographyException_init_$Create$ = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.c;
  var Registry_getInstance = kotlin_dev_whyoleg_cryptography_cryptography_core.$_$.q;
  var Unit_instance = kotlin_kotlin.$_$.k4;
  var defineProp = kotlin_kotlin.$_$.z8;
  //endregion
  //region block: pre-declaration
  initMetadataForObject(WebCryptoCryptographyProvider, 'WebCryptoCryptographyProvider', VOID, CryptographyProvider);
  initMetadataForClass(WebCryptoEncodableKey, 'WebCryptoEncodableKey', VOID, VOID, VOID, [1]);
  initMetadataForClass(AesKey, 'AesKey', VOID, WebCryptoEncodableKey, VOID, [1]);
  initMetadataForClass(WebCryptoAes, 'WebCryptoAes', VOID, VOID, [CryptographyAlgorithm]);
  initMetadataForClass(WebCryptoKeyProcessor, 'WebCryptoKeyProcessor');
  initMetadataForObject(AesKeyProcessor, 'AesKeyProcessor', VOID, WebCryptoKeyProcessor);
  initMetadataForClass(AesCbcKey, 'AesCbcKey', VOID, AesKey, VOID, [1]);
  initMetadataForObject(WebCryptoAesCbc, 'WebCryptoAesCbc', VOID, WebCryptoAes, [WebCryptoAes, CryptographyAlgorithm]);
  initMetadataForClass(AesCtrKey, 'AesCtrKey', VOID, AesKey, VOID, [1]);
  initMetadataForObject(WebCryptoAesCtr, 'WebCryptoAesCtr', VOID, WebCryptoAes, [WebCryptoAes, CryptographyAlgorithm]);
  initMetadataForClass(AesGcmKey, 'AesGcmKey', VOID, AesKey, VOID, [1]);
  initMetadataForObject(WebCryptoAesGcm, 'WebCryptoAesGcm', VOID, WebCryptoAes, [WebCryptoAes, CryptographyAlgorithm]);
  initMetadataForCompanion(Companion);
  initMetadataForClass(WebCryptoDigest, 'WebCryptoDigest', VOID, VOID, [CryptographyAlgorithm], [1]);
  initMetadataForClass(EcPublicKey, 'EcPublicKey', VOID, WebCryptoEncodableKey, VOID, [1]);
  initMetadataForClass(EcPrivateKey, 'EcPrivateKey', VOID, WebCryptoEncodableKey, VOID, [1]);
  initMetadataForClass(WebCryptoEc, 'WebCryptoEc', VOID, VOID, [CryptographyAlgorithm]);
  initMetadataForObject(EcPublicKeyProcessor, 'EcPublicKeyProcessor', VOID, WebCryptoKeyProcessor);
  initMetadataForObject(EcPrivateKeyProcessor, 'EcPrivateKeyProcessor', VOID, WebCryptoKeyProcessor);
  initMetadataForClass(EcdsaKeyPair, 'EcdsaKeyPair');
  initMetadataForClass(EcdsaPublicKey, 'EcdsaPublicKey', VOID, EcPublicKey, VOID, [1]);
  initMetadataForClass(EcdsaPrivateKey, 'EcdsaPrivateKey', VOID, EcPrivateKey, VOID, [1]);
  initMetadataForObject(WebCryptoEcdsa, 'WebCryptoEcdsa', VOID, WebCryptoEc, [WebCryptoEc, CryptographyAlgorithm]);
  initMetadataForClass(HmacKey, 'HmacKey', VOID, WebCryptoEncodableKey, VOID, [1]);
  initMetadataForObject(WebCryptoHmac, 'WebCryptoHmac', VOID, VOID, [CryptographyAlgorithm]);
  initMetadataForObject(HmacKeyProcessor, 'HmacKeyProcessor', VOID, WebCryptoKeyProcessor);
  initMetadataForClass(RsaPublicKey, 'RsaPublicKey', VOID, WebCryptoEncodableKey, VOID, [1]);
  initMetadataForClass(RsaPrivateKey, 'RsaPrivateKey', VOID, WebCryptoEncodableKey, VOID, [1]);
  initMetadataForClass(WebCryptoRsa, 'WebCryptoRsa', VOID, VOID, [CryptographyAlgorithm]);
  initMetadataForObject(RsaPublicKeyProcessor, 'RsaPublicKeyProcessor', VOID, WebCryptoKeyProcessor);
  initMetadataForObject(RsaPrivateKeyProcessor, 'RsaPrivateKeyProcessor', VOID, WebCryptoKeyProcessor);
  initMetadataForClass(RsaOaepKeyPair, 'RsaOaepKeyPair');
  initMetadataForClass(RsaOaepPublicKey, 'RsaOaepPublicKey', VOID, RsaPublicKey, VOID, [1]);
  initMetadataForClass(RsaOaepPrivateKey, 'RsaOaepPrivateKey', VOID, RsaPrivateKey, VOID, [1]);
  initMetadataForObject(WebCryptoRsaOaep, 'WebCryptoRsaOaep', VOID, WebCryptoRsa, [WebCryptoRsa, CryptographyAlgorithm]);
  initMetadataForClass(RsaPkcs1KeyPair, 'RsaPkcs1KeyPair');
  initMetadataForClass(RsaPkcs1PublicKey, 'RsaPkcs1PublicKey', VOID, RsaPublicKey, VOID, [1]);
  initMetadataForClass(RsaPkcs1PrivateKey, 'RsaPkcs1PrivateKey', VOID, RsaPrivateKey, VOID, [1]);
  initMetadataForObject(WebCryptoRsaPkcs1, 'WebCryptoRsaPkcs1', VOID, WebCryptoRsa, [WebCryptoRsa, CryptographyAlgorithm]);
  initMetadataForClass(RsaPssKeyPair, 'RsaPssKeyPair');
  initMetadataForClass(RsaPssPublicKey, 'RsaPssPublicKey', VOID, RsaPublicKey, VOID, [1]);
  initMetadataForClass(RsaPssPrivateKey, 'RsaPssPrivateKey', VOID, RsaPrivateKey, VOID, [1]);
  initMetadataForObject(WebCryptoRsaPss, 'WebCryptoRsaPss', VOID, WebCryptoRsa, [WebCryptoRsa, CryptographyAlgorithm]);
  initMetadataForClass(WebCryptoKeyWrapper, 'WebCryptoKeyWrapper');
  //endregion
  function get_defaultProvider() {
    _init_properties_WebCryptoCryptographyProvider_kt__i22tls();
    return defaultProvider;
  }
  var defaultProvider;
  var WebCrypto$delegate;
  function WebCryptoCryptographyProvider() {
    WebCryptoCryptographyProvider_instance = this;
    CryptographyProvider.call(this);
  }
  protoOf(WebCryptoCryptographyProvider).g2q = function (identifier) {
    var tmp = equals(identifier, SHA1_getInstance()) ? Companion_getInstance_7().i2q_1 : equals(identifier, SHA256_getInstance()) ? Companion_getInstance_7().j2q_1 : equals(identifier, SHA384_getInstance()) ? Companion_getInstance_7().k2q_1 : equals(identifier, SHA512_getInstance()) ? Companion_getInstance_7().l2q_1 : equals(identifier, Companion_getInstance_6()) ? WebCryptoHmac_getInstance() : equals(identifier, Companion_getInstance_5()) ? WebCryptoAesCbc_getInstance() : equals(identifier, Companion_getInstance_4()) ? WebCryptoAesCtr_getInstance() : equals(identifier, Companion_getInstance_3()) ? WebCryptoAesGcm_getInstance() : equals(identifier, Companion_getInstance_2()) ? WebCryptoRsaOaep_getInstance() : equals(identifier, Companion_getInstance_1()) ? WebCryptoRsaPss_getInstance() : equals(identifier, Companion_getInstance_0()) ? WebCryptoRsaPkcs1_getInstance() : equals(identifier, Companion_getInstance()) ? WebCryptoEcdsa_getInstance() : null;
    return (tmp == null ? true : isInterface(tmp, CryptographyAlgorithm)) ? tmp : THROW_CCE();
  };
  var WebCryptoCryptographyProvider_instance;
  function WebCryptoCryptographyProvider_getInstance() {
    if (WebCryptoCryptographyProvider_instance == null)
      new WebCryptoCryptographyProvider();
    return WebCryptoCryptographyProvider_instance;
  }
  function defaultProvider$lambda() {
    _init_properties_WebCryptoCryptographyProvider_kt__i22tls();
    return WebCryptoCryptographyProvider_getInstance();
  }
  var properties_initialized_WebCryptoCryptographyProvider_kt_n89q9u;
  function _init_properties_WebCryptoCryptographyProvider_kt__i22tls() {
    if (!properties_initialized_WebCryptoCryptographyProvider_kt_n89q9u) {
      properties_initialized_WebCryptoCryptographyProvider_kt_n89q9u = true;
      defaultProvider = lazy(defaultProvider$lambda);
      WebCrypto$delegate = get_defaultProvider();
    }
  }
  function AesKey(key) {
    WebCryptoEncodableKey.call(this, key, AesKeyProcessor_getInstance());
    this.o2q_1 = key;
  }
  function WebCryptoAes(algorithmName, keyWrapper) {
    this.p2q_1 = algorithmName;
    this.q2q_1 = keyWrapper;
  }
  function AesKeyProcessor() {
    AesKeyProcessor_instance = this;
    WebCryptoKeyProcessor.call(this);
  }
  var AesKeyProcessor_instance;
  function AesKeyProcessor_getInstance() {
    if (AesKeyProcessor_instance == null)
      new AesKeyProcessor();
    return AesKeyProcessor_instance;
  }
  function AesCbcKey(key) {
    AesKey.call(this, key);
  }
  function WebCryptoAesCbc$AesCbcKey$_init_$ref_lop2vf() {
    var l = function (p0) {
      return new AesCbcKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoAesCbc() {
    WebCryptoAesCbc_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['encrypt', 'decrypt'];
    WebCryptoAes.call(this, 'AES-CBC', new WebCryptoKeyWrapper(tmp, WebCryptoAesCbc$AesCbcKey$_init_$ref_lop2vf()));
  }
  var WebCryptoAesCbc_instance;
  function WebCryptoAesCbc_getInstance() {
    if (WebCryptoAesCbc_instance == null)
      new WebCryptoAesCbc();
    return WebCryptoAesCbc_instance;
  }
  function AesCtrKey(key) {
    AesKey.call(this, key);
  }
  function WebCryptoAesCtr$AesCtrKey$_init_$ref_5qzjvv() {
    var l = function (p0) {
      return new AesCtrKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoAesCtr() {
    WebCryptoAesCtr_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['encrypt', 'decrypt'];
    WebCryptoAes.call(this, 'AES-CTR', new WebCryptoKeyWrapper(tmp, WebCryptoAesCtr$AesCtrKey$_init_$ref_5qzjvv()));
  }
  var WebCryptoAesCtr_instance;
  function WebCryptoAesCtr_getInstance() {
    if (WebCryptoAesCtr_instance == null)
      new WebCryptoAesCtr();
    return WebCryptoAesCtr_instance;
  }
  function AesGcmKey(key) {
    AesKey.call(this, key);
  }
  function WebCryptoAesGcm$AesGcmKey$_init_$ref_c6pr3f() {
    var l = function (p0) {
      return new AesGcmKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoAesGcm() {
    WebCryptoAesGcm_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['encrypt', 'decrypt'];
    WebCryptoAes.call(this, 'AES-GCM', new WebCryptoKeyWrapper(tmp, WebCryptoAesGcm$AesGcmKey$_init_$ref_c6pr3f()));
  }
  var WebCryptoAesGcm_instance;
  function WebCryptoAesGcm_getInstance() {
    if (WebCryptoAesGcm_instance == null)
      new WebCryptoAesGcm();
    return WebCryptoAesGcm_instance;
  }
  function Companion() {
    Companion_instance = this;
    this.i2q_1 = new WebCryptoDigest('SHA-1', SHA1_getInstance());
    this.j2q_1 = new WebCryptoDigest('SHA-256', SHA256_getInstance());
    this.k2q_1 = new WebCryptoDigest('SHA-384', SHA384_getInstance());
    this.l2q_1 = new WebCryptoDigest('SHA-512', SHA512_getInstance());
  }
  var Companion_instance;
  function Companion_getInstance_7() {
    if (Companion_instance == null)
      new Companion();
    return Companion_instance;
  }
  function WebCryptoDigest(algorithm, id) {
    Companion_getInstance_7();
    this.r2q_1 = algorithm;
    this.s2q_1 = id;
  }
  protoOf(WebCryptoDigest).t2q = function () {
    return this;
  };
  protoOf(WebCryptoDigest).u2q = function (dataInput) {
    nonBlocking();
  };
  function EcPublicKey(publicKey) {
    WebCryptoEncodableKey.call(this, publicKey, EcPublicKeyProcessor_getInstance());
    this.x2q_1 = publicKey;
  }
  function EcPrivateKey(privateKey) {
    WebCryptoEncodableKey.call(this, privateKey, EcPrivateKeyProcessor_getInstance());
    this.a2r_1 = privateKey;
  }
  function WebCryptoEc$keyPairWrapper$lambda($keyPairWrapper, this$0) {
    return function (it) {
      return $keyPairWrapper(this$0.e2r_1.c2r_1(it.publicKey), this$0.f2r_1.c2r_1(it.privateKey));
    };
  }
  function WebCryptoEc(algorithmName, publicKeyWrapper, privateKeyWrapper, keyPairWrapper) {
    this.d2r_1 = algorithmName;
    this.e2r_1 = publicKeyWrapper;
    this.f2r_1 = privateKeyWrapper;
    var tmp = this;
    // Inline function 'kotlin.collections.plus' call
    var this_0 = this.e2r_1.b2r_1;
    var elements = this.f2r_1.b2r_1;
    // Inline function 'kotlin.js.asDynamic' call
    tmp.g2r_1 = this_0.concat(elements);
    var tmp_0 = this;
    tmp_0.h2r_1 = WebCryptoEc$keyPairWrapper$lambda(keyPairWrapper, this);
  }
  function EcPublicKeyProcessor() {
    EcPublicKeyProcessor_instance = this;
    WebCryptoKeyProcessor.call(this);
  }
  var EcPublicKeyProcessor_instance;
  function EcPublicKeyProcessor_getInstance() {
    if (EcPublicKeyProcessor_instance == null)
      new EcPublicKeyProcessor();
    return EcPublicKeyProcessor_instance;
  }
  function EcPrivateKeyProcessor() {
    EcPrivateKeyProcessor_instance = this;
    WebCryptoKeyProcessor.call(this);
  }
  var EcPrivateKeyProcessor_instance;
  function EcPrivateKeyProcessor_getInstance() {
    if (EcPrivateKeyProcessor_instance == null)
      new EcPrivateKeyProcessor();
    return EcPrivateKeyProcessor_instance;
  }
  function EcdsaKeyPair(publicKey, privateKey) {
    this.i2r_1 = publicKey;
    this.j2r_1 = privateKey;
  }
  function EcdsaPublicKey(publicKey) {
    EcPublicKey.call(this, publicKey);
  }
  function EcdsaPrivateKey(privateKey) {
    EcPrivateKey.call(this, privateKey);
  }
  function WebCryptoEcdsa$EcdsaPublicKey$_init_$ref_5egfgi() {
    var l = function (p0) {
      return new EcdsaPublicKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoEcdsa$EcdsaPrivateKey$_init_$ref_8mqrbu() {
    var l = function (p0) {
      return new EcdsaPrivateKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoEcdsa$EcdsaKeyPair$_init_$ref_l5vyez() {
    var l = function (p0, p1) {
      return new EcdsaKeyPair(p0, p1);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoEcdsa() {
    WebCryptoEcdsa_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['verify'];
    var tmp_0 = new WebCryptoKeyWrapper(tmp, WebCryptoEcdsa$EcdsaPublicKey$_init_$ref_5egfgi());
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp_1 = ['sign'];
    var tmp_2 = new WebCryptoKeyWrapper(tmp_1, WebCryptoEcdsa$EcdsaPrivateKey$_init_$ref_8mqrbu());
    WebCryptoEc.call(this, 'ECDSA', tmp_0, tmp_2, WebCryptoEcdsa$EcdsaKeyPair$_init_$ref_l5vyez());
  }
  var WebCryptoEcdsa_instance;
  function WebCryptoEcdsa_getInstance() {
    if (WebCryptoEcdsa_instance == null)
      new WebCryptoEcdsa();
    return WebCryptoEcdsa_instance;
  }
  function HmacKey(key) {
    WebCryptoEncodableKey.call(this, key, HmacKeyProcessor_getInstance());
    this.m2r_1 = key;
  }
  function WebCryptoHmac$HmacKey$_init_$ref_enwl2t() {
    var l = function (p0) {
      return new HmacKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoHmac() {
    WebCryptoHmac_instance = this;
    var tmp = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp_0 = ['sign', 'verify'];
    tmp.n2r_1 = new WebCryptoKeyWrapper(tmp_0, WebCryptoHmac$HmacKey$_init_$ref_enwl2t());
  }
  var WebCryptoHmac_instance;
  function WebCryptoHmac_getInstance() {
    if (WebCryptoHmac_instance == null)
      new WebCryptoHmac();
    return WebCryptoHmac_instance;
  }
  function HmacKeyProcessor() {
    HmacKeyProcessor_instance = this;
    WebCryptoKeyProcessor.call(this);
  }
  var HmacKeyProcessor_instance;
  function HmacKeyProcessor_getInstance() {
    if (HmacKeyProcessor_instance == null)
      new HmacKeyProcessor();
    return HmacKeyProcessor_instance;
  }
  function RsaPublicKey(publicKey) {
    WebCryptoEncodableKey.call(this, publicKey, RsaPublicKeyProcessor_getInstance());
    this.q2r_1 = publicKey;
  }
  function RsaPrivateKey(privateKey) {
    WebCryptoEncodableKey.call(this, privateKey, RsaPrivateKeyProcessor_getInstance());
    this.t2r_1 = privateKey;
  }
  function WebCryptoRsa$keyPairWrapper$lambda($keyPairWrapper, this$0) {
    return function (it) {
      return $keyPairWrapper(this$0.v2r_1.c2r_1(it.publicKey), this$0.w2r_1.c2r_1(it.privateKey));
    };
  }
  function WebCryptoRsa(algorithmName, publicKeyWrapper, privateKeyWrapper, keyPairWrapper) {
    this.u2r_1 = algorithmName;
    this.v2r_1 = publicKeyWrapper;
    this.w2r_1 = privateKeyWrapper;
    var tmp = this;
    // Inline function 'kotlin.collections.plus' call
    var this_0 = this.v2r_1.b2r_1;
    var elements = this.w2r_1.b2r_1;
    // Inline function 'kotlin.js.asDynamic' call
    tmp.x2r_1 = this_0.concat(elements);
    var tmp_0 = this;
    tmp_0.y2r_1 = WebCryptoRsa$keyPairWrapper$lambda(keyPairWrapper, this);
  }
  function RsaPublicKeyProcessor() {
    RsaPublicKeyProcessor_instance = this;
    WebCryptoKeyProcessor.call(this);
  }
  var RsaPublicKeyProcessor_instance;
  function RsaPublicKeyProcessor_getInstance() {
    if (RsaPublicKeyProcessor_instance == null)
      new RsaPublicKeyProcessor();
    return RsaPublicKeyProcessor_instance;
  }
  function RsaPrivateKeyProcessor() {
    RsaPrivateKeyProcessor_instance = this;
    WebCryptoKeyProcessor.call(this);
  }
  var RsaPrivateKeyProcessor_instance;
  function RsaPrivateKeyProcessor_getInstance() {
    if (RsaPrivateKeyProcessor_instance == null)
      new RsaPrivateKeyProcessor();
    return RsaPrivateKeyProcessor_instance;
  }
  function RsaOaepKeyPair(publicKey, privateKey) {
    this.z2r_1 = publicKey;
    this.a2s_1 = privateKey;
  }
  function RsaOaepPublicKey(publicKey) {
    RsaPublicKey.call(this, publicKey);
  }
  function RsaOaepPrivateKey(privateKey) {
    RsaPrivateKey.call(this, privateKey);
  }
  function WebCryptoRsaOaep$RsaOaepPublicKey$_init_$ref_2xzkj4() {
    var l = function (p0) {
      return new RsaOaepPublicKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaOaep$RsaOaepPrivateKey$_init_$ref_ds5c3s() {
    var l = function (p0) {
      return new RsaOaepPrivateKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaOaep$RsaOaepKeyPair$_init_$ref_whtofn() {
    var l = function (p0, p1) {
      return new RsaOaepKeyPair(p0, p1);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaOaep() {
    WebCryptoRsaOaep_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['encrypt'];
    var tmp_0 = new WebCryptoKeyWrapper(tmp, WebCryptoRsaOaep$RsaOaepPublicKey$_init_$ref_2xzkj4());
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp_1 = ['decrypt'];
    var tmp_2 = new WebCryptoKeyWrapper(tmp_1, WebCryptoRsaOaep$RsaOaepPrivateKey$_init_$ref_ds5c3s());
    WebCryptoRsa.call(this, 'RSA-OAEP', tmp_0, tmp_2, WebCryptoRsaOaep$RsaOaepKeyPair$_init_$ref_whtofn());
  }
  var WebCryptoRsaOaep_instance;
  function WebCryptoRsaOaep_getInstance() {
    if (WebCryptoRsaOaep_instance == null)
      new WebCryptoRsaOaep();
    return WebCryptoRsaOaep_instance;
  }
  function RsaPkcs1KeyPair(publicKey, privateKey) {
    this.b2s_1 = publicKey;
    this.c2s_1 = privateKey;
  }
  function RsaPkcs1PublicKey(publicKey) {
    RsaPublicKey.call(this, publicKey);
  }
  function RsaPkcs1PrivateKey(privateKey) {
    RsaPrivateKey.call(this, privateKey);
  }
  function WebCryptoRsaPkcs1$RsaPkcs1PublicKey$_init_$ref_kiwvhe() {
    var l = function (p0) {
      return new RsaPkcs1PublicKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaPkcs1$RsaPkcs1PrivateKey$_init_$ref_y0qpl2() {
    var l = function (p0) {
      return new RsaPkcs1PrivateKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaPkcs1$RsaPkcs1KeyPair$_init_$ref_s062w5() {
    var l = function (p0, p1) {
      return new RsaPkcs1KeyPair(p0, p1);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaPkcs1() {
    WebCryptoRsaPkcs1_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['verify'];
    var tmp_0 = new WebCryptoKeyWrapper(tmp, WebCryptoRsaPkcs1$RsaPkcs1PublicKey$_init_$ref_kiwvhe());
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp_1 = ['sign'];
    var tmp_2 = new WebCryptoKeyWrapper(tmp_1, WebCryptoRsaPkcs1$RsaPkcs1PrivateKey$_init_$ref_y0qpl2());
    WebCryptoRsa.call(this, 'RSASSA-PKCS1-v1_5', tmp_0, tmp_2, WebCryptoRsaPkcs1$RsaPkcs1KeyPair$_init_$ref_s062w5());
  }
  var WebCryptoRsaPkcs1_instance;
  function WebCryptoRsaPkcs1_getInstance() {
    if (WebCryptoRsaPkcs1_instance == null)
      new WebCryptoRsaPkcs1();
    return WebCryptoRsaPkcs1_instance;
  }
  function RsaPssKeyPair(publicKey, privateKey) {
    this.d2s_1 = publicKey;
    this.e2s_1 = privateKey;
  }
  function RsaPssPublicKey(publicKey) {
    RsaPublicKey.call(this, publicKey);
  }
  function RsaPssPrivateKey(privateKey) {
    RsaPrivateKey.call(this, privateKey);
  }
  function WebCryptoRsaPss$RsaPssPublicKey$_init_$ref_o813fm() {
    var l = function (p0) {
      return new RsaPssPublicKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaPss$RsaPssPrivateKey$_init_$ref_6l5g3q() {
    var l = function (p0) {
      return new RsaPssPrivateKey(p0);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaPss$RsaPssKeyPair$_init_$ref_3h8asb() {
    var l = function (p0, p1) {
      return new RsaPssKeyPair(p0, p1);
    };
    l.callableName = '<init>';
    return l;
  }
  function WebCryptoRsaPss() {
    WebCryptoRsaPss_instance = this;
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp = ['verify'];
    var tmp_0 = new WebCryptoKeyWrapper(tmp, WebCryptoRsaPss$RsaPssPublicKey$_init_$ref_o813fm());
    // Inline function 'kotlin.arrayOf' call
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var tmp_1 = ['sign'];
    var tmp_2 = new WebCryptoKeyWrapper(tmp_1, WebCryptoRsaPss$RsaPssPrivateKey$_init_$ref_6l5g3q());
    WebCryptoRsa.call(this, 'RSA-PSS', tmp_0, tmp_2, WebCryptoRsaPss$RsaPssKeyPair$_init_$ref_3h8asb());
  }
  var WebCryptoRsaPss_instance;
  function WebCryptoRsaPss_getInstance() {
    if (WebCryptoRsaPss_instance == null)
      new WebCryptoRsaPss();
    return WebCryptoRsaPss_instance;
  }
  function nonBlocking() {
    throw CryptographyException_init_$Create$('Only non-blocking(suspend) calls are supported in WebCrypto');
  }
  function WebCryptoEncodableKey(key, keyProcessor) {
    this.f2s_1 = key;
    this.g2s_1 = keyProcessor;
  }
  function WebCryptoKeyProcessor() {
  }
  function WebCryptoKeyWrapper(usages, wrap) {
    this.b2r_1 = usages;
    this.c2r_1 = wrap;
  }
  function get_initHook() {
    return initHook;
  }
  var initHook;
  function initHook$init$() {
    Registry_getInstance().d2q(get_defaultProvider());
    return Unit_instance;
  }
  //region block: init
  initHook = initHook$init$();
  //endregion
  //region block: exports
  function $jsExportAll$(_) {
    var $dev = _.dev || (_.dev = {});
    var $dev$whyoleg = $dev.whyoleg || ($dev.whyoleg = {});
    var $dev$whyoleg$cryptography = $dev$whyoleg.cryptography || ($dev$whyoleg.cryptography = {});
    var $dev$whyoleg$cryptography$providers = $dev$whyoleg$cryptography.providers || ($dev$whyoleg$cryptography.providers = {});
    var $dev$whyoleg$cryptography$providers$webcrypto = $dev$whyoleg$cryptography$providers.webcrypto || ($dev$whyoleg$cryptography$providers.webcrypto = {});
    defineProp($dev$whyoleg$cryptography$providers$webcrypto, 'initHook', get_initHook);
  }
  $jsExportAll$(_);
  _.$jsExportAll$ = $jsExportAll$;
  //endregion
  return _;
}));

//# sourceMappingURL=cryptography-kotlin-cryptography-provider-webcrypto.js.map
