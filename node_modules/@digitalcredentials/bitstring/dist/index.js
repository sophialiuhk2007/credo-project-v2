'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base64url = require('@digitalcredentials/base64url-universal');
var pako = require('pako');
var assertions = require('./assertions.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var base64url__namespace = /*#__PURE__*/_interopNamespace(base64url);

/*!
 * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.
 */

class Bitstring {
  constructor({length, buffer} = {}) {
    if(length && buffer) {
      throw new Error('Only one of "length" or "buffer" must be given.');
    }
    if(length !== undefined) {
      assertions.isPositiveInteger(length, 'length');
    } else {
      assertions.isUint8Array(buffer, 'buffer');
    }
    if(length) {
      this.bits = new Uint8Array(Math.ceil(length / 8));
      this.length = length;
    } else {
      this.bits = new Uint8Array(buffer.buffer);
      this.length = buffer.length * 8;
    }
  }

  set(position, on) {
    assertions.isNumber(position, 'position');
    assertions.isBoolean(on, 'on');
    const {index, bit} = _parsePosition(position, this.length);
    if(on) {
      this.bits[index] |= bit;
    } else {
      this.bits[index] &= 0xFF ^ bit;
    }
  }

  get(position) {
    assertions.isNumber(position, 'position');
    const {index, bit} = _parsePosition(position, this.length);
    return !!(this.bits[index] & bit);
  }

  async encodeBits() {
    return base64url__namespace.encode(pako.gzip(this.bits));
  }

  static async decodeBits({encoded}) {
    assertions.isString(encoded, 'encoded');
    return pako.ungzip(base64url__namespace.decode(encoded));
  }

  async compressBits() {
    return pako.gzip(this.bits);
  }

  static async uncompressBits({compressed}) {
    assertions.isUint8Array(compressed, 'compressed');
    return pako.ungzip(compressed);
  }
}

function _parsePosition(position, length) {
  assertions.isNonNegativeInteger(position, 'position');
  assertions.isPositiveInteger(length, 'length');

  if(position >= length) {
    throw new Error(
      `Position "${position}" is out of range "0-${length - 1}".`);
  }
  const index = Math.floor(position / 8);
  const bit = 1 << (position % 8);
  return {index, bit};
}

exports.Bitstring = Bitstring;
