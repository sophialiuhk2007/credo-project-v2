/**
 * ec.ts
 */
import { JsonWebKeyPair, CurveTypes, HashTypes, SignatureFormat } from './typedef';
/**
 * Generate elliptic curve cryptography public/private key pair. Generated keys are in JWK.
 * @param {String} [namedCurve='P-256'] - Name of curve like 'P-256'.
 * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey }>} - The generated keys.
 * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.
 */
export declare const generateKey: (namedCurve?: CurveTypes) => Promise<JsonWebKeyPair>;
/**
 * Sign message with ECDSA.
 * @param {Uint8Array} msg - Byte array of message to be signed.
 * @param {JsonWebKey} privateJwk - Private key object in JWK format.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm used in singing, like 'SHA-256'.
 * @param {String} [signatureFormat='raw'] - Signature format. 'raw' indicates the purely raw byte array of signature. It can also take 'der', and then the output is ASN.1 DER formatted.
 * @return {Promise<Uint8Array>} - Output signature byte array in raw or der format.
 * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.
 */
export declare const sign: (msg: Uint8Array, privateJwk: JsonWebKey, hash?: HashTypes, signatureFormat?: SignatureFormat) => Promise<Uint8Array>;
/**
 * Verify signature with ECDSA.
 * @param {Uint8Array} msg - Byte array of message that have been signed.
 * @param {Uint8Array} signature - Byte array of signature for the given message.
 * @param {JsonWebKey} publicJwk - Public key object in JWK format.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm used in singing, like 'SHA-256'.
 * @param {String} [signatureFormat='raw'] - Signature format. 'raw' indicates the purely raw byte array of signature. It can also take 'der', and then the input must be in ASN.1 DER format.
 * @return {Promise<boolean>} - The result of verification.
 * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.
 */
export declare const verify: (msg: Uint8Array, signature: Uint8Array, publicJwk: JsonWebKey, hash?: HashTypes, signatureFormat?: SignatureFormat) => Promise<boolean>;
/**
 * ECDH: Elliptic Curve Diffie-Hellman Key Exchange, which derives shared secret from my private key and destination's public key.
 * **NOTE** We SHOULD NOT use the derived secret as an encryption key directly.
 * We should employ an appropriate key derivation procedure like HKDF to use the secret for symmetric key encryption.
 * @param {JsonWebKey} publicJwk - Remote public key object in JWK format.
 * @param {JsonWebKey} privateJwk - Local (my) private key object in JWK format.
 * @return {Promise<Uint8Array>} - The derived master secret via ECDH.
 * @throws {Error} - Throws if UnsupportedEnvironment, i.e., neither WebCrypto, NodeCrypto, nor PureJS codes works.
 */
export declare const deriveSecret: (publicJwk: JsonWebKey, privateJwk: JsonWebKey) => Promise<Uint8Array>;
