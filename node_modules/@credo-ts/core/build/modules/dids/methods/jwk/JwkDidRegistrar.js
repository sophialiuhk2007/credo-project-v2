"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwkDidRegistrar = void 0;
const jwk_1 = require("../../../../crypto/jose/jwk");
const DidDocumentRole_1 = require("../../domain/DidDocumentRole");
const repository_1 = require("../../repository");
const DidJwk_1 = require("./DidJwk");
class JwkDidRegistrar {
    constructor() {
        this.supportedMethods = ['jwk'];
    }
    async create(agentContext, options) {
        const didRepository = agentContext.dependencyManager.resolve(repository_1.DidRepository);
        const keyType = options.options.keyType;
        const seed = options.secret?.seed;
        const privateKey = options.secret?.privateKey;
        try {
            let key = options.options.key;
            if (key && (keyType || seed || privateKey)) {
                return {
                    didDocumentMetadata: {},
                    didRegistrationMetadata: {},
                    didState: {
                        state: 'failed',
                        reason: 'Key instance cannot be combined with key type, seed or private key',
                    },
                };
            }
            if (keyType) {
                key = await agentContext.wallet.createKey({
                    keyType,
                    seed,
                    privateKey,
                });
            }
            if (!key) {
                return {
                    didDocumentMetadata: {},
                    didRegistrationMetadata: {},
                    didState: {
                        state: 'failed',
                        reason: 'Missing key type or key instance',
                    },
                };
            }
            const jwk = (0, jwk_1.getJwkFromKey)(key);
            const didJwk = DidJwk_1.DidJwk.fromJwk(jwk);
            // Save the did so we know we created it and can issue with it
            const didRecord = new repository_1.DidRecord({
                did: didJwk.did,
                role: DidDocumentRole_1.DidDocumentRole.Created,
            });
            await didRepository.save(agentContext, didRecord);
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'finished',
                    did: didJwk.did,
                    didDocument: didJwk.didDocument,
                    secret: {
                        // FIXME: the uni-registrar creates the seed in the registrar method
                        // if it doesn't exist so the seed can always be returned. Currently
                        // we can only return it if the seed was passed in by the user. Once
                        // we have a secure method for generating seeds we should use the same
                        // approach
                        seed: options.secret?.seed,
                        privateKey: options.secret?.privateKey,
                    },
                },
            };
        }
        catch (error) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: `unknownError: ${error.message}`,
                },
            };
        }
    }
    async update() {
        return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
                state: 'failed',
                reason: `notSupported: cannot update did:jwk did`,
            },
        };
    }
    async deactivate() {
        return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
                state: 'failed',
                reason: `notSupported: cannot deactivate did:jwk did`,
            },
        };
    }
}
exports.JwkDidRegistrar = JwkDidRegistrar;
//# sourceMappingURL=JwkDidRegistrar.js.map