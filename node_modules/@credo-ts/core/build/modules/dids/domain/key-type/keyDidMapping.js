"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeyDidMappingByKeyType = getKeyDidMappingByKeyType;
exports.getKeyFromVerificationMethod = getKeyFromVerificationMethod;
exports.getSupportedVerificationMethodTypesFromKeyType = getSupportedVerificationMethodTypesFromKeyType;
const KeyType_1 = require("../../../../crypto/KeyType");
const jwk_1 = require("../../../../crypto/jose/jwk");
const error_1 = require("../../../../error");
const verificationMethod_1 = require("../verificationMethod");
const JsonWebKey2020_1 = require("../verificationMethod/JsonWebKey2020");
const bls12381g1_1 = require("./bls12381g1");
const bls12381g1g2_1 = require("./bls12381g1g2");
const bls12381g2_1 = require("./bls12381g2");
const ed25519_1 = require("./ed25519");
const keyDidJsonWebKey_1 = require("./keyDidJsonWebKey");
const secp256k1_1 = require("./secp256k1");
const x25519_1 = require("./x25519");
// TODO: Maybe we should make this dynamically?
const keyDidMapping = {
    [KeyType_1.KeyType.Ed25519]: ed25519_1.keyDidEd25519,
    [KeyType_1.KeyType.X25519]: x25519_1.keyDidX25519,
    [KeyType_1.KeyType.Bls12381g1]: bls12381g1_1.keyDidBls12381g1,
    [KeyType_1.KeyType.Bls12381g2]: bls12381g2_1.keyDidBls12381g2,
    [KeyType_1.KeyType.Bls12381g1g2]: bls12381g1g2_1.keyDidBls12381g1g2,
    [KeyType_1.KeyType.P256]: keyDidJsonWebKey_1.keyDidJsonWebKey,
    [KeyType_1.KeyType.P384]: keyDidJsonWebKey_1.keyDidJsonWebKey,
    [KeyType_1.KeyType.P521]: keyDidJsonWebKey_1.keyDidJsonWebKey,
    [KeyType_1.KeyType.K256]: secp256k1_1.keyDidSecp256k1,
};
/**
 * Dynamically creates a mapping from verification method key type to the key Did interface
 * for all key types.
 *
 * {
 *    "Ed25519VerificationKey2018": KeyDidMapping
 * }
 */
const verificationMethodKeyDidMapping = Object.values(KeyType_1.KeyType).reduce((mapping, keyType) => {
    const supported = keyDidMapping[keyType].supportedVerificationMethodTypes.reduce((accumulator, vMethodKeyType) => ({
        ...accumulator,
        [vMethodKeyType]: keyDidMapping[keyType],
    }), {});
    return {
        ...mapping,
        ...supported,
    };
}, {});
function getKeyDidMappingByKeyType(keyType) {
    const keyDid = keyDidMapping[keyType];
    if (!keyDid) {
        throw new error_1.CredoError(`Unsupported key did from key type '${keyType}'`);
    }
    return keyDid;
}
function getKeyFromVerificationMethod(verificationMethod) {
    // This is a special verification method, as it supports basically all key types.
    if ((0, JsonWebKey2020_1.isJsonWebKey2020)(verificationMethod)) {
        // TODO: move this validation to another place
        if (!verificationMethod.publicKeyJwk) {
            throw new error_1.CredoError(`Missing publicKeyJwk on verification method with type ${JsonWebKey2020_1.VERIFICATION_METHOD_TYPE_JSON_WEB_KEY_2020}`);
        }
        return (0, jwk_1.getJwkFromJson)(verificationMethod.publicKeyJwk).key;
    }
    if ((0, verificationMethod_1.isMultikey)(verificationMethod)) {
        if (!verificationMethod.publicKeyMultibase) {
            throw new error_1.CredoError(`Missing publicKeyMultibase on verification method with type ${verificationMethod_1.VERIFICATION_METHOD_TYPE_MULTIKEY}`);
        }
        return (0, verificationMethod_1.getKeyFromMultikey)(verificationMethod);
    }
    const keyDid = verificationMethodKeyDidMapping[verificationMethod.type];
    if (!keyDid) {
        throw new error_1.CredoError(`Unsupported key did from verification method type '${verificationMethod.type}'`);
    }
    return keyDid.getKeyFromVerificationMethod(verificationMethod);
}
function getSupportedVerificationMethodTypesFromKeyType(keyType) {
    const keyDid = keyDidMapping[keyType];
    if (!keyDid) {
        throw new error_1.CredoError(`Unsupported key did from key type '${keyType}'`);
    }
    return keyDid.supportedVerificationMethodTypes;
}
//# sourceMappingURL=keyDidMapping.js.map