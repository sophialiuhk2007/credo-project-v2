"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentConfig = void 0;
const constants_1 = require("../constants");
const logger_1 = require("../logger");
const types_1 = require("../types");
class AgentConfig {
    constructor(initConfig, agentDependencies) {
        this.initConfig = initConfig;
        this._endpoints = initConfig.endpoints;
        this.label = initConfig.label;
        this.logger = initConfig.logger ?? new logger_1.ConsoleLogger(logger_1.LogLevel.off);
        this.agentDependencies = agentDependencies;
    }
    /**
     * @todo move to context configuration
     */
    get walletConfig() {
        return this.initConfig.walletConfig;
    }
    get didCommMimeType() {
        return this.initConfig.didCommMimeType ?? types_1.DidCommMimeType.V1;
    }
    /**
     * Encode keys in did:key format instead of 'naked' keys, as stated in Aries RFC 0360.
     *
     * This setting will not be taken into account if the other party has previously used naked keys
     * in a given protocol (i.e. it does not support Aries RFC 0360).
     */
    get useDidKeyInProtocols() {
        return this.initConfig.useDidKeyInProtocols ?? true;
    }
    get endpoints() {
        // if endpoints is not set, return queue endpoint
        // https://github.com/hyperledger/aries-rfcs/issues/405#issuecomment-582612875
        if (!this._endpoints || this._endpoints.length === 0) {
            return [constants_1.DID_COMM_TRANSPORT_QUEUE];
        }
        return this._endpoints;
    }
    set endpoints(endpoints) {
        this._endpoints = endpoints;
    }
    get useDidSovPrefixWhereAllowed() {
        return this.initConfig.useDidSovPrefixWhereAllowed ?? false;
    }
    /**
     * @todo move to context configuration
     */
    get connectionImageUrl() {
        return this.initConfig.connectionImageUrl;
    }
    get autoUpdateStorageOnStartup() {
        return this.initConfig.autoUpdateStorageOnStartup ?? false;
    }
    get backupBeforeStorageUpdate() {
        return this.initConfig.backupBeforeStorageUpdate ?? true;
    }
    get processDidCommMessagesConcurrently() {
        return this.initConfig.processDidCommMessagesConcurrently ?? false;
    }
    extend(config) {
        return new AgentConfig({ ...this.initConfig, logger: this.logger, label: this.label, ...config }, this.agentDependencies);
    }
    toJSON() {
        return {
            ...this.initConfig,
            walletConfig: {
                ...this.walletConfig,
                key: this.walletConfig?.key ? '[*****]' : undefined,
                storage: {
                    ...this.walletConfig?.storage,
                    credentials: this.walletConfig?.storage?.credentials ? '[*****]' : undefined,
                },
            },
            logger: this.logger.logLevel,
            agentDependencies: Boolean(this.agentDependencies),
            label: this.label,
        };
    }
}
exports.AgentConfig = AgentConfig;
//# sourceMappingURL=AgentConfig.js.map